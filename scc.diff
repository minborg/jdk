diff --git a/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java b/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java
new file mode 100644
index 00000000000..c5a45cadcfa
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java
@@ -0,0 +1,128 @@
+package jdk.internal.access;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.Function;
+
+// This class is required to be able to be used very early in the boot sequence.
+// Because of this, it does not use reflection, MethodHandles, or ImmutableCollections
+/**
+ * A thread-safe, concurrent, lock-free, stable heterogeneous container.
+ * <p>
+ * The lookup of components can be eligible for constant folding if the stable component
+ * container is a VM constant (e.g., is declared as a `static final` field) and the
+ * lookup key is a constant (e.g., a class literal).
+ * <p>
+ * Except if otherwise specified, all methods throw a {@linkplain NullPointerException}
+ * if a {@code null} parameter is provided.
+ *
+ * @param <T> The common type of the components. The type can be {@linkplain Object} if
+ *            there is no common super type for the components.
+ */
+public sealed interface StableComponentContainer<T> permits StableComponentContainerImpl {
+
+    /**
+     * {@return the associated component for the provided {@code type}}
+     *
+     * @param type to use as lookup
+     * @param <C> component type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C get(Class<C> type);
+
+    /**
+     * {@return the associated component for the provided {@code type}}, or else the
+     *          provided {@code other} value.
+     *
+     * @param type to use as lookup
+     * @param other to return if there is no association to the provided {@code type}
+     *              (nullable)
+     * @param <C> component type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C orElse(Class<C> type, C other);
+
+    /**
+     * {@return {@code true} if, and only if, there is an associated component for
+     *          the provided {@code type}}, or else {@code false}}
+     *
+     * @param type to use as lookup
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    boolean isInitialized(Class<? extends T> type);
+
+    /**
+     * Associates the provided {@code type} with the provided {@code component}
+     *
+     * @param type to use as lookup
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     * @throws IllegalStateException if the provided {@code type} was already associated
+     *         with a component
+     */
+    <C extends T> void set(Class<C> type, C component);
+
+    /**
+     * If the specified type is not already associated with a component,
+     * attempts to compute its value using the given mapping
+     * function and enters it into this container.
+     *<p>
+     * If the mapping function itself throws an (unchecked) exception, the
+     * exception is rethrown, and no association is recorded. The most
+     * common usage is to construct a new object serving as an initial
+     * mapped value or memoized result, as in:
+     *
+     * <pre> {@code
+     * Component component = container.computeIfAbsent(Component.class, k -> new ComponentImpl(f(k)));
+     * }</pre>
+     *
+     * <p>The mapping function should not modify this container during computation.
+     *
+     * @implSpec
+     * The implementation is equivalent to the following steps for this
+     * {@code container}, then returning the current value or {@code null} if now
+     * absent:
+     *
+     * <pre> {@code
+     * if (!map.isInitialized(key)) {
+     *     map.put(key, mappingFunction.apply(key));
+     * }
+     * }</pre>
+     * <p>
+     * The implementation makes no guarantees about synchronization
+     * or atomicity properties of this method.
+     *
+     * @param type with which the to-be-computed component is to be associated
+     * @param mappingFunction the mapping function to compute a component
+     * @return the current (existing or computed) component associated with
+     *         the specified type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C computeIfAbsent(Class<C> type,
+                                    Function<Class<C>, ? extends C> mappingFunction);
+
+    /**
+     * {@return a new stable component container that can associate any of the provided
+     *          {@code types} to components}
+     *
+     * @param types that can be used to associate to components
+     * @param <T>   the common type of the components. The type can be {@linkplain Object}
+     *              if there is no common super type for the components.
+     */
+    static <T> StableComponentContainer<T> of(Set<Class<? extends T>> types) {
+        // TOC TOU protection and
+        // implicit null check of `types` and explicit null check on all its elements
+        final Object[] inputs = new Object[types.size()];
+        int idx = 0;
+        for (Object type : types) {
+            inputs[idx++] = Objects.requireNonNull(type);
+        }
+        return StableComponentContainerImpl.of(inputs);
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java b/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java
new file mode 100644
index 00000000000..acbb296aa98
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java
@@ -0,0 +1,142 @@
+package jdk.internal.access;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.AOTSafeClassInitializer;
+import jdk.internal.vm.annotation.ForceInline;
+import jdk.internal.vm.annotation.Stable;
+
+import java.util.Objects;
+import java.util.StringJoiner;
+import java.util.function.Function;
+
+@AOTSafeClassInitializer
+record StableComponentContainerImpl<T>(@Stable Object[] table) implements StableComponentContainer<T> {
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    @ForceInline
+    public <C extends T> C get(Class<C> type) {
+        return type.cast(componentRaw(type));
+    }
+
+    public boolean isInitialized(Class<? extends T> type) {
+        return componentRaw(type) != null;
+    }
+
+    @Override
+    public <C extends T> C orElse(Class<C> type, C other) {
+        final Object componentRaw = componentRaw(type);
+        return componentRaw == null ? other : type.cast(componentRaw);
+    }
+
+    @ForceInline
+    private Object componentRaw(Class<?> type) {
+        Objects.requireNonNull(type);
+        final int probe = probeOrThrow(type);
+        return UNSAFE.getReferenceAcquire(table, nextOffset(offsetFor(probe)));
+    }
+
+    public <C extends T> void set(Class<C> type, C component) {
+        set0(type, component, true);
+    }
+
+    @ForceInline
+    public <C extends T> void set0(Class<C> type, C component, boolean setSemantics) {
+        Objects.requireNonNull(component);
+        // Implicit null check of `type`
+        if (!type.isInstance(component)) {
+            throw new IllegalArgumentException("The component '" + component + "' is not an instance of " + type);
+        }
+        final int probe = probeOrThrow(type);
+        if (!UNSAFE.compareAndSetReference(table, nextOffset(offsetFor(probe)), null, component) && setSemantics) {
+            throw new IllegalStateException("The component is already initialized: " + type.getName());
+        }
+    }
+
+    @ForceInline
+    @Override
+    public <C extends T> C computeIfAbsent(Class<C> type,
+                                           Function<Class<C>, ? extends C> mappingFunction) {
+        Objects.requireNonNull(mappingFunction);
+        C c;
+        if ((c = orElse(type, null)) == null) {
+            // Allow racy sets as several threads can race to set the value
+            set0(type, c = mappingFunction.apply(type), false);
+        }
+        return c;
+    }
+
+    @Override
+    public String toString() {
+        return "StableComponentContainer" + associations(true);
+    }
+
+    private String associations(boolean showValues) {
+        final StringJoiner sj = new StringJoiner(", ");
+        for (int i = 0; i < table.length; i += 2) {
+            final Class<?> type = (Class<?>) table[i];
+            if (type != null) {
+                if (showValues) {
+                    final Object component = UNSAFE.getReferenceAcquire(table, nextOffset(offsetFor(i)));
+                    sj.add(type.getName() + (component != null ? "=" + component : ""));
+                } else {
+                    sj.add(type.toString());
+                }
+            }
+        }
+        return "{" + sj + "}";
+    }
+
+    @ForceInline
+    private int probeOrThrow(Class<?> type) {
+        final int probe = probe(table, type);
+        if (probe < 0) {
+            throw new IllegalArgumentException("The type '" + type.getName() + "' is outside the allowed input types: " + associations(false));
+        }
+        return probe;
+    }
+
+    @ForceInline
+    private long offsetFor(int index) {
+        return Unsafe.ARRAY_OBJECT_BASE_OFFSET + (long) index * Unsafe.ARRAY_OBJECT_INDEX_SCALE;
+    }
+
+    @ForceInline
+    private long nextOffset(long offset) {
+        return offset + Unsafe.ARRAY_OBJECT_INDEX_SCALE;
+    }
+
+    // returns index at which the probe key is present; or if absent,
+    // (-i - 1) where i is location where element should be inserted.
+    @ForceInline
+    private static int probe(Object[] table, Object pk) {
+        int idx = Math.floorMod(pk.hashCode(), table.length >> 1) << 1;
+        while (true) {
+            Object ek = table[idx];
+            if (ek == null) {
+                return -idx - 1;
+            } else if (pk.equals(ek)) {
+                return idx;
+            } else if ((idx += 2) == table.length) {
+                idx = 0;
+            }
+        }
+    }
+
+    private static int availableIndex(int probe) {
+        return -probe - 1;
+    }
+
+    static <T> StableComponentContainer<T> of(Object[] inputs) {
+        // Prepopulate all the keys upfront
+        final Object[] table = new Object[inputs.length << 2];
+        for (Object type : inputs) {
+            final int probe = probe(table, type);
+            assert probe < 0;
+            final int keyIndex = availableIndex(probe);
+            table[keyIndex] = type;
+        }
+        return new StableComponentContainerImpl<>(table);
+    }
+
+}
