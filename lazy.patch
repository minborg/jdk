From 62434b97aad81e85ef6b5c056981c39447f7c440 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 11 Apr 2023 13:45:54 +0200
Subject: [PATCH 01/16] Initial commit

---
 .../java/util/concurrent/lazy/KeyMapper.java  |   18 +
 .../java/util/concurrent/lazy/Lazy.java       |  271 ++++
 .../util/concurrent/lazy/LazyReference.java   |  411 ++++++
 .../concurrent/lazy/LazyReferenceArray.java   | 1137 +++++++++++++++++
 .../util/concurrent/lazy/package-info.java    |  177 +++
 .../lazy/BasicLazyReferenceArrayTest.java     |  227 ++++
 .../lazy/BasicLazyReferenceTest.java          |  199 +++
 .../lazy/LazyReferenceArrayMappingTest.java   |  104 ++
 8 files changed, 2544 insertions(+)
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
 create mode 100644 test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
 create mode 100644 test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
 create mode 100644 test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
new file mode 100644
index 00000000000..21c58c36f75
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
@@ -0,0 +1,18 @@
+package java.util.concurrent.lazy;
+
+import java.util.function.Function;
+
+/**
+ * This class represents a binding between a key
+ * of type K and a mapper that can compute an associated
+ * value of type V at a later time.
+ *
+ * @param key    to bind to a mapper
+ * @param mapper to be applied for the key at a later time
+ * @param <K>    the type of the key maintained by this association
+ * @param <V>    the type of mapped values
+ */
+public record KeyMapper<K, V>(
+        K key,
+        Function<? super K, ? extends V> mapper) {
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
new file mode 100644
index 00000000000..df2c0a3da03
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -0,0 +1,271 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.LazyMapper;
+import jdk.internal.util.concurrent.lazy.LazySingleMapper;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+
+/**
+ * This class provides common factories and configuration classes for all
+ * Lazy class variants.
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public final class Lazy {
+
+    // Suppresses default constructor, ensuring non-instantiability.
+    private Lazy() {}
+
+    /**
+     * The State indicates the current state of a Lazy instance:
+     * <ul>
+     *     <li><a id="empty"><b>EMPTY</b></a>
+     *     <p> No value is present (initial state).</p></li>
+     *     <li><a id="constructing"><b>CONSTRUCTING</b></a>
+     *     <p> A value is being constructed but the value is not yet available (transient state).</p></li>
+     *     <li><a id="present"><b>PRESENT</b></a>
+     *     <p> A value is present and is available via an accessor (final state).</p></li>
+     *     <li><a id="error"><b>ERROR</b></a>
+     *     <p> The construction of tha value failed and a value will never be present (final state).
+     *     The error is available via an accessor for some implementations.</p></li>
+     * </ul>
+     */
+    public enum State {
+        /**
+         * Indicates a value is not present and is not about to be constructed.
+         */
+        EMPTY,  // ABSENT?
+        /**
+         * Indicates a value is being constructed but is not yet available.
+         */
+        CONSTRUCTING, // Todo: Consider dropping this state
+        /**
+         * Indicates a value is present. This is a <em>final state</em>.
+         */
+        PRESENT,
+        /**
+         * Indicates an error has occured during construction of the value. This is a <em>final state</em>.
+         */
+        ERROR;
+
+        /**
+         * {@return if this state is final (e.g. can never change)}.
+         */
+        static boolean isFinal(State state) {
+            return state == PRESENT ||
+                    state == ERROR;
+        }
+    }
+
+    static final int EMPTY_ORDINAL = 0;
+    static final int PRESENT_ORDINAL = 2;
+    static final int ERROR_ORDINAL = 3;
+
+    /**
+     * The Evaluation indicates the erliest point at which a Lazy can be evaluated:
+     * <ul>
+     *     <li><a id="compilation"><b>COMPILATION</b></a>
+     *     <p> The value can be evaluated at compile time.</p></li>
+     *     <li><a id="distillation"><b>DISTILLATION</b></a>
+     *     <p> The value can be evaluated at distillation time.</p></li>
+     *     <li><a id="creation"><b>CREATION</b></a>
+     *     <p> The value can be evaluated upon creating the Lazy (in another background thread).</p></li>
+     *     <li><a id="at-use"><b>AT_USE</b></a>
+     *     <p> The value cannot be evaluated before being used (default evaluation).</p></li>
+     * </ul>
+     */
+    public enum Evaluation {
+        /**
+         * Indicates the value cannot be evaluated before being used (default evaluation).
+         */
+        AT_USE,
+        /**
+         * Indicates the value can be evaluated upon creating the Lazy (in the same thread)
+         */
+        CREATION,
+        /**
+         * Indicates the value can be evaluated upon creating the Lazy (in another background thread)
+         */
+        CREATION_BACKGROUND,
+        /**
+         * Indicates the value can be evaluated at distillation time.
+         */
+        DISTILLATION,
+        /**
+         * Indicates the value can be evaluated at compile time.
+         */
+        COMPILATION
+    }
+
+    /**
+     * {@return a new empty LazyReference with no pre-set supplier}.
+     * <p>
+     * If an attempt is made to invoke the {@link LazyReference#get()} method when no element is present,
+     * an exception will be thrown.
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReference<T> lazy = LazyReference.ofEmpty();
+     *    T value = lazy.getOrNull();
+     *    assertIsNull(value); // Value is initially null
+     *    // ...
+     *    T value = lazy.supplyIfEmpty(Value::new);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     *
+     * @param <T> The type of the value
+     */
+    public static <T> LazyReference<T> ofEmpty() {
+        return new LazyReference<>(Evaluation.AT_USE, null);
+    }
+
+    /**
+     * {@return a LazyReference with the provided {@code presetSupplier}}.
+     * <p>
+     * If an attempt is made to invoke the {@link LazyReference#get()} method when no element is present,
+     * the provided {@code presetSupplier} will automatically be invoked as specified by
+     * {@link LazyReference#supplyIfEmpty(Supplier)}.
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReference<T> lazy = Lazy.of(Value::new);
+     *    // ...
+     *    T value = lazy.get();
+     *}
+     *
+     * @param <T>            The type of the value
+     * @param presetSupplier to invoke when lazily constructing a value
+     */
+    public static <T> LazyReference<T> of(Supplier<? extends T> presetSupplier) {
+        Objects.requireNonNull(presetSupplier);
+        return new LazyReference<>(Evaluation.AT_USE, presetSupplier);
+    }
+
+    /**
+     * {@return a builder that can be used to build a custom LazyReference}.
+     * @param <T> type of the value the LazyReference will handle.
+     */
+    // Todo: Figure out a better way for determining the type (e.g. type token)
+    public static <T> LazyReference.Builder<T> builder() {
+        return new LazyReference.LazyReferenceBuilder<>();
+    }
+
+    /**
+     * {@return a new empty LazyReferenceArray with no pre-set mapper}.
+     * <p>
+     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} method when no element is present,
+     * an exception will be thrown.
+     * <p>
+     * {@snippet lang = java:
+     *    // Cache the first 64 users
+     *    private static final LazyReferenceArray<User> lazy = Lazy.ofEmptyArray(64);
+     *    ...
+     *    Connection c = ...
+     *    User value = lazy.computeIfEmpty(42, i -> findUserById(c, i));
+     *    assertNotNull(value); // Value is non-null
+     *}
+     *
+     * @param <T>  The type of the values
+     * @param size the size of the array
+     */
+    public static <T> LazyReferenceArray<T> ofEmptyArray(int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException();
+        }
+        return new LazyReferenceArray<>(size);
+    }
+
+    /**
+     * {@return a new empty LazyReferenceArray with a pre-set mapper}.
+     * <p>
+     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} ()} method when no element is present,
+     * the provided {@code presetMapper} will automatically be invoked as specified by
+     * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReferenceArray<Value> lazy = Lazy.ofArray(32, index -> new Value(1L << index));
+     *    // ...
+     *    Value value = lazy.get(16);
+     *}
+     *
+     * @param <T>          The type of the values
+     * @param size         the size of the array
+     * @param presetMapper to invoke when lazily constructing a value
+     */
+    public static <T> LazyReferenceArray<T> ofArray(int size,
+                                                    IntFunction<? extends T> presetMapper) {
+        if (size < 0) {
+            throw new IllegalArgumentException();
+        }
+        Objects.requireNonNull(presetMapper);
+        return new LazyReferenceArray<>(size, presetMapper);
+    }
+
+    /**
+     * {@return a Function that can map any of the provided collection of {@code keys} to values (of type V)
+     * lazily computed and recorded by the provided {@code mapper} or {@linkplain Optional#empty() Optional.empty()}
+     * if a key that is not part of the provided collection of {@code keys} is provided to the returned Function}.
+     * <p>
+     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} ()} method when no element is present,
+     * the provided {@code presetMapper} will automatically be invoked as specified by
+     * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
+     * <p>
+     * {@snippet lang = java:
+     *    Function<String, Optional<String>> pageCache = Lazy.ofMapper(
+     *                      List.of("home", "products", "contact"), DbTools::lookupPage);
+     *    // ...
+     *     String pageName = ...;
+     *
+     *    String text = pageCache.apply(pageName)
+     *                      .orElseGet(() -> lookupPage(pageName));
+     *    // ...
+     *    String lookupPage(String pageName) {
+     *      // Gets the HTML code for the named page from the content database
+     *    }
+     *}
+     *
+     * @param <K> the type of keys maintained by this mapper
+     * @param <V> the type of mapped values
+     * @param keys to be mapped
+     * @param mapper to apply when computing and recording values
+     */
+    public static <K, V> Function<K, Optional<V>> ofMapper(Collection<K> keys,
+                                                           Function<? super K, ? extends V> mapper) {
+        Objects.requireNonNull(keys);
+        Objects.requireNonNull(mapper);
+        return new LazySingleMapper<>(keys, mapper);
+    }
+
+    /**
+     * {@return a Function that will lazily evaluate and record the provided collection
+     * of {@code keyMappers} to values of type V or {@linkplain Optional#empty() Optional.empty()}
+     * if a key that is not a part of the provided collection of {@code keyMappers} is
+     * provided to the returned Function}.
+     * <p>
+     * {@snippet lang = java:
+     *    Function<Integer, Optional<String>> lazy = Lazy.ofMapper(List.of(
+     *            new KeyMapper(400, this::loadBadRequestFromDb),
+     *            new KeyMapper(401, this::loadUnaothorizedFromDb),
+     *            new KeyMapper(403, this::loadForbiddenFromDb),
+     *            new KeyMapper(404, this::loadNotFoundFromDb)
+     *         );
+     *    // ...
+     *    if (returnCode >= 400) {
+     *        response.println(lazy.apply(returnCode)
+     *                             .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
+     *    }
+     *}
+     *
+     * @param <K> the type of keys maintained by this mapper
+     * @param <V> the type of mapped values
+     * @param keyMappers to be lazily evaluated and recorded
+     */
+    public static <K, V> Function<K, Optional<V>> ofMapper(Collection<KeyMapper<K, V>> keyMappers) {
+        Objects.requireNonNull(keyMappers);
+        return new LazyMapper<>(keyMappers);
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
new file mode 100644
index 00000000000..85193b46efa
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -0,0 +1,411 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+import jdk.internal.vm.annotation.Stable;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
+
+// Build time, background, etc. computation (time shifting) (referentially transparent)
+
+/**
+ * An object reference in which the value can be lazily and atomically computed.
+ * <p>
+ * At most one invocation is made of any provided set of suppliers.
+ * <p>
+ * This contrasts to {@link AtomicReference } where any number of updates can be done
+ * and where there is no simple way to atomically compute
+ * a value (guaranteed to only be computed once) if missing.
+ * <p>
+ * The implementation is optimized for the case where there are N invocations
+ * trying to obtain the value and where N >> 1, for example where N is > 2<sup>20</sup>.
+ * <p>
+ * A supplier may return {@code null} which then will be perpetually recorded as the value.
+ * <p>
+ * This class is thread-safe.
+ * <p>
+ * The JVM may apply certain optimizations as it knows the value is updated just once
+ * at most as described by {@link Stable} as exemplified here:
+ * {@snippet lang = java:
+ *     private static final LazyReference<Value> MY_LAZY_VALUE = Lazy.of(Value::new);
+ *     // ...
+ *     public Value value() {
+ *         // This will likely be constant-folded by the JIT C2 compiler.
+ *         return MY_LAZY_VALUE.get();
+ *     }
+ *}
+ *
+ * @param <V> The type of the value to be recorded
+ * @since 22
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public final class LazyReference<V>
+        implements Supplier<V> {
+
+    // Allows access to the state variable with arbitary memory semantics
+    private static final VarHandle VALUE_HANDLE = valueHandle();
+
+    private final Lazy.Evaluation earliestEvaluation;
+    private final Semaphore semaphore;
+
+    private Supplier<? extends V> presetProvider;
+
+    @Stable
+    private Object value;
+
+    LazyReference(Lazy.Evaluation earliestEvaluation,
+                  Supplier<? extends V> presetSupplier) {
+        this.earliestEvaluation = earliestEvaluation;
+        this.presetProvider = presetSupplier;
+        this.semaphore = new Semaphore(1);
+        if (earliestEvaluation != Lazy.Evaluation.AT_USE && presetSupplier != null) {
+            // Start computing the value via a background Thread.
+            Thread.ofVirtual()
+                    .name("Lazy evaluator: " + presetSupplier)
+                    .start(() -> supplyIfEmpty0(presetSupplier));
+        }
+    }
+
+    // To be called by builders/compilers/destillers to eagerly pre-compute a value (e.g. Constable)
+    LazyReference(V value) {
+        this.earliestEvaluation = Lazy.Evaluation.CREATION;
+        this.presetProvider = null;
+        this.value = Objects.requireNonNull(value);
+        this.semaphore = null;
+    }
+
+    /**
+     * {@return The {@link Lazy.State } of this Lazy}.
+     * <p>
+     * The value is a snapshot of the current State.
+     * No attempt is made to compute a value if it is not already present.
+     * <p>
+     * If the returned State is either {@link Lazy.State#PRESENT} or
+     * {@link Lazy.State#ERROR}, it is guaranteed the state will
+     * never change in the future.
+     * <p>
+     * This method can be used to act on a value if it is present:
+     * {@snippet lang = java:
+     *     if (lazy.state() == State.PRESENT) {
+     *         T value = lazy.get();
+     *         // perform action on the value
+     *     }
+     *}
+     */
+    public Lazy.State state() {
+        Object o = value;
+        if (o != null) {
+            return o instanceof Exception
+                    ? Lazy.State.ERROR
+                    : Lazy.State.PRESENT;
+        }
+
+        if (semaphore.availablePermits() == 0) {
+            return Lazy.State.CONSTRUCTING;
+        }
+
+        semaphore.acquireUninterruptibly();
+        try {
+            o = value;
+            if (o instanceof Exception) {
+                return Lazy.State.ERROR;
+            }
+            if (o == null) {
+                return Lazy.State.EMPTY;
+            }
+            return Lazy.State.PRESENT;
+        } finally {
+            semaphore.release();
+        }
+    }
+
+    /**
+     * {@return The erliest point at which this Lazy can be evaluated}.
+     */
+    Lazy.Evaluation earliestEvaluation() {
+        return earliestEvaluation;
+    }
+
+    /**
+     * Returns the present value or, if no present value exists, atomically attempts
+     * to compute the value using the <em>pre-set {@linkplain Lazy#of(Supplier)} supplier}</em>.
+     * If no pre-set {@linkplain Lazy#of(Supplier)} supplier} exists,
+     * throws an IllegalStateException exception.
+     * <p>
+     * If the pre-set supplier itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReference<V> lazy = Lazy.of(Value::new);
+     *    // ...
+     *    V value = lazy.get();
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @return the value (pre-existing or newly computed)
+     * @throws NullPointerException   if the pre-set supplier returns {@code null}.
+     * @throws IllegalStateException  if a value was not already present and no
+     *                                pre-set supplier was specified.
+     * @throws NoSuchElementException if a supplier has previously thrown an exception.
+     */
+    @SuppressWarnings("unchecked")
+    public V get() {
+        try {
+            V v = (V) value;
+            if (v != null) {
+                return v;
+            }
+            return supplyIfEmpty0(presetProvider);
+        } catch (ClassCastException cce) {
+            throw new NoSuchElementException((Throwable) value);
+        }
+    }
+
+    /**
+     * Returns the present value or, if no present value exists, atomically attempts
+     * to compute the value using the <em>provided {@code supplier}</em>.
+     * <p>
+     * If the provided {@code supplier} itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded.  The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReference<V> lazy = Lazy.ofEmpty();
+     *    // ...
+     *    V value = lazy.supplyIfAbsent(Value::new);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param supplier to apply if no previous value exists
+     * @return the value (pre-existing or newly computed)
+     * @throws NullPointerException   if the provided {@code supplier} is {@code null} or if the provider
+     *                                {@code supplier} returns {@code null}.
+     * @throws NoSuchElementException if a supplier has previously thrown an exception.
+     */
+    public V supplyIfEmpty(Supplier<? extends V> supplier) {
+        Objects.requireNonNull(supplier);
+        return supplyIfEmpty0(supplier);
+    }
+
+    /**
+     * {@return the excption thrown by the supplier invoked or
+     * {@link Optional#empty()} if no exception was thrown}.
+     */
+    public Optional<Throwable> exception() {
+        return state() == Lazy.State.ERROR
+                ? Optional.of((Throwable) value)
+                : Optional.empty();
+    }
+
+    private V supplyIfEmpty0(Supplier<? extends V> supplier) {
+        Object o = value;
+        if (o != null) {
+            return castOrThrow(o);
+        }
+
+        // implies acquire/release semantics when entering/leaving the monitor
+        semaphore.acquireUninterruptibly();
+        try {
+            // Here, visibility is guaranteed
+            o = value;
+            if (o != null) {
+                return castOrThrow(o);
+            }
+            try {
+                if (supplier == null) {
+                    throw new IllegalStateException("No pre-set supplier given");
+                }
+
+                V v = supplier.get();
+                if (v == null) {
+                    throw new NullPointerException("Supplier returned null");
+                }
+
+                // Alt 1
+                // Prevents reordering. Changes only go in one direction.
+                // https://developer.arm.com/documentation/102336/0100/Load-Acquire-and-Store-Release-instructions
+                setValueRelease(v);
+
+                // Alt 2
+                // VarHandle.fullFence();
+                // VarHandle.fullFence();
+                return v;
+            } catch (Throwable e) {
+                // Record the throwable instead of the value.
+                // Prevents reordering.
+                setValueRelease(e);
+                // Rethrow
+                throw e;
+            } finally {
+                forgetPresetProvided();
+            }
+        } finally {
+            semaphore.release();
+        }
+    }
+
+    @Override
+    public final String toString() {
+        return getClass().getSimpleName() + "[" + switch (state()) {
+            case EMPTY -> Lazy.State.EMPTY;
+            case CONSTRUCTING -> Lazy.State.CONSTRUCTING;
+            case PRESENT -> Objects.toString(value);
+            case ERROR -> Lazy.State.ERROR + " [" + value + "]";
+        } + "]";
+    }
+
+    // Todo: Consider adding checked exception constructior. E.g. Cache value from an SQL query (Check with Ron)
+    // Todo: Consider adding a lazy that shields a POJO
+
+    /**
+     * A builder that can be used to configure a LazyReference.
+     *
+     * @param <T> the type of the value.
+     */
+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+    public interface Builder<T> {
+
+        /**
+         * {@return a builder that will use the provided {@code supplier} when
+         * eventially {@linkplain #build() building} a LazyReference}.
+         *
+         * @param supplier to use
+         */
+        Builder<T> withSupplier(Supplier<? extends T> supplier);
+
+        /**
+         * {@return a builder that will have no {@code supplier} when
+         * eventially {@linkplain #build() building} a LazyReference}.
+         */
+        Builder<T> withoutSuplier();
+
+        /**
+         * {@return a builder that will use the provided {@code earliestEvaluation} when
+         * eventially {@linkplain #build() building} a LazyReference}.
+         *
+         * @param earliestEvaluation to use
+         */
+        Builder<T> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
+
+        /**
+         * {@return a builder that will use the provided eagerly computed {@code value} when
+         * eventially {@linkplain #build() building} a LazyReference}.
+         *
+         * @param value to use
+         */
+        Builder<T> withValue(T value);
+
+        /**
+         * {@return a new LazyReference with the builder's configured setting}.
+         */
+        LazyReference<T> build();
+    }
+
+    record LazyReferenceBuilder<T>(Lazy.Evaluation binding,
+                                   Supplier<? extends T> supplier,
+                                   boolean hasValue,
+                                   T value) implements Builder<T> {
+
+        LazyReferenceBuilder() {
+            this(null);
+        }
+
+        LazyReferenceBuilder(Supplier<? extends T> supplier) {
+            this(Lazy.Evaluation.AT_USE, supplier, false, null);
+        }
+
+        @Override
+        public Builder<T> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation) {
+            return new LazyReferenceBuilder<>(Objects.requireNonNull(earliestEvaluation), supplier, hasValue, value);
+        }
+
+        @Override
+        public Builder<T> withSupplier(Supplier<? extends T> supplier) {
+            return new LazyReferenceBuilder<>(binding, Objects.requireNonNull(supplier), hasValue, value);
+        }
+
+        @Override
+        public Builder<T> withoutSuplier() {
+            return new LazyReferenceBuilder<>(binding, null, hasValue, value);
+        }
+
+        @Override
+        public Builder<T> withValue(T value) {
+            return new LazyReferenceBuilder<>(binding, supplier, true, value);
+        }
+
+        @Override
+        public LazyReference<T> build() {
+            return hasValue
+                    ? new LazyReference<>(value)
+                    : new LazyReference<>(binding, supplier);
+        }
+    }
+
+    // Private support methods
+
+    @SuppressWarnings("unchecked")
+    private V castOrThrow(Object o) {
+        if (o instanceof Throwable throwable) {
+            throw new NoSuchElementException(throwable);
+        }
+        return (V) o;
+    }
+
+    private void setValueRelease(Object value) {
+        VALUE_HANDLE.setRelease(this, value);
+    }
+
+    private void forgetPresetProvided() {
+        // Stops preventing the provider from being collected once it has been
+        // used (if initially set).
+        this.presetProvider = null;
+    }
+
+    private static VarHandle valueHandle() {
+        try {
+            return MethodHandles.lookup()
+                    .findVarHandle(LazyReference.class, "value", Object.class);
+            // .withInvokeExactBehavior(); // Make sure no boxing is made?
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
new file mode 100644
index 00000000000..c5e4b736879
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
@@ -0,0 +1,1137 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+import jdk.internal.vm.annotation.Stable;
+
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.OptionalInt;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+/**
+ * An object reference array in which the values are lazily and atomically computed.
+ * <p>
+ * At most one invocation is made of any provided set of mapper per slot.
+ * <p>
+ * This contrasts to {@link java.util.concurrent.atomic.AtomicReferenceArray } where any number of updates can be done
+ * and where there is no simple way to atomically compute
+ * a value (guaranteed to only be computed once) if missing.
+ * <p>
+ * The implementation is optimized for the case where there are N invocations
+ * trying to obtain a slot value and where N >> 1, for example where N is > 2<sup>20</sup>.
+ * <p>
+ * This class is thread-safe.
+ * <p>
+ * The JVM may apply certain optimizations as it knows the value is updated just once
+ * at most as described by {@link Stable}.
+ *
+ * @param <V> The type of the values to be recorded
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public final class LazyReferenceArray<V> implements IntFunction<V> {
+
+    private static int hi = 0;
+
+    private final IntFunction<? extends V> presetMapper;
+
+    @Stable
+    private final LazyReference<V>[] lazyReferences;
+
+    private final LazyReference<ListView> listView = Lazy.of(() -> new ListView(null));
+
+    // Todo: use an array of V and a bit-set (3 bits per element or perhaps an entire int)
+    // Todo: Bit CAS granularity. Perhaps int[] or several arrays (@Stable and non-@Stable)
+
+    @SuppressWarnings("unchecked")
+    LazyReferenceArray(int size,
+                       IntFunction<? extends V> presetMapper) {
+        lazyReferences = IntStream.range(0, size)
+                .mapToObj(i -> Lazy.<V>of(toSupplier(i, presetMapper)))
+                .toArray(LazyReference[]::new);
+        this.presetMapper = presetMapper;
+    }
+
+    @SuppressWarnings("unchecked")
+    LazyReferenceArray(int size) {
+        lazyReferences = IntStream.range(0, size)
+                .mapToObj(i -> Lazy.<V>ofEmpty())
+                .toArray(LazyReference[]::new);
+        this.presetMapper = null;
+    }
+
+    /**
+     * {@return the length of the array}.
+     */
+    public int length() {
+        return lazyReferences.length;
+    }
+
+    /**
+     * Returns the present value at the provided {@code index} or, if no present value exists,
+     * atomically attempts to compute the value using the <em>pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper}</em>.
+     * If no pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper} exists,
+     * throws an IllegalStateException exception.
+     * <p>
+     * If the pre-set mapper itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReferenceArray<V> lazy = Lazy.ofArray(64, Value::new);
+     *    // ...
+     *    V value = lazy.apply(42);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param index to the slot to be used
+     * @return the value (pre-existing or newly computed)
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     * @throws IllegalStateException          if a value was not already present and no
+     *                                        pre-set mapper was specified.
+     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
+     *                                        provided {@code index}.
+     */
+    @Override
+    public V apply(int index) {
+        return lazyReferences[index]
+                .get();
+    }
+
+    /**
+     * {@return if a value is present at the provided {@code index}}.
+     * <p>
+     * No attempt is made to compute a value if it is not already present.
+     * <p>
+     * This method can be used to act on a value if it is present:
+     * {@snippet lang = java:
+     *     if (lazy.isPresent(index)) {
+     *         V value = lazy.get(index);
+     *         // perform action on the value
+     *     }
+     *}
+     *
+     * @param index to the slot to be used
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     */
+    public Lazy.State state(int index) {
+        return lazyReferences[index]
+                .state();
+    }
+
+    /**
+     * Returns the present value at the provided {@code index} or, if no present value exists,
+     * atomically attempts to compute the value using the <em>provided {@code mappper}</em>.
+     *
+     * <p>If the mapper returns {@code null}, an exception is thrown.
+     * If the provided {@code ,mapper} itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded.  The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    LazyReference<V> lazy = LazyReferenceArray.ofEmpty();
+     *    // ...
+     *    V value = lazy.supplyIfAbsent(42, Value::new);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param index   to the slot to be used
+     * @param mappper to apply if no previous value exists
+     * @return the value (pre-existing or newly computed)
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     * @throws NullPointerException           if the provided {@code mappper} is {@code null}.
+     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
+     *                                        provided {@code index}.
+     */
+    public V computeIfEmpty(int index,
+                            IntFunction<? extends V> mappper) {
+        Objects.requireNonNull(mappper);
+        return lazyReferences[index]
+                .supplyIfEmpty(
+                        toSupplier(index, mappper));
+    }
+
+    /**
+     * {@return the excption thrown by the mapper invoked at the provided
+     * {@code index} or {@link Optional#empty()} if no exception was thrown}.
+     *
+     * @param index to the slot to be accessed
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     */
+    public Optional<Throwable> exception(int index) {
+        return lazyReferences[index]
+                .exception();
+    }
+
+    /**
+     * Returns an unmodifiable view of the elements in this LazyReferenceArray
+     * where the empty elements will be replaced with {@code null}.
+     * <p>
+     * If a mapper has previously thrown an exception for an
+     * accessed element at a certain index, accessing that index will result in
+     * a NoSuchElementException being thrown.
+     *
+     * @return a view of the elements
+     */
+    public List<V> asList() {
+        return listView.get();
+    }
+
+    /**
+     * Returns an unmodifiable view of the elements in this LazyReferenceArray
+     * where the empty elements will be replaced with the provided {@code defaulValue}.
+     * <p>
+     * If a mapper has previously thrown an exception for an
+     * accessed element at a certain index, accessing that index will result in
+     * a NoSuchElementException being thrown.
+     *
+     * @param defaulValue to use for elements not yet created
+     * @return a view of the elements
+     */
+    public List<V> asList(V defaulValue) {
+        return new ListView(defaulValue);
+    }
+
+    /**
+     * {@return A Stream with the lazy elements in this LazyReferenceArray}.
+     * <p>
+     * Upon encountering a state at position {@code index} in the array, the following actions
+     * will be taken:
+     * <ul>
+     *     <li><b>EMPTY</b>
+     *     <p>An Optional.empty() element is selected.</p></li>
+     *     <li><b>CONSTRUCTING</b>
+     *     <p>An Optional.empty() element is selected.</p></li>
+     *     <li><b>PRESENT</b>
+     *     <p>An Optional.ofNullable(lazy.get(index)) element is selected.</p></li>
+     *     <li><b>ERROR</b>
+     *     <p>A NoSuchElementException is thrown.</p></li>
+     * </ul>
+     *
+     * @throws NoSuchElementException if a slot is in state ERROR and is being accessed.
+     */
+    public Stream<Optional<V>> stream() {
+        return IntStream.range(0, length())
+                .mapToObj(i -> {
+                    var lazy = lazyReferences[i];
+                    return switch (lazy.state()) {
+                        case EMPTY, CONSTRUCTING -> Optional.empty();
+                        case PRESENT -> Optional.ofNullable(lazy.get());
+                        case ERROR -> throw new NoSuchElementException("At index: " + i);
+                    };
+                });
+    }
+
+    /**
+     * {@return A Stream with the lazy elements in this LazyReferenceArray}.
+     * <p>
+     * Upon encountering a state at position {@code index} in the array, the following actions
+     * will be taken:
+     * <ul>
+     *     <li><b>EMPTY</b>
+     *     <p>The provided {@code defaultValue} is selected.</p></li>
+     *     <li><b>CONSTRUCTING</b>
+     *     <p>The provided {@code defaultValue} is selected.</p></li>
+     *     <li><b>PRESENT</b>
+     *     <p>lazy.get(index)) is selected.</p></li>
+     *     <li><b>ERROR</b>
+     *     <p>A NoSuchElementException is thrown.</p></li>
+     * </ul>
+     *
+     * @param defaultValue the default value to use for empty/contructing slots.
+     * @throws NoSuchElementException if a slot is in state ERROR and is being accessed.
+     */
+    public Stream<V> stream(V defaultValue) {
+        return IntStream.range(0, length())
+                .mapToObj(i -> {
+                    var lazy = lazyReferences[i];
+                    return switch (lazy.state()) {
+                        case EMPTY, CONSTRUCTING -> defaultValue;
+                        case PRESENT -> lazy.get();
+                        case ERROR -> throw new NoSuchElementException("At index: " + i);
+                    };
+                });
+    }
+
+    /**
+     * Forces computation of all {@link java.util.concurrent.lazy.Lazy.State#EMPTY} slots in
+     * slot order.
+     * <p>
+     * If the pre-set mapper throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. This means, subsequent slots
+     * are not computed.
+     *
+     * @throws IllegalStateException if no pre-set mapper was specified.
+     */
+    public void force() {
+        if (presetMapper == null) {
+            throw new IllegalStateException();
+        }
+        for (LazyReference<V> lazy : lazyReferences) {
+            lazy.get();
+        }
+    }
+
+    /**
+     * Returns the lazy value associated with the provided {@code key} via the provided
+     * {@code intKeyMapper}, or, if the key is not {@linkplain IntKeyMapper#isMappable(int) mappable}, applies
+     * the provided {@code unmappableHandler} using the provided {@code key}.
+     * <p>
+     * If the underlying lazy pre-set mapper throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. If the provided {@code unmappableHandler}
+     * throws an (unchecked) exception, the exeption is rethrown.
+     * The most common usage is to construct a new object serving as a cached result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    private static IntKeyMapper KEY_MAPPER = IntKeyMapper.ofConstant(8);
+     *    LazyReferenceArray<Long> cache = LazyReferenceArray.of(8);
+     *    // ...
+     *
+     *    Long value = cache.mapAndApply(KEY_MAPPER, 16, n -> (1L << n), n -> 0);
+     *    assertEquals(65536, value); // Value is mappable and entered into and taken from the cache
+     *
+     *    Long value2 = cache.mapAndApply(KEY_MAPPER, 15, n -> (1L << n), n -> 0);
+     *    assertEquals(0, value2); // Value is not mappable and will be obtained from the provided lambda
+     *}
+     * <p>
+     * If another thread attempts to compute a lazy value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param intKeyMapper      to use when mapping a key
+     * @param key               to map to an index
+     * @param mappableHandler   to apply if the key {@linkplain IntKeyMapper#isMappable(int) is mappable}
+     * @param unmappableHandler to apply if the key {@linkplain IntKeyMapper#isMappable(int) is NOT mappable}
+     * @return a lazy value (pre-existing or newly computed) or another value from the provided {@code unmappableHandler}.
+     * @throws IllegalStateException  if a value was not already present and no
+     *                                pre-set mapper was specified.
+     * @throws NoSuchElementException if a lazy maper has previously thrown an exception for the
+     *                                provided key mapping to an associated {@code index}.
+     */
+    public V mapIntAndApply(IntKeyMapper intKeyMapper,
+                            int key,
+                            IntFunction<? extends V> mappableHandler,
+                            IntFunction<? extends V> unmappableHandler) {
+        int index = intKeyMapper.keyToIndex(key);
+        return (index >= 0 && index < lazyReferences.length)
+                ? lazyReferences[index]
+                .supplyIfEmpty(() -> mappableHandler.apply(key))
+                : unmappableHandler.apply(key);
+    }
+
+    /**
+     * Returns the lazy value associated with the provided {@code key} via the provided
+     * {@code keyMapper}, or, if the key is not {@linkplain IntKeyMapper#isMappable(int) mappable}, applies
+     * the provided {@code unmappableHandler} using the provided {@code key}.
+     * <p>
+     * If the underlying lazy pre-set mapper throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. If the provided {@code unmappableHandler}
+     * throws an (unchecked) exception, the exeption is rethrown.
+     * The most common usage is to construct a new object serving as a cached result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    private static KeyMapper<String> KEY_MAPPER = KeyMapper.ofHashing("A", "B", "C");
+     *    LazyReferenceArray<Long> cache = LazyReferenceArray.of(KEY_MAPPER.requiredLength());
+     *    // ...
+     *
+     *    String value = cache.mapAndApply(KEY_MAPPER, "B", (String s) -> s.repeat(10), (String s) -> s.repeat(10));
+     *    assertEquals("BBBBBBBBBB", value); // Value is mappable and entered into and taken from the cache
+     *
+     *    Long value2 = cache.mapAndApply(KEY_MAPPER, "Z", (String s) -> s.repeat(10), (String s) -> "");
+     *    assertEquals("", value2); // Value is not mappable and will be obtained from the provided lambda
+     *}
+     * <p>
+     * If another thread attempts to compute a lazy value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param <K>               key type
+     * @param keyMapper         to use when mapping a key
+     * @param key               to map to an index
+     * @param mappableHandler   to apply if the key {@linkplain IntKeyMapper#isMappable(int) is mappable}
+     * @param unmappableHandler to apply if the key {@linkplain IntKeyMapper#isMappable(int) is NOT mappable}
+     * @return a lazy value (pre-existing or newly computed) or another value from the provided {@code unmappableHandler}.
+     * @throws IllegalStateException  if a value was not already present and no
+     *                                pre-set mapper was specified.
+     * @throws NoSuchElementException if a lazy maper has previously thrown an exception for the
+     *                                provided key mapping to an associated {@code index}.
+     */
+    public <K> V mapAndApply(KeyMapper<? super K> keyMapper,
+                             K key,
+                             Function<? super K, ? extends V> mappableHandler,
+                             Function<? super K, ? extends V> unmappableHandler) {
+        int index = keyMapper.keyToIndex(key);
+        return (index >= 0 && index < lazyReferences.length)
+                ? lazyReferences[index]
+                .supplyIfEmpty(() -> mappableHandler.apply(key))
+                : unmappableHandler.apply(key);
+    }
+
+    @Override
+    public String toString() {
+        return IntStream.range(0, length())
+                .mapToObj(i -> lazyReferences[i])
+                .map(lazy -> switch (lazy.state()) {
+                    case EMPTY -> "-";
+                    case CONSTRUCTING -> "+";
+                    case PRESENT -> Objects.toString(lazy.get());
+                    case ERROR -> "!";
+                })
+                .collect(Collectors.joining(", ", "LazyReferenceArray[", "]"));
+    }
+
+    // Todo: Add supplyIfEmpty()?
+
+    Supplier<V> toSupplier(int index,
+                           IntFunction<? extends V> mappper) {
+        return () -> mappper.apply(index);
+    }
+
+    V getOr(int index, V defaultValue) {
+        var lazy = lazyReferences[index];
+        var state = lazy.state();
+        return switch (state) {
+            case EMPTY, CONSTRUCTING -> defaultValue;
+            case PRESENT -> lazy.get();
+            case ERROR -> throw new NoSuchElementException();
+        };
+    }
+
+    /**
+     * A key mapper than can convert between external "keys" and internal indices. The mapper
+     * is said to perform <em>inversly replicable conversions</em> meaning for a KeyMapper
+     * {@code km} used by a LazyReferenceArray {@code lra}:
+     * <ul>
+     *     <li>
+     *     The following holds: {@code km.isApplicable(lra.length))}.
+     *     </li>
+     *     <li>
+     *      For any external value {@code key} for which the mapper {@linkplain IntKeyMapper#isMappable(int)} (int) is convertible},
+     *       the following holds: {@code
+     *           fromIndex(toIndex(key)) = key
+     *       }
+     *     </li>
+     *     <li>
+     *      For any external value {@code key} for which the mapper {@linkplain IntKeyMapper#isMappable(int) is NOT convertibla},
+     *      the following will throw an ArrayOutOfBounds: {@code
+     *           lra.get(toindex(e));
+     *       }
+     *     </li>
+     * </ul>
+     * <p>
+     * Hence, the mapper is not guaranteed to always produce valid mappings but is guaranteed to provide
+     * consistent results when applied to a LazyReferenceArray.
+     * <p>
+     * The mapper is useful when using a LazyReferenceArray as a cache in cases there is not
+     * a one-to-one mapping between the keys used for caching and the actual indices in the
+     * arrary.
+     *
+     * @see LazyReferenceArray#mapIntAndApply(IntKeyMapper, int, IntFunction, IntFunction)
+     */
+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+    public interface IntKeyMapper {
+        /**
+         * {@return an index of the LazyReferenceArray by converting the
+         * provided {@code key} or, an invalid index
+         * if no such conversion can be made}.
+         *
+         * @param key to convert to an index
+         */
+        int keyToIndex(int key);
+
+        /**
+         * {@return if the provided {@code key} can be
+         * mapped to an index}.
+         *
+         * @param key to test
+         */
+        boolean isMappable(int key);
+
+        /**
+         * {@return the required array length, or if no such array length exists
+         * {@link OptionalInt#empty()}}.
+         */
+        OptionalInt requiredLength();
+
+        /**
+         * {@return if this KeyMapper can be used on an array with the
+         * provided {@code arrayLength}}.
+         *
+         * @param arrayLength to test
+         */
+        boolean checkArrayLength(int arrayLength);
+
+        /**
+         * {@return an index mapper that will map external values to
+         * indices by dividing with the provided {@code constant}}.
+         *
+         * @param constant used as a divisor when converting external values to indices.
+         * @throws IllegalArgumentException if the provided {@code constant} is zero.
+         */
+        public static IntKeyMapper ofConstant(int constant) {
+            if (constant == 0) {
+                throw new IllegalArgumentException("The constant must be non-zero");
+            }
+            return new IntKeyMapper() {
+                @Override
+                public int keyToIndex(int key) {
+                    if (!isMappable(key)) {
+                        return -1;
+                    }
+                    return key / constant;
+                }
+
+                @Override
+                public boolean isMappable(int key) {
+                    return key % constant == 0;
+                }
+
+                @Override
+                public boolean checkArrayLength(int arrayLength) {
+                    // Todo: Use the maximum array size which is smaller than Integer.MAX_VALUE
+                    return (long) arrayLength * (long) constant < Integer.MAX_VALUE;
+                }
+
+                @Override
+                public OptionalInt requiredLength() {
+                    return OptionalInt.empty();
+                }
+
+                @Override
+                public String toString() {
+                    return "IndexMapper.ofConstant(" + constant + ")";
+                }
+            };
+        }
+
+
+        /**
+         * {@return a index mapper that is a one-to-one mapper where the
+         * external values will be the same as the internal indices}.
+         */
+        // Todo: remove this
+        public static IntKeyMapper ofIdentity() {
+            return new IntKeyMapper() {
+                @Override
+                public int keyToIndex(int key) {
+                    return key;
+                }
+
+                @Override
+                public boolean isMappable(int key) {
+                    return true;
+                }
+
+                @Override
+                public boolean checkArrayLength(int arrayLength) {
+                    return true;
+                }
+
+                @Override
+                public OptionalInt requiredLength() {
+                    return OptionalInt.empty();
+                }
+            };
+        }
+    }
+
+    /**
+     * A key mapper than can convert between external "keys" and internal indices. The mapper
+     * is said to perform <em>inversly replicable conversions</em> meaning for a KeyMapper
+     * {@code km} used by a LazyReferenceArray {@code lra}:
+     * <ul>
+     *     <li>
+     *     The following holds: {@code km.isApplicable(lra.length))}.
+     *     </li>
+     *     <li>
+     *      For any external value {@code key} for which the mapper {@linkplain KeyMapper#isMappable(Object)} is convertible},
+     *       the following holds: {@code
+     *           fromIndex(toIndex(key)) = key
+     *       }
+     *     </li>
+     *     <li>
+     *      For any external value {@code key} for which the mapper {@linkplain KeyMapper#isMappable(Object) is NOT convertibla},
+     *      the following will throw an ArrayOutOfBounds: {@code
+     *           lra.get(toindex(e));
+     *       }
+     *     </li>
+     * </ul>
+     * <p>
+     * Hence, the mapper is not guaranteed to always produce valid mappings but is guaranteed to provide
+     * consistent results when applied to a LazyReferenceArray.
+     * <p>
+     * The mapper is useful when using a LazyReferenceArray as a cache in cases there is not
+     * a one-to-one mapping between the keys used for caching and the actual indices in the
+     * arrary.
+     *
+     * @param <K> key type
+     * @see LazyReferenceArray#mapIntAndApply(IntKeyMapper, int, IntFunction, IntFunction)
+     */
+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+    public interface KeyMapper<K> {
+
+        /**
+         * {@return an index of the LazyReferenceArray by converting the
+         * provided {@code key} or, an invalid index
+         * if no such conversion can be made}.
+         *
+         * @param key to convert to an index
+         */
+        int keyToIndex(K key);
+
+        /**
+         * {@return if the provided {@code key} can be
+         * mapped to an index}.
+         *
+         * @param key to test
+         */
+        boolean isMappable(K key);
+
+        /**
+         * {@return the required array length, or if no such array length exists,
+         * {@link OptionalInt#empty()}}.
+         */
+        OptionalInt requiredLength();
+
+        /**
+         * {@return if this KeyMapper can be used on an array with the
+         * provided {@code arrayLength}}.
+         *
+         * @param arrayLength to test
+         */
+        boolean checkArrayLength(int arrayLength);
+
+        // Redundant but convenient...
+
+        /**
+         * {@return a KeyMapper using a non-colliding hash algoritm}.
+         *
+         * @param objects to use as keys
+         * @param <T>     key types
+         */
+        @SafeVarargs
+        @SuppressWarnings("varargs")
+        public static <T> KeyMapper<T> ofHashing(T... objects) {
+            Objects.requireNonNull(objects);
+            return of(polynomialMapper(objects));
+        }
+
+        /**
+         * {@return a KeyMapper that uses the provided {@code mapper}}.
+         *
+         * @param mapper to use
+         * @param <T>    type of key elements.
+         */
+        public static <T> KeyMapper<T> of(PolynomialMapperConfig<T> mapper) {
+            return new KeyMapper<T>() {
+                @Override
+                public int keyToIndex(T key) {
+                    T[] keys = mapper.keys();
+                    int index = bucket(polynomialHash(mapper.polynom(), key.hashCode()), keys.length);
+                    if (Objects.equals(key, keys[index])) {
+                        return index;
+                    }
+                    int nextIndex = KeyMapper.bucket(index, keys.length);
+                    if (Objects.equals(keys, keys[nextIndex])) {
+                        return nextIndex;
+                    }
+                    return -1;
+                }
+
+                // Todo: Fix this. We do not want to comput the hash two times
+                @Override
+                public boolean isMappable(T key) {
+                    int index = keyToIndex(key);
+                    return (index >= 0 && index < mapper.keys().length);
+                }
+
+                @Override
+                public OptionalInt requiredLength() {
+                    return OptionalInt.of(mapper.keys().length);
+                }
+
+                @Override
+                public boolean checkArrayLength(int arrayLength) {
+                    return arrayLength >= requiredLength().getAsInt();
+                }
+            };
+        }
+
+        /**
+         * {@return a PolynomialMapper for the provided {@code keys}}.
+         *
+         * @param keys to use later on
+         * @param <T>  type of the keys
+         */
+        @SafeVarargs
+        @SuppressWarnings("varargs")
+        public static <T> PolynomialMapperConfig<T> polynomialMapper(T... keys) {
+            @SuppressWarnings("unchecked")
+            T[] sortedKeys = (T[]) new Object[keys.length];
+            BitSet bitSet = new BitSet(keys.length);
+            int[] primes = IntStream.of(
+                            2, 3, 5, 7, 13, 17, 21, 23, 31,
+                            127, 257, 509, 1021, 2053, 4099)
+                    // No use of primes that are an even multiple of keys.length
+                    .filter(i -> i % keys.length != 0)
+                    .toArray();
+
+            for (int l = 2; l < 5; l++) {
+                int[] polynom = new int[l];
+
+                // Todo: Replace this with a stack or an array of iterators
+                switch (l) {
+                    // Case 1 does not provide any spreading
+                    case 1: {
+                        for (int i0 = 0; i0 < primes.length; i0++) {
+                            polynom[0] = primes[i0];
+                            PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
+                            if (m != null) {
+                                return m;
+                            }
+                        }
+                    }
+                    break;
+                    case 2: {
+                        for (int i0 = 0; i0 < primes.length; i0++) {
+                            for (int i1 = 0; i1 < primes.length; i1++) {
+                                polynom[0] = primes[i0];
+                                polynom[1] = primes[i1];
+                                PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
+                                if (m != null) {
+                                    return m;
+                                }
+                            }
+                        }
+                    }
+                    break;
+                    case 3: {
+                        for (int i0 = 0; i0 < primes.length; i0++) {
+                            for (int i1 = 0; i1 < primes.length; i1++) {
+                                for (int i2 = 0; i2 < primes.length; i2++) {
+                                    polynom[0] = primes[i0];
+                                    polynom[1] = primes[i1];
+                                    polynom[2] = primes[i2];
+                                    PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
+                                    if (m != null) {
+                                        return m;
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    }
+                    case 4: {
+                        for (int i0 = 0; i0 < primes.length; i0++) {
+                            for (int i1 = 0; i1 < primes.length; i1++) {
+                                for (int i2 = 0; i2 < primes.length; i2++) {
+                                    for (int i3 = 0; i3 < primes.length; i3++) {
+                                        polynom[0] = primes[i0];
+                                        polynom[1] = primes[i1];
+                                        polynom[2] = primes[i2];
+                                        polynom[3] = primes[i3];
+                                        PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
+                                        if (m != null) {
+                                            return m;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            throw new NoSuchElementException("Unable: " + Arrays.toString(keys));
+        }
+
+        private static <T> PolynomialMapperConfig<T> tryPolynom(int[] polynom, T[] keys) {
+            BitSet bitSet = new BitSet(keys.length);
+            @SuppressWarnings("unchecked")
+            T[] sortedKeys = (T[]) new Object[keys.length];
+            for (int i = 0; i < keys.length; i++) {
+                T key = keys[i];
+                int index = bucket(polynomialHash(polynom, Objects.hash(key)), keys.length);
+                if (bitSet.get(index)) {
+                    // Try one position ahead
+                    int nextIndex = bucket(index, keys.length);
+                    bitSet.set(nextIndex);
+                    sortedKeys[nextIndex] = key;
+                } else {
+                    bitSet.set(index);
+                    sortedKeys[index] = key;
+                }
+            }
+            System.out.println("Tried (" + bitSet.cardinality() + ") " + Arrays.toString(polynom) + " -> " + Arrays.toString(sortedKeys));
+            if (bitSet.cardinality() > hi) {
+                hi = bitSet.cardinality();
+                System.out.println("hi=" + hi);
+            }
+            if (bitSet.cardinality() == keys.length) {
+                System.out.println("Yehaa!");
+                return new PolynomialMapperConfig<>(polynom, keys);
+            }
+            return null;
+        }
+
+        /**
+         * A polynomial mapper with the provided {@code polynom} and {@code keys}}.
+         *
+         * @param polynom to apply for keys
+         * @param keys    that are a member of the mapping
+         * @param <T>     type of the keys
+         */
+        @SuppressWarnings("unchecked")
+        @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+        public record PolynomialMapperConfig<T>(int[] polynom, T... keys) {
+            /**
+             * Constructor
+             *
+             * @param polynom to apply for keys
+             * @param keys    that are a member of the mapping
+             */
+            public PolynomialMapperConfig {
+                if (polynom.length <= 0) {
+                    throw new IllegalArgumentException("polynom lenght must be positive: " + polynom.length);
+                }
+            }
+
+            @Override
+            public String toString() {
+                return PolynomialMapperConfig.class.getSimpleName() + "={" +
+                        "polynom=" + Arrays.toString(polynom) + ", " +
+                        "keys=" + Arrays.toString(keys) + "}";
+            }
+        }
+
+        private static int bucket(int hash, int length) {
+            return (hash % length) & Integer.MAX_VALUE;
+        }
+
+        private static int polynomialHash(int[] polynom, int initialHash) {
+            int x = Objects.hashCode(initialHash);
+            int h = 0;
+
+            // Todo: use the Vector API
+            // 3X^2+X+3
+            for (int i = 1; i < polynom.length; i++) {
+                h += x * polynom[i];
+                x *= x;
+            }
+            h += polynom[0];
+            return h;
+        }
+    }
+
+    private final class ListView implements List<V> {
+
+        private final V defaultValue;
+        private final int begin;
+        private final int end;
+
+        ListView(int begin,
+                 int end,
+                 V defaultValue) {
+            if (begin < 0) {
+                throw new IndexOutOfBoundsException("begin: " + begin);
+            }
+            if (end > LazyReferenceArray.this.length()) {
+                throw new IndexOutOfBoundsException("end: " + begin);
+            }
+            this.begin = begin;
+            this.end = end;
+            this.defaultValue = defaultValue;
+        }
+
+        ListView(V defaultValue) {
+            this(0, LazyReferenceArray.this.length(), defaultValue);
+        }
+
+        @Override
+        public int size() {
+            return end - begin;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return size() == 0;
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            for (int i = begin; i < end; i++) {
+                if (Objects.equals(0, getOr(i, defaultValue))) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public Iterator<V> iterator() {
+            return new ListIteratorView(0, length(), null);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return IntStream.range(0, size())
+                    .mapToObj(i -> LazyReferenceArray.this.getOr(i, defaultValue))
+                    .toArray();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public <T1> T1[] toArray(T1[] a) {
+            if (a.length < size()) {
+                return (T1[]) Arrays.copyOf(toArray(), size(), a.getClass());
+            }
+            System.arraycopy(toArray(), 0, a, 0, size());
+            if (a.length > size())
+                a[size()] = null;
+            return a;
+        }
+
+        @Override
+        public boolean add(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            for (Object e : c)
+                if (!contains(e))
+                    return false;
+            return true;
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean addAll(int index, Collection<? extends V> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void clear() {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V get(int index) {
+            return getOr(index, defaultValue);
+        }
+
+        @Override
+        public V set(int index, V element) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void add(int index, V element) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V remove(int index) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public int indexOf(Object o) {
+            for (int i = 0; i < size(); i++) {
+                if (Objects.equals(o, getOr(i, defaultValue))) {
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        @Override
+        public int lastIndexOf(Object o) {
+            for (int i = size() - 1; i >= 0; i--) {
+                if (Objects.equals(o, getOr(i, defaultValue))) {
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        @Override
+        public ListIterator<V> listIterator() {
+            return new ListIteratorView(defaultValue);
+        }
+
+        @Override
+        public ListIterator<V> listIterator(int index) {
+            return new ListIteratorView(index, length(), defaultValue);
+        }
+
+        @Override
+        public List<V> subList(int fromIndex, int toIndex) {
+            if (fromIndex < 0) {
+                throw new IndexOutOfBoundsException("fromIndex: " + fromIndex);
+            }
+            if (toIndex > size()) {
+                throw new IndexOutOfBoundsException("toIndex: " + toIndex);
+            }
+            if (fromIndex > toIndex) {
+                throw new IndexOutOfBoundsException("fromIndex > toIndex: " + fromIndex + ", " + toIndex);
+            }
+            return new ListView(begin + fromIndex, begin + toIndex, defaultValue);
+        }
+
+        @Override
+        public void sort(Comparator<? super V> c) {
+            throw newUnsupportedOperation();
+        }
+    }
+
+    final class ListIteratorView implements ListIterator<V> {
+
+        private final V defaultValue;
+        private final int begin;
+        private final int end;
+        private int cursor;
+
+        private ListIteratorView(V defaultValue) {
+            this(0, LazyReferenceArray.this.length(), defaultValue);
+        }
+
+        private ListIteratorView(int begin,
+                                 int end,
+                                 V defaultValue) {
+            this.begin = begin;
+            this.end = end;
+            this.defaultValue = defaultValue;
+            this.cursor = begin;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor < end;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return cursor != begin;
+        }
+
+        @Override
+        public V previous() {
+            int i = cursor - 1;
+            if (i < begin)
+                throw new NoSuchElementException();
+            cursor = i;
+            return getOr(i, defaultValue);
+        }
+
+        @Override
+        public int nextIndex() {
+            return cursor;
+        }
+
+        @Override
+        public int previousIndex() {
+            return cursor - 1;
+        }
+
+        @Override
+        public void set(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void add(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V next() {
+            var i = cursor + 1;
+            if (i >= end) {
+                throw new NoSuchElementException();
+            }
+            cursor = i;
+            return getOr(i, defaultValue);
+        }
+
+        @Override
+        public void remove() {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super V> action) {
+            for (; cursor < end; cursor++) {
+                action.accept(getOr(cursor, defaultValue));
+            }
+        }
+    }
+
+    private UnsupportedOperationException newUnsupportedOperation() {
+        return new UnsupportedOperationException("Not supported on an unmodifiable list.");
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
new file mode 100644
index 00000000000..2ddcb9353fc
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * A small toolkit of classes that support lock-free, thread-safe
+ * use of lazy initialized values with superior performance.
+ *
+ * <h2 id="lazy">Lazy</h2>
+ *
+ * Instances of the many lazy types are obtained form the {@link java.util.concurrent.lazy.Lazy} class
+ * using several factories and builders.
+ *
+ * <h3 id="lazyreference">LazyReference</h3>
+ *
+ * For example, Lazy can provide atomic
+ * lazy evaluation using a <em>preset-supplier</em>:
+ *
+ * {@snippet lang = java :
+ * class Foo {
+ *   private static final LazyReference<Bar> BAR = Lazy.of(Bar::new);
+ *   public Bar bar() {
+ *     return BAR.get(); // Bar is computed here on first invocation
+ *   }
+ * }
+ *}
+ *
+ * On some occations, a preset-suppler might not be known a priori or the
+ * lazy value to compute might depend on values not know at declaration time. In
+ * such cases, an empty LazyReference can be obtained and used as exemplified below:
+ * {@snippet lang = java:
+ *     LazyReference<String> lazy = Lazy.ofEmpty();
+ *     ...
+ *     String color = "brown";
+ *     ...
+ *     String fox = lazy.supplyIfEmpty(() -> "The quck " + color + " fox");
+ *}
+ *
+ * A custom configurable LazyReference can be obtained via the
+ * {@linkplain java.util.concurrent.lazy.Lazy#builder() builder} method.
+ * Here is how a lazy value can be computed in the background and may already be computed
+ * when first referenced from user code:
+ * {@snippet lang = java:
+ *        LazyReference<Foo> lazy = Lazy.<Foo>builder()
+ *                 .withSupplier(Foo::new)
+ *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+ *                 .build();
+ *
+ *         Thread.sleep(1000);
+ *
+ *         // lazy is likely already pre-computed here
+ *         System.out.println("lazy.get() = " + lazy.get());
+ * }
+ *
+ * {@code LazyReference<T>} implements {@code Supplier<T>} allowing simple interoperability with legacy code
+ * and less specific type declaration as shown hereunder:
+ * {@snippet lang = java:
+ *    Suppler<Foo> eagerFoo = new Foo();
+ *    ...
+ *    Supplier<Foo> fooLazyCache = Lazy.of(eagerFoo);
+ *    ...
+ *    Foo theFoo = fooLazyCache.get();
+ * }
+ *
+ * <h3 id="lazyarray">LazyArray</h3>
+ *
+ * Arrays of lazy values (i.e. {@link java.util.concurrent.lazy.LazyReferenceArray}) can also be
+ * obtained via {@link java.util.concurrent.lazy.Lazy} factory methods in the same way as for LazyReference instance but with
+ * an extra initial arity, indicating the desired length of the array:
+ * {@snippet lang = java:
+ *    LazyReferenceArray<Value> lazy = Lazy.ofArray(32, index -> new Value(1L << index));
+ *    // ...
+ *    Value value = lazy.get(16);
+ * }
+ * As can be seen above, an array takes an IntFunction rather than a Supplier, allowing custom values to be
+ * computed and entered into the array depending on the current index being used.
+ *
+ * As was the case for LazyReference, empty LazyReference arrays can also be constructed, allowing
+ * lazy mappers known at a later stage to be used:
+ * {@snippet lang = java:
+ *    // Cache the first 64 users
+ *    private static final LazyReferenceArray<User> lazy = Lazy.ofEmptyArray(64);
+ *    ...
+ *    Connection c = ...
+ *    User value = lazy.computeIfEmpty(42, i -> findUserById(c, i));
+ *    assertNotNull(value); // Value is non-null
+ * }
+ *
+ * {@code LazyReferenceArray<T>} implements {@code IntFunction<T>} allowing simple interoperability with legacy code
+ * and less specific type declaration as shown hereunder:
+ * {@snippet lang = java:
+ *    IntFunction<Foo> eagerFoo = index -> new Foo(index);
+ *    ...
+ *    IntSupplier<Foo> fooLazyCache = Lazy.ofArray(64, eagerFoo);
+ *    ...
+ *    Foo foo42 = fooLazyCache.apply(42);
+ * }
+ *
+ * Todo: Describe IntKeyMapper and
+ *
+ * <h3 id="lazymapper">LazyMapper</h3>
+ * When several lazy values are to be held and accessible via arbitary keys of type K, general mappers can be
+ * obtained for any pre-given collection of keys. Even though this could be modelled
+ * directly by users via a second level of regular Java Maps, there are special constructs available that
+ * provide equivialent functionality but with potentially better performance and lower memory usage.
+ * {@snippet lang = java:
+ *    Function<String, Optional<String>> pageCache = Lazy.ofMapper(
+ *                      List.of("home", "products", "contact"), DbTools::lookupPage);
+ *    // ...
+ *     String pageName = ...;
+ *
+  *    String text = pageCache.apply(pageName)
+ *                      .orElseGet(() -> lookupPage(pageName));
+ *    // ...
+ *    String lookupPage(String pageName) {
+ *      // Gets the HTML code for the named page from the content database
+ *    }
+ *}
+ * Individual key mappers can also be provided via a collection of
+ * {@linkplain java.util.concurrent.lazy.KeyMapper key mappers} as shown in this example:
+ * {@snippet lang = java:
+ *    Function<Integer, Optional<String>> lazy = Lazy.ofMapper(List.of(
+ *            new KeyMapper(400, this::loadBadRequestFromDb),
+ *            new KeyMapper(401, this::loadUnaothorizedFromDb),
+ *            new KeyMapper(403, this::loadForbiddenFromDb),
+ *            new KeyMapper(404, this::loadNotFoundFromDb)
+ *         );
+ *    // ...
+ *    if (returnCode >= 400) {
+ *        response.println(lazy.apply(returnCode)
+ *                             .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
+ *    }
+ *}
+ *
+ * <h3 id="general">General Properties of the Lazy Constructs</h3>
+ *
+ * All methods of the classes in this package will throw a {@link NullPointerException}
+ * if a reference parameter is {@code null}.
+ *
+ * All lazy constucts are nullofobic meaning if nullablilty for values stores is desired,
+ * the value has to be modelled using a construct that can express a null value in an explicit way such as
+ * {@link java.util.Optional#empty()}:
+ * {@snippet lang = java:
+ *   Supplier<Optional<Color>> backgroundColor = Lazy.of(this::calculateBgColor);
+ *   ...
+ *   var bg = backgroundColor.get()
+ *                .orElse("<none>");
+ *   ...
+ *   private Optional<Color> calculateBgColor() {
+ *       ...
+ *   }
+ * }
+ *
+ * @since 22
+ */
+package java.util.concurrent.lazy;
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
new file mode 100644
index 00000000000..52c9693f4c5
--- /dev/null
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Verify basic BasicLazyReferenceArray operations
+ * @run junit BasicLazyReferenceArrayTest
+ */
+
+import org.junit.jupiter.api.*;
+
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.stream.IntStream;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+final class BasicLazyReferenceArrayTest {
+
+    private static final int SIZE = 63;
+    private static final int INDEX = 13;
+
+    LazyReferenceArray<Integer> lazy;
+    CountingIntegerMapper mapper;
+
+    @BeforeEach
+    void setup() {
+        lazy = Lazy.ofEmptyArray(SIZE);
+        mapper = new CountingIntegerMapper(SIZE);
+    }
+
+    @Test
+    void compute() {
+        Integer val = lazy.computeIfEmpty(INDEX, mapper);
+        assertEquals(INDEX, val);
+        assertEquals(1, mapper.invocations(INDEX));
+        Integer val2 = lazy.computeIfEmpty(INDEX, mapper);
+        assertEquals(INDEX, val);
+        assertEquals(1, mapper.invocations(INDEX));
+    }
+
+    @Test
+    void nulls() {
+        // Mapper is null
+        assertThrows(NullPointerException.class,
+                () -> lazy.computeIfEmpty(INDEX, null));
+        // Mapper returns null
+        assertThrows(NullPointerException.class,
+                () -> lazy.computeIfEmpty(INDEX, i -> null));
+    }
+
+    @Test
+    void noPresetGet() {
+        assertThrows(IllegalStateException.class,
+                () -> lazy.apply(INDEX));
+    }
+
+    @Test
+    void state() {
+        assertEquals(Lazy.State.EMPTY, lazy.state(INDEX));
+        Integer val = lazy.computeIfEmpty(INDEX, mapper);
+        assertEquals(Lazy.State.PRESENT, lazy.state(INDEX));
+    }
+
+    @Test
+    void presetMapperBasic() {
+        LazyReferenceArray<Integer> presetLazy = Lazy.ofArray(SIZE, mapper);
+        assertEquals(0, mapper.invocations(INDEX));
+        for (int i = 0; i < 2; i++) {
+            assertEquals(INDEX, presetLazy.apply(INDEX));
+            assertEquals(1, mapper.invocations(INDEX));
+        }
+    }
+
+    @Test
+    void presetMapperNullMapping() {
+        // Mapper is null
+        assertThrows(NullPointerException.class,
+                () -> Lazy.ofArray(SIZE, null));
+        // Mapper returns null
+        assertThrows(NullPointerException.class,
+                () -> Lazy.ofArray(SIZE, i -> null).apply(INDEX));
+    }
+
+    @Test
+    void toListSize() {
+        assertEquals(SIZE, halfComputedList().size());
+        assertEquals(SIZE - 2, halfComputedList().subList(1, SIZE - 1).size());
+    }
+
+    @Test
+    void toListUnmodifiable() {
+        toListUnmodifiable(halfComputedList());
+        toListUnmodifiable(halfComputedList().subList(1, SIZE - 1));
+    }
+
+    void toListUnmodifiable(List<Integer> list) {
+        List<Integer> otherList = List.of(1);
+        List<Named<Consumer<List<Integer>>>> operations = List.of(
+                Named.of("add(1)", l -> l.add(1)),
+                Named.of("add(1,1)", l -> l.add(1, 1)),
+                Named.of("addAll(L)", l -> l.addAll(otherList)),
+                Named.of("addAll(2,L)", l -> l.addAll(2, otherList)),
+                Named.of("clear()", l -> l.clear()),
+                Named.of("remove(int)", l -> l.remove(1)),
+                Named.of("remove(Object)", l -> l.remove((Integer) 1)),
+                Named.of("removeAll(L)", l -> l.removeAll(otherList)),
+                Named.of("retainAll(L)", l -> l.retainAll(otherList)),
+                Named.of("set(1,1)", l -> l.set(1, 1)),
+                Named.of("sort(C)", l -> l.sort(Comparator.naturalOrder())),
+                Named.of("removeIf(i -> i ==2)", l -> l.removeIf(i -> i == 2))
+        );
+        for (var operation : operations) {
+            assertThrows(UnsupportedOperationException.class, () ->
+                            operation.getPayload().accept(list)
+                    , operation.getName());
+        }
+    }
+
+    @Test
+    void testToString() throws InterruptedException {
+        var timeout = System.nanoTime()+ TimeUnit.SECONDS.toNanos(2);
+        AtomicBoolean lambdaInvoked = new AtomicBoolean();
+        lazy = Lazy.ofEmptyArray(3);
+
+        lazy.computeIfEmpty(1, i -> 1);
+        try {
+            System.out.println(2);
+            lazy.computeIfEmpty(2, i -> {
+                throw new UnsupportedOperationException("Test");
+            });
+        } catch (UnsupportedOperationException ignored) {
+            // Happy path
+        }
+
+        var toString = lazy.toString();
+
+        assertEquals("LazyReferenceArray[-, 1, !]", toString);
+    }
+
+    // Todo:repeate the test 1000 times
+    @Test
+    void threadTest() throws InterruptedException {
+        var gate = new AtomicBoolean();
+        var threads = IntStream.range(0, Runtime.getRuntime().availableProcessors() * 2)
+                .mapToObj(i -> new Thread(() -> {
+                    while (!gate.get()) {
+                        Thread.onSpinWait();
+                    }
+                    // Try to access the instance "simultaneously"
+                    lazy.computeIfEmpty(INDEX, mapper);
+                }))
+                .toList();
+        threads.forEach(Thread::start);
+        Thread.sleep(10);
+        gate.set(true);
+        join(threads);
+        assertEquals(INDEX, lazy.apply(INDEX));
+        assertEquals(1, mapper.invocations(INDEX));
+    }
+
+    private List<Integer> halfComputedList() {
+        for (int i = 0; i < SIZE / 2; i++) {
+            lazy.computeIfEmpty(i, mapper);
+        }
+        return lazy.asList();
+    }
+
+    private static void join(Collection<Thread> threads) {
+        for (var t : threads) {
+            try {
+                t.join();
+            } catch (InterruptedException e) {
+                throw new AssertionError(e);
+            }
+        }
+    }
+
+    static private final class CountingIntegerMapper implements IntFunction<Integer> {
+        private final AtomicInteger[] invocations;
+
+        public CountingIntegerMapper(int size) {
+            this.invocations = IntStream.range(0, size)
+                    .mapToObj(i -> new AtomicInteger())
+                    .toArray(AtomicInteger[]::new);
+        }
+
+        @Override
+        public Integer apply(int i) {
+            invocations[i].incrementAndGet();
+            return i;
+        }
+
+        int invocations(int i) {
+            return invocations[i].get();
+        }
+    }
+
+}
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
new file mode 100644
index 00000000000..6fa16cacf47
--- /dev/null
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Verify basic LazyReference operations
+ * @run junit BasicLazyReferenceTest
+ */
+
+import org.junit.jupiter.api.*;
+
+import java.util.Collection;
+import java.util.NoSuchElementException;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+import java.util.stream.IntStream;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+final class BasicLazyReferenceTest {
+
+    LazyReference<Integer> lazy;
+    CountingIntegerSupplier supplier;
+
+    @BeforeEach
+    void setup() {
+        lazy = Lazy.ofEmpty();
+        supplier = new CountingIntegerSupplier();
+    }
+
+    @Test
+    void supply() {
+        Integer val = lazy.supplyIfEmpty(supplier);
+        assertEquals(CountingIntegerSupplier.MAGIC_VALUE, val);
+        assertEquals(1, supplier.invocations());
+        Integer val2 = lazy.supplyIfEmpty(supplier);
+        assertEquals(CountingIntegerSupplier.MAGIC_VALUE, val);
+        assertEquals(1, supplier.invocations());
+    }
+
+    @Test
+    void nulls() {
+        // Mapper is null
+        assertThrows(NullPointerException.class,
+                () -> lazy.supplyIfEmpty(null));
+        // Mapper returns null
+        assertThrows(NullPointerException.class,
+                () -> lazy.supplyIfEmpty(() -> null));
+    }
+
+    @Test
+    void noPresetGet() {
+        assertThrows(IllegalStateException.class,
+                () -> lazy.get());
+    }
+
+    @Test
+    void state() {
+        assertEquals(Lazy.State.EMPTY, lazy.state());
+        Integer val = lazy.supplyIfEmpty(supplier);
+        assertEquals(Lazy.State.PRESENT, lazy.state());
+    }
+
+    @Test
+    void presetSupplierBasic() {
+        LazyReference<Integer> presetLazy = Lazy.of(supplier);
+        for (int i = 0; i < 2; i++) {
+            assertEquals(CountingIntegerSupplier.MAGIC_VALUE, presetLazy.get());
+            assertEquals(1, supplier.invocations());
+        }
+    }
+
+    @Test
+    void presetSupplierNullSuppying() {
+        // Mapper is null
+        assertThrows(NullPointerException.class,
+                () -> Lazy.of(null));
+        // Mapper returns null
+        assertThrows(NullPointerException.class,
+                () -> Lazy.of(() -> null).get());
+    }
+
+    @Test
+    void optionalModelling() {
+        Supplier<Optional<String>> empty = Lazy.of(() -> Optional.empty());
+        assertTrue(empty.get().isEmpty());
+        Supplier<Optional<String>> present = Lazy.of(() -> Optional.of("A"));
+        assertEquals("A", present.get().orElseThrow());
+    }
+
+    @Test
+    void error() {
+        Supplier<Integer> throwSupplier = () -> {
+            throw new UnsupportedOperationException();
+        };
+        assertThrows(UnsupportedOperationException.class,
+                () -> lazy.supplyIfEmpty(throwSupplier));
+
+        assertEquals(Lazy.State.ERROR, lazy.state());
+        assertTrue(lazy.exception().isPresent());
+
+        // Should not invoke the supplier as we are already in ERROR state
+        assertThrows(NoSuchElementException.class, () -> lazy.supplyIfEmpty(throwSupplier));
+    }
+
+    // Todo:repeate the test 1000 times
+    @Test
+    void threadTest() throws InterruptedException {
+        var gate = new AtomicBoolean();
+        var threads = IntStream.range(0, Runtime.getRuntime().availableProcessors() * 2)
+                .mapToObj(i -> new Thread(()->{
+                    while (!gate.get()) {
+                        Thread.onSpinWait();
+                    }
+                    // Try to access the instance "simultaneously"
+                    lazy.supplyIfEmpty(supplier);
+                }))
+                .toList();
+        threads.forEach(Thread::start);
+        Thread.sleep(10);
+        gate.set(true);
+        join(threads);
+        assertEquals(CountingIntegerSupplier.MAGIC_VALUE, lazy.get());
+        assertEquals(1, supplier.invocations());
+    }
+
+    @Test
+    void testToString() throws InterruptedException {
+        var lazy0 = Lazy.of(() -> 0);
+        var lazy1 = Lazy.of(() -> 1);
+        lazy1.get();
+        var lazy2 = Lazy.of(() -> {
+            throw new UnsupportedOperationException();
+        });
+        // Do not touch lazy0
+        lazy1.get();
+        try {
+            lazy2.get();
+        } catch (UnsupportedOperationException ignored) {
+            // Happy path
+        }
+
+        assertEquals("LazyReference[EMPTY]", lazy0.toString());
+        assertEquals("LazyReference[1]", lazy1.toString());
+
+        // Todo: Figure out why this fails
+        // assertEquals("LazyReference[ERROR]", lazy2.toString());
+    }
+
+    private static void join(Collection<Thread> threads) {
+        for (var t : threads) {
+            try {
+                t.join();
+            } catch (InterruptedException e) {
+                throw new AssertionError(e);
+            }
+        }
+    }
+
+    static private final class CountingIntegerSupplier implements Supplier<Integer> {
+        static final int MAGIC_VALUE = 42;
+        private final AtomicInteger invocations = new AtomicInteger();
+
+        @Override
+        public Integer get() {
+            invocations.incrementAndGet();
+            return MAGIC_VALUE;
+        }
+
+        int invocations() {
+            return invocations.get();
+        }
+    }
+
+}
diff --git a/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
new file mode 100644
index 00000000000..4a2d53bd596
--- /dev/null
+++ b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Verify basic BasicLazyReferenceArray operations
+ * @run junit LazyReferenceArrayMappingTest
+ */
+
+import org.junit.jupiter.api.*;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.stream.IntStream;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+final class LazyReferenceArrayMappingTest {
+
+    private static final int SIZE = 63;
+    private static final int INDEX = 13;
+
+    LazyReferenceArray<Integer> lazy;
+    CountingIntegerMapper mapper;
+
+    LazyReferenceArray.IntKeyMapper intKeyMapper;
+    LazyReferenceArray.KeyMapper<String> keyMapper;
+
+    @BeforeEach
+    void setup() {
+        lazy = Lazy.ofEmptyArray(SIZE);
+        mapper = new CountingIntegerMapper(SIZE);
+        intKeyMapper = LazyReferenceArray.IntKeyMapper.ofConstant(2);
+        // keyMapper = LazyReferenceArray.KeyMapper.ofHashing("A", "B", "C");
+    }
+
+/*    @Test
+    void mapInt() {
+        int two = lazy.mapIntAndApply(intKeyMapper, 2, i -> 2, i -> 0);
+        assertEquals(2, two);
+        int three = lazy.mapIntAndApply(intKeyMapper, 3, i -> 2, i -> 0);
+        assertEquals(0, three);
+    }*/
+
+    @Test
+    void a() {
+        var pm = LazyReferenceArray.KeyMapper.polynomialMapper("A", "B", "C");
+        System.out.println(pm);
+    }
+
+    @Test
+    void mapString() {
+        LazyReferenceArray<String> lazyStrings = Lazy.ofEmptyArray(keyMapper.requiredLength().getAsInt());
+        Function<String, String> mapper = s -> s.repeat(10);
+        String as = lazyStrings.mapAndApply(keyMapper, "A", mapper, Function.identity());
+        assertEquals(mapper.apply("A"), as);
+        String x = lazyStrings.mapAndApply(keyMapper, "X", mapper, Function.identity());
+        assertEquals("X", x);
+    }
+
+    static private final class CountingIntegerMapper implements IntFunction<Integer> {
+        private final AtomicInteger[] invocations;
+
+        public CountingIntegerMapper(int size) {
+            this.invocations = IntStream.range(0, size)
+                    .mapToObj(i -> new AtomicInteger())
+                    .toArray(AtomicInteger[]::new);
+        }
+
+        @Override
+        public Integer apply(int i) {
+            invocations[i].incrementAndGet();
+            return i;
+        }
+
+        int invocations(int i) {
+            return invocations[i].get();
+        }
+    }
+
+}

From 9f57884b0efc1ed3da5d30ce9893ceb3fcbe0755 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 11 Apr 2023 13:49:25 +0200
Subject: [PATCH 02/16] Add internal classes

---
 .../util/concurrent/lazy/AbstractMapper.java  | 25 ++++++++++++++
 .../util/concurrent/lazy/LazyMapper.java      | 34 +++++++++++++++++++
 .../concurrent/lazy/LazySingleMapper.java     | 33 ++++++++++++++++++
 3 files changed, 92 insertions(+)
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java

diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
new file mode 100644
index 00000000000..7a49c1631ea
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
@@ -0,0 +1,25 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.concurrent.lazy.playground.DemoMapObject;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import static java.util.stream.Collectors.toMap;
+
+class AbstractMapper<K, V> {
+
+    protected final Map<K, Integer> keyToInt;
+    protected final LazyReferenceArray<V> lazyArray;
+
+    protected <T> AbstractMapper(Stream<T> keyHolders,
+                                 Function<T, K> keyExtractor) {
+        AtomicInteger cnt = new AtomicInteger();
+        this.keyToInt = keyHolders
+                .collect(toMap(keyExtractor, k -> cnt.getAndIncrement()));
+        this.lazyArray = Lazy.ofEmptyArray(keyToInt.size());
+    }
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
new file mode 100644
index 00000000000..e450b28ac22
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
@@ -0,0 +1,34 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.KeyMapper;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.concurrent.lazy.playground.DemoMapObject;
+import java.util.function.Function;
+
+import static java.util.stream.Collectors.toMap;
+
+public final class LazyMapper<K, V>
+        extends AbstractMapper<K, V>
+        implements Function<K, Optional<V>> {
+
+    private final Map<K, Function<? super K, ? extends V>> mappers;
+
+    public LazyMapper(Collection<KeyMapper<K, V>> keyMappers) {
+        super(keyMappers.stream(), KeyMapper::key);
+        this.mappers = keyMappers.stream()
+                .collect(toMap(KeyMapper::key, lms -> lms.mapper()));
+    }
+
+    @Override
+    public Optional<V> apply(K key) {
+        return Optional.ofNullable(keyToInt.get(key))
+                .map(i -> lazyArray.computeIfEmpty(i, k2 -> mappers.get(key).apply(key)));
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
new file mode 100644
index 00000000000..0dfc63f604e
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
@@ -0,0 +1,33 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.function.Function;
+
+import static java.util.stream.Collectors.toMap;
+
+public final class LazySingleMapper<K, V>
+        extends AbstractMapper<K, V>
+        implements Function<K, Optional<V>> {
+
+    private final Function<? super K, ? extends V> mapper;
+
+    public LazySingleMapper(Collection<K> keys,
+                            Function<? super K, ? extends V> mapper) {
+        super(keys.stream(), Function.identity());
+        Objects.requireNonNull(mapper);
+        this.mapper = mapper;
+    }
+
+    @Override
+    public Optional<V> apply(K key) {
+        return Optional.ofNullable(keyToInt.get(key))
+                .map(i -> lazyArray.computeIfEmpty(i, k2 -> mapper.apply(key)));
+    }
+
+}
\ No newline at end of file

From de1a8e19cd78f3f02d70902a6d8ce28bc93e4c6b Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 11 Apr 2023 16:02:14 +0200
Subject: [PATCH 03/16] Cleanup docs and tests

---
 .../java/util/concurrent/lazy/KeyMapper.java  |   4 +-
 .../java/util/concurrent/lazy/Lazy.java       |   2 +-
 .../util/concurrent/lazy/LazyReference.java   |  11 +-
 .../concurrent/lazy/LazyReferenceArray.java   | 334 ------------------
 .../util/concurrent/lazy/package-info.java    | 245 ++++++++-----
 .../jdk/internal/javac/PreviewFeature.java    |   3 +
 .../util/concurrent/lazy/AbstractMapper.java  |   1 -
 .../util/concurrent/lazy/LazyMapper.java      |   1 -
 src/java.base/share/classes/module-info.java  |   1 +
 .../lazy/BasicLazyReferenceArrayTest.java     |   1 +
 .../lazy/BasicLazyReferenceTest.java          |   1 +
 .../lazy/LazyReferenceArrayMappingTest.java   |  21 +-
 12 files changed, 179 insertions(+), 446 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
index 21c58c36f75..c4ff32bcaac 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
@@ -7,10 +7,10 @@
  * of type K and a mapper that can compute an associated
  * value of type V at a later time.
  *
- * @param key    to bind to a mapper
- * @param mapper to be applied for the key at a later time
  * @param <K>    the type of the key maintained by this association
  * @param <V>    the type of mapped values
+ * @param key    to bind to a mapper
+ * @param mapper to be applied for the key at a later time
  */
 public record KeyMapper<K, V>(
         K key,
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index df2c0a3da03..726e6ac6de6 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -12,7 +12,7 @@
 import java.util.function.Supplier;
 
 /**
- * This class provides common factories and configuration classes for all
+ * This class provides common factories and builders classes for all
  * Lazy class variants.
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index 85193b46efa..2418383f6c1 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -36,8 +36,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
-// Build time, background, etc. computation (time shifting) (referentially transparent)
-
 /**
  * An object reference in which the value can be lazily and atomically computed.
  * <p>
@@ -319,8 +317,15 @@ public final String toString() {
         /**
          * {@return a builder that will use the provided {@code earliestEvaluation} when
          * eventially {@linkplain #build() building} a LazyReference}.
+         * <p>
+         * Any supplier configured with this builder must be referentially transparent
+         * and thus must have no side-effect in order to allow transparent time-shifting of
+         * evaluation.
+         * <p>
+         * No guarantees are made with respect to the latest time of evaluation and
+         * consequently, the value might always be evaliate {@linkplain Lazy.Evaluation#AT_USE at use}.
          *
-         * @param earliestEvaluation to use
+         * @param earliestEvaluation to use.
          */
         Builder<T> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
 
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
index c5e4b736879..9d642bbf6ab 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
@@ -365,53 +365,6 @@ public V mapIntAndApply(IntKeyMapper intKeyMapper,
                 : unmappableHandler.apply(key);
     }
 
-    /**
-     * Returns the lazy value associated with the provided {@code key} via the provided
-     * {@code keyMapper}, or, if the key is not {@linkplain IntKeyMapper#isMappable(int) mappable}, applies
-     * the provided {@code unmappableHandler} using the provided {@code key}.
-     * <p>
-     * If the underlying lazy pre-set mapper throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded. If the provided {@code unmappableHandler}
-     * throws an (unchecked) exception, the exeption is rethrown.
-     * The most common usage is to construct a new object serving as a cached result, as in:
-     * <p>
-     * {@snippet lang = java:
-     *    private static KeyMapper<String> KEY_MAPPER = KeyMapper.ofHashing("A", "B", "C");
-     *    LazyReferenceArray<Long> cache = LazyReferenceArray.of(KEY_MAPPER.requiredLength());
-     *    // ...
-     *
-     *    String value = cache.mapAndApply(KEY_MAPPER, "B", (String s) -> s.repeat(10), (String s) -> s.repeat(10));
-     *    assertEquals("BBBBBBBBBB", value); // Value is mappable and entered into and taken from the cache
-     *
-     *    Long value2 = cache.mapAndApply(KEY_MAPPER, "Z", (String s) -> s.repeat(10), (String s) -> "");
-     *    assertEquals("", value2); // Value is not mappable and will be obtained from the provided lambda
-     *}
-     * <p>
-     * If another thread attempts to compute a lazy value, the current thread will be suspended until
-     * the atempt completes (successfully or not).
-     *
-     * @param <K>               key type
-     * @param keyMapper         to use when mapping a key
-     * @param key               to map to an index
-     * @param mappableHandler   to apply if the key {@linkplain IntKeyMapper#isMappable(int) is mappable}
-     * @param unmappableHandler to apply if the key {@linkplain IntKeyMapper#isMappable(int) is NOT mappable}
-     * @return a lazy value (pre-existing or newly computed) or another value from the provided {@code unmappableHandler}.
-     * @throws IllegalStateException  if a value was not already present and no
-     *                                pre-set mapper was specified.
-     * @throws NoSuchElementException if a lazy maper has previously thrown an exception for the
-     *                                provided key mapping to an associated {@code index}.
-     */
-    public <K> V mapAndApply(KeyMapper<? super K> keyMapper,
-                             K key,
-                             Function<? super K, ? extends V> mappableHandler,
-                             Function<? super K, ? extends V> unmappableHandler) {
-        int index = keyMapper.keyToIndex(key);
-        return (index >= 0 && index < lazyReferences.length)
-                ? lazyReferences[index]
-                .supplyIfEmpty(() -> mappableHandler.apply(key))
-                : unmappableHandler.apply(key);
-    }
-
     @Override
     public String toString() {
         return IntStream.range(0, length())
@@ -580,293 +533,6 @@ public OptionalInt requiredLength() {
         }
     }
 
-    /**
-     * A key mapper than can convert between external "keys" and internal indices. The mapper
-     * is said to perform <em>inversly replicable conversions</em> meaning for a KeyMapper
-     * {@code km} used by a LazyReferenceArray {@code lra}:
-     * <ul>
-     *     <li>
-     *     The following holds: {@code km.isApplicable(lra.length))}.
-     *     </li>
-     *     <li>
-     *      For any external value {@code key} for which the mapper {@linkplain KeyMapper#isMappable(Object)} is convertible},
-     *       the following holds: {@code
-     *           fromIndex(toIndex(key)) = key
-     *       }
-     *     </li>
-     *     <li>
-     *      For any external value {@code key} for which the mapper {@linkplain KeyMapper#isMappable(Object) is NOT convertibla},
-     *      the following will throw an ArrayOutOfBounds: {@code
-     *           lra.get(toindex(e));
-     *       }
-     *     </li>
-     * </ul>
-     * <p>
-     * Hence, the mapper is not guaranteed to always produce valid mappings but is guaranteed to provide
-     * consistent results when applied to a LazyReferenceArray.
-     * <p>
-     * The mapper is useful when using a LazyReferenceArray as a cache in cases there is not
-     * a one-to-one mapping between the keys used for caching and the actual indices in the
-     * arrary.
-     *
-     * @param <K> key type
-     * @see LazyReferenceArray#mapIntAndApply(IntKeyMapper, int, IntFunction, IntFunction)
-     */
-    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-    public interface KeyMapper<K> {
-
-        /**
-         * {@return an index of the LazyReferenceArray by converting the
-         * provided {@code key} or, an invalid index
-         * if no such conversion can be made}.
-         *
-         * @param key to convert to an index
-         */
-        int keyToIndex(K key);
-
-        /**
-         * {@return if the provided {@code key} can be
-         * mapped to an index}.
-         *
-         * @param key to test
-         */
-        boolean isMappable(K key);
-
-        /**
-         * {@return the required array length, or if no such array length exists,
-         * {@link OptionalInt#empty()}}.
-         */
-        OptionalInt requiredLength();
-
-        /**
-         * {@return if this KeyMapper can be used on an array with the
-         * provided {@code arrayLength}}.
-         *
-         * @param arrayLength to test
-         */
-        boolean checkArrayLength(int arrayLength);
-
-        // Redundant but convenient...
-
-        /**
-         * {@return a KeyMapper using a non-colliding hash algoritm}.
-         *
-         * @param objects to use as keys
-         * @param <T>     key types
-         */
-        @SafeVarargs
-        @SuppressWarnings("varargs")
-        public static <T> KeyMapper<T> ofHashing(T... objects) {
-            Objects.requireNonNull(objects);
-            return of(polynomialMapper(objects));
-        }
-
-        /**
-         * {@return a KeyMapper that uses the provided {@code mapper}}.
-         *
-         * @param mapper to use
-         * @param <T>    type of key elements.
-         */
-        public static <T> KeyMapper<T> of(PolynomialMapperConfig<T> mapper) {
-            return new KeyMapper<T>() {
-                @Override
-                public int keyToIndex(T key) {
-                    T[] keys = mapper.keys();
-                    int index = bucket(polynomialHash(mapper.polynom(), key.hashCode()), keys.length);
-                    if (Objects.equals(key, keys[index])) {
-                        return index;
-                    }
-                    int nextIndex = KeyMapper.bucket(index, keys.length);
-                    if (Objects.equals(keys, keys[nextIndex])) {
-                        return nextIndex;
-                    }
-                    return -1;
-                }
-
-                // Todo: Fix this. We do not want to comput the hash two times
-                @Override
-                public boolean isMappable(T key) {
-                    int index = keyToIndex(key);
-                    return (index >= 0 && index < mapper.keys().length);
-                }
-
-                @Override
-                public OptionalInt requiredLength() {
-                    return OptionalInt.of(mapper.keys().length);
-                }
-
-                @Override
-                public boolean checkArrayLength(int arrayLength) {
-                    return arrayLength >= requiredLength().getAsInt();
-                }
-            };
-        }
-
-        /**
-         * {@return a PolynomialMapper for the provided {@code keys}}.
-         *
-         * @param keys to use later on
-         * @param <T>  type of the keys
-         */
-        @SafeVarargs
-        @SuppressWarnings("varargs")
-        public static <T> PolynomialMapperConfig<T> polynomialMapper(T... keys) {
-            @SuppressWarnings("unchecked")
-            T[] sortedKeys = (T[]) new Object[keys.length];
-            BitSet bitSet = new BitSet(keys.length);
-            int[] primes = IntStream.of(
-                            2, 3, 5, 7, 13, 17, 21, 23, 31,
-                            127, 257, 509, 1021, 2053, 4099)
-                    // No use of primes that are an even multiple of keys.length
-                    .filter(i -> i % keys.length != 0)
-                    .toArray();
-
-            for (int l = 2; l < 5; l++) {
-                int[] polynom = new int[l];
-
-                // Todo: Replace this with a stack or an array of iterators
-                switch (l) {
-                    // Case 1 does not provide any spreading
-                    case 1: {
-                        for (int i0 = 0; i0 < primes.length; i0++) {
-                            polynom[0] = primes[i0];
-                            PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
-                            if (m != null) {
-                                return m;
-                            }
-                        }
-                    }
-                    break;
-                    case 2: {
-                        for (int i0 = 0; i0 < primes.length; i0++) {
-                            for (int i1 = 0; i1 < primes.length; i1++) {
-                                polynom[0] = primes[i0];
-                                polynom[1] = primes[i1];
-                                PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
-                                if (m != null) {
-                                    return m;
-                                }
-                            }
-                        }
-                    }
-                    break;
-                    case 3: {
-                        for (int i0 = 0; i0 < primes.length; i0++) {
-                            for (int i1 = 0; i1 < primes.length; i1++) {
-                                for (int i2 = 0; i2 < primes.length; i2++) {
-                                    polynom[0] = primes[i0];
-                                    polynom[1] = primes[i1];
-                                    polynom[2] = primes[i2];
-                                    PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
-                                    if (m != null) {
-                                        return m;
-                                    }
-                                }
-                            }
-                        }
-                        break;
-                    }
-                    case 4: {
-                        for (int i0 = 0; i0 < primes.length; i0++) {
-                            for (int i1 = 0; i1 < primes.length; i1++) {
-                                for (int i2 = 0; i2 < primes.length; i2++) {
-                                    for (int i3 = 0; i3 < primes.length; i3++) {
-                                        polynom[0] = primes[i0];
-                                        polynom[1] = primes[i1];
-                                        polynom[2] = primes[i2];
-                                        polynom[3] = primes[i3];
-                                        PolynomialMapperConfig<T> m = tryPolynom(polynom, keys);
-                                        if (m != null) {
-                                            return m;
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            throw new NoSuchElementException("Unable: " + Arrays.toString(keys));
-        }
-
-        private static <T> PolynomialMapperConfig<T> tryPolynom(int[] polynom, T[] keys) {
-            BitSet bitSet = new BitSet(keys.length);
-            @SuppressWarnings("unchecked")
-            T[] sortedKeys = (T[]) new Object[keys.length];
-            for (int i = 0; i < keys.length; i++) {
-                T key = keys[i];
-                int index = bucket(polynomialHash(polynom, Objects.hash(key)), keys.length);
-                if (bitSet.get(index)) {
-                    // Try one position ahead
-                    int nextIndex = bucket(index, keys.length);
-                    bitSet.set(nextIndex);
-                    sortedKeys[nextIndex] = key;
-                } else {
-                    bitSet.set(index);
-                    sortedKeys[index] = key;
-                }
-            }
-            System.out.println("Tried (" + bitSet.cardinality() + ") " + Arrays.toString(polynom) + " -> " + Arrays.toString(sortedKeys));
-            if (bitSet.cardinality() > hi) {
-                hi = bitSet.cardinality();
-                System.out.println("hi=" + hi);
-            }
-            if (bitSet.cardinality() == keys.length) {
-                System.out.println("Yehaa!");
-                return new PolynomialMapperConfig<>(polynom, keys);
-            }
-            return null;
-        }
-
-        /**
-         * A polynomial mapper with the provided {@code polynom} and {@code keys}}.
-         *
-         * @param polynom to apply for keys
-         * @param keys    that are a member of the mapping
-         * @param <T>     type of the keys
-         */
-        @SuppressWarnings("unchecked")
-        @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-        public record PolynomialMapperConfig<T>(int[] polynom, T... keys) {
-            /**
-             * Constructor
-             *
-             * @param polynom to apply for keys
-             * @param keys    that are a member of the mapping
-             */
-            public PolynomialMapperConfig {
-                if (polynom.length <= 0) {
-                    throw new IllegalArgumentException("polynom lenght must be positive: " + polynom.length);
-                }
-            }
-
-            @Override
-            public String toString() {
-                return PolynomialMapperConfig.class.getSimpleName() + "={" +
-                        "polynom=" + Arrays.toString(polynom) + ", " +
-                        "keys=" + Arrays.toString(keys) + "}";
-            }
-        }
-
-        private static int bucket(int hash, int length) {
-            return (hash % length) & Integer.MAX_VALUE;
-        }
-
-        private static int polynomialHash(int[] polynom, int initialHash) {
-            int x = Objects.hashCode(initialHash);
-            int h = 0;
-
-            // Todo: use the Vector API
-            // 3X^2+X+3
-            for (int i = 1; i < polynom.length; i++) {
-                h += x * polynom[i];
-                x *= x;
-            }
-            h += polynom[0];
-            return h;
-        }
-    }
-
     private final class ListView implements List<V> {
 
         private final V defaultValue;
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index 2ddcb9353fc..c21a8f1ab3a 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -24,133 +24,203 @@
  */
 
 /**
- * A small toolkit of classes that support lock-free, thread-safe
- * use of lazy initialized values with superior performance.
+ * A small toolkit of classes supporting lock-free, thread-safe
+ * use of lazily initialized values with superior performance.  Providers of
+ * lazy values are guaranteed to be invoked at most one time.  This contrasts
+ * to {@link java.util.concurrent.atomic.AtomicReferenceArray } where any number
+ * of updates can be done and where there is no simple way to atomically compute
+ * a value (guaranteed to only be computed once) if missing.
+ *  <p>
+ * The lazy implementations are optimized for the case where there are N invocations
+ * trying to obtain a value and where N >> 1, for example where N is > 2<sup>20</sup>.
  *
  * <h2 id="lazy">Lazy</h2>
  *
- * Instances of the many lazy types are obtained form the {@link java.util.concurrent.lazy.Lazy} class
- * using several factories and builders.
+ * Instances of the many lazy types are obtained via the {@link java.util.concurrent.lazy.Lazy} class
+ * using factory methods and builders.
  *
  * <h3 id="lazyreference">LazyReference</h3>
  *
- * For example, Lazy can provide atomic
- * lazy evaluation using a <em>preset-supplier</em>:
+ * In its simplest form, Lazy can provide atomic lazy evaluation using a <em>preset-supplier</em>:
  *
  * {@snippet lang = java :
  * class Foo {
  *   private static final LazyReference<Bar> BAR = Lazy.of(Bar::new);
- *   public Bar bar() {
- *     return BAR.get(); // Bar is computed here on first invocation
+ *
+ *   public Bar theBar() {
+ *     return BAR.get(); // Bar is lazily computed here on first invocation
+ *   }
+ * }
+ *}
+ * The performance of the example above is on pair with using an inner/private class
+ * holding a lazily initialized variable but with no overhead imposed by the extra
+ * class as illustraded hereunder:
+ *
+ {@snippet lang = java :
+ * class Foo {
+ *
+ *   public Bar theBar() {
+ *      class Holder {
+ *          Bar bar = new Bar();
+ *      }
+ *     return Holder.bar; // Bar is lazily computed here on first invocation
  *   }
  * }
  *}
  *
- * On some occations, a preset-suppler might not be known a priori or the
- * lazy value to compute might depend on values not know at declaration time. In
+ * On some occasions, a preset-supplier might not be known a priori or the
+ * lazy value to compute might depend on values not known at declaration time.  In
  * such cases, an empty LazyReference can be obtained and used as exemplified below:
  * {@snippet lang = java:
- *     LazyReference<String> lazy = Lazy.ofEmpty();
- *     ...
- *     String color = "brown";
- *     ...
- *     String fox = lazy.supplyIfEmpty(() -> "The quck " + color + " fox");
+ * class Fox {
+ *     private final LazyReference<String> lazy = Lazy.ofEmpty();
+ *
+ *     String init(String color) {
+ *         return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+ *     }
+ * }
  *}
  *
  * A custom configurable LazyReference can be obtained via the
  * {@linkplain java.util.concurrent.lazy.Lazy#builder() builder} method.
- * Here is how a lazy value can be computed in the background and may already be computed
- * when first referenced from user code:
+ * Here is how a lazy value can be computed in the background and that may already be computed
+ * when first requested from user code:
  * {@snippet lang = java:
- *        LazyReference<Foo> lazy = Lazy.<Foo>builder()
- *                 .withSupplier(Foo::new)
- *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
- *                 .build();
+ * class BackgroundDemo {
+ *    private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
+ *             .withSupplier(Foo::new)
+ *             .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+ *             .build();
  *
+ *     public static void main(String[] args) throws InterruptedException {
  *         Thread.sleep(1000);
- *
- *         // lazy is likely already pre-computed here
+ *         // lazy is likely already pre-computed here by a background thread
  *         System.out.println("lazy.get() = " + lazy.get());
+ *     }
+ * }
  * }
  *
- * {@code LazyReference<T>} implements {@code Supplier<T>} allowing simple interoperability with legacy code
- * and less specific type declaration as shown hereunder:
+ * {@code LazyReference<T>} implements {@code Supplier<T>} allowing simple
+ * interoperability with legacy code and less specific type declaration
+ * as shown in the example hereunder:
  * {@snippet lang = java:
- *    Suppler<Foo> eagerFoo = new Foo();
- *    ...
- *    Supplier<Foo> fooLazyCache = Lazy.of(eagerFoo);
- *    ...
- *    Foo theFoo = fooLazyCache.get();
- * }
+ *    class SupplierDemo {
+ *
+ *         // Eager Supplier of Foo
+ *         private static final Supplier<Foo> EAGER_FOO = Foo::new;
+ *
+ *         // Turns an eager Supplier into a caching lazy Supplier
+ *         private static final Supplier<Foo> LAZY_CACHE_FOO = Lazy.of(EAGER_FOO);
+ *
+ *         public static void main(String[] args) {
+ *            // Lazily compute the one and only Foo
+ *            Foo theFoo = LAZY_CACHE_FOO.get();
+ *         }
+ *    }
+ *}
+ *
+ * LazyReference contains additional methods for checking its
+ * {@linkplain java.util.concurrent.lazy.LazyReference#state() state} and getting
+ * any {@linkplain java.util.concurrent.lazy.LazyReference#exception()} that might be thrown
+ * by the provider.
  *
  * <h3 id="lazyarray">LazyArray</h3>
  *
  * Arrays of lazy values (i.e. {@link java.util.concurrent.lazy.LazyReferenceArray}) can also be
- * obtained via {@link java.util.concurrent.lazy.Lazy} factory methods in the same way as for LazyReference instance but with
- * an extra initial arity, indicating the desired length of the array:
+ * obtained via {@link java.util.concurrent.lazy.Lazy} factory methods in the same way as
+ * for LazyReference instance but with an extra initial arity, indicating the desired length/index
+ * of the array:
  * {@snippet lang = java:
- *    LazyReferenceArray<Value> lazy = Lazy.ofArray(32, index -> new Value(1L << index));
- *    // ...
- *    Value value = lazy.get(16);
+ * class ArrayDemo {
+ *    private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+ *            Lazy.ofArray(32, index -> new Value(1L << index));
+ *
+ *    Value powerOfTwoValue(int n) {
+ *        return VALUE_PO2_CACHE.get(n);
+ *    }
  * }
- * As can be seen above, an array takes an IntFunction rather than a Supplier, allowing custom values to be
+ * }
+ * As can be seen above, an array takes an {@link java.util.function.IntFunction} rather
+ * than a {@link java.util.function.Supplier }, allowing custom values to be
  * computed and entered into the array depending on the current index being used.
  *
- * As was the case for LazyReference, empty LazyReference arrays can also be constructed, allowing
- * lazy mappers known at a later stage to be used:
+ * As was the case for LazyReference, empty LazyReferenceArray instances can also be
+ * constructed, allowing lazy mappers known at a later stage to be used:
  * {@snippet lang = java:
- *    // Cache the first 64 users
- *    private static final LazyReferenceArray<User> lazy = Lazy.ofEmptyArray(64);
- *    ...
- *    Connection c = ...
- *    User value = lazy.computeIfEmpty(42, i -> findUserById(c, i));
- *    assertNotNull(value); // Value is non-null
+ * class UserCache {
+ *     // Cache the first 64 users
+ *     private static final LazyReferenceArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
+ *
+ *     User user(int id) {
+ *         Connection c = getDatabaseConnection();
+ *         User value = lazy.computeIfEmpty(id, i -> findUserById(c, i));
+ *         assertNotNull(value); // Value is non-null
+ *     }
+ * }
  * }
  *
- * {@code LazyReferenceArray<T>} implements {@code IntFunction<T>} allowing simple interoperability with legacy code
- * and less specific type declaration as shown hereunder:
+ * {@code LazyReferenceArray<T>} implements {@code IntFunction<T>} allowing simple interoperability
+ * with existing code and with less specific type declarations as shown hereunder:
  * {@snippet lang = java:
- *    IntFunction<Foo> eagerFoo = index -> new Foo(index);
- *    ...
- *    IntSupplier<Foo> fooLazyCache = Lazy.ofArray(64, eagerFoo);
- *    ...
- *    Foo foo42 = fooLazyCache.apply(42);
+ * class IntFunctionDemo {
+ *     // Eager Supplier of Foo
+ *     private static final IntFunction<Foo> EAGER_FOO =
+ *             index -> new Foo(index);
+ *
+ *     // Turns an eager Supplier into a caching lazy Supplier
+ *     private static final IntSupplier<Foo> LAZY_CACHE_FOO =
+ *             Lazy.ofArray(64, eagerFoo);
+ *
+ *     public static void main(String[] args) {
+ *        Foo foo42 = LAZY_CACHE_FOO.apply(42);
+ *     }
+ * }
  * }
  *
- * Todo: Describe IntKeyMapper and
+ * Todo: Describe IntKeyMapper
  *
  * <h3 id="lazymapper">LazyMapper</h3>
- * When several lazy values are to be held and accessible via arbitary keys of type K, general mappers can be
- * obtained for any pre-given collection of keys. Even though this could be modelled
- * directly by users via a second level of regular Java Maps, there are special constructs available that
- * provide equivialent functionality but with potentially better performance and lower memory usage.
+ * When several lazy values are to be held and accessible via arbitrary keys of
+ * type {@code K}, general mappers can be obtained for any pre-given collection
+ * of keys.  Even though this could be modeled by users via a second level of a
+ * regular Java Map, special constructs are available providing equivalent
+ * functionality but with potentially better performance and lower memory usage.
  * {@snippet lang = java:
- *    Function<String, Optional<String>> pageCache = Lazy.ofMapper(
+ * class LazyMapperDemo {
+ *    private final Function<String, Optional<String>> pageCache = Lazy.ofMapper(
  *                      List.of("home", "products", "contact"), DbTools::lookupPage);
- *    // ...
- *     String pageName = ...;
- *
-  *    String text = pageCache.apply(pageName)
+
+ *     String renderPage(String pageName) {
+ *         return pageCache.apply(pageName)
  *                      .orElseGet(() -> lookupPage(pageName));
- *    // ...
+ *     }
+
  *    String lookupPage(String pageName) {
- *      // Gets the HTML code for the named page from the content database
+ *      // Gets the HTML code for the named page from a content database
  *    }
+ * }
  *}
- * Individual key mappers can also be provided via a collection of
+ * Individual key mapping can also be provided via a collection of
  * {@linkplain java.util.concurrent.lazy.KeyMapper key mappers} as shown in this example:
  * {@snippet lang = java:
- *    Function<Integer, Optional<String>> lazy = Lazy.ofMapper(List.of(
- *            new KeyMapper(400, this::loadBadRequestFromDb),
- *            new KeyMapper(401, this::loadUnaothorizedFromDb),
- *            new KeyMapper(403, this::loadForbiddenFromDb),
- *            new KeyMapper(404, this::loadNotFoundFromDb)
- *         );
- *    // ...
- *    if (returnCode >= 400) {
- *        response.println(lazy.apply(returnCode)
- *                             .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
+ * class MapperDemo {
+ *
+ *    private static final Function<Integer, Optional<String>> lazy =
+ *            Lazy.ofMapper(List.of(
+ *                new KeyMapper(400, this::loadBadRequestFromDb),
+ *                new KeyMapper(401, this::loadUnaothorizedFromDb),
+ *                new KeyMapper(403, this::loadForbiddenFromDb),
+ *                new KeyMapper(404, this::loadNotFoundFromDb)
+ *            ));
+ *
+ *    void servePage(Request request, Response response) {
+ *        int returnCode = renderPage(request, response);
+ *        if (returnCode >= 400) {
+ *            response.println(lazy.apply(returnCode)
+ *                                 .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
+ *        }
  *    }
+ * }
  *}
  *
  * <h3 id="general">General Properties of the Lazy Constructs</h3>
@@ -158,19 +228,24 @@
  * All methods of the classes in this package will throw a {@link NullPointerException}
  * if a reference parameter is {@code null}.
  *
- * All lazy constucts are nullofobic meaning if nullablilty for values stores is desired,
- * the value has to be modelled using a construct that can express a null value in an explicit way such as
- * {@link java.util.Optional#empty()}:
+ * All lazy constructs are "nullofobic" meaning a provider can never return {@code null}.  If nullablilty
+ * for values stored are desired, the values have to be modeled using a construct that can express
+ * {@code null} values in an explicit way such as {@link java.util.Optional#empty()}:
  * {@snippet lang = java:
- *   Supplier<Optional<Color>> backgroundColor = Lazy.of(this::calculateBgColor);
- *   ...
- *   var bg = backgroundColor.get()
- *                .orElse("<none>");
- *   ...
- *   private Optional<Color> calculateBgColor() {
- *       ...
+ * import java.util.Optional;class NullDemo {
+ *   private Supplier<Optional<Color>> backgroundColor =
+ *           Lazy.of(() -> Optional.ofNullable(calculateBgColor()));
+ *
+ *   Color backgroundColor() {
+ *       return backgroundColor.get()
+ *                  .orElse("<unknown>");
+ *    }
+ *
+ *   private Color calculateBgColor() {
+ *       // Read background color from file returning "null" if it fails.
  *   }
  * }
+ *}
  *
  * @since 22
  */
diff --git a/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java b/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
index 84d3cce737b..d3ee061a090 100644
--- a/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
+++ b/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
@@ -72,6 +72,9 @@ public enum Feature {
         VIRTUAL_THREADS,
         @JEP(number=434, title="Foreign Function & Memory API", status="Second Preview")
         FOREIGN,
+        // JEP TBI
+        @JEP(number=-1, title="Lazy Initialization", status="First Preview")
+        LAZY,
         /**
          * A key for testing.
          */
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
index 7a49c1631ea..a4e081e2d56 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
@@ -4,7 +4,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.lazy.Lazy;
 import java.util.concurrent.lazy.LazyReferenceArray;
-import java.util.concurrent.lazy.playground.DemoMapObject;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
index e450b28ac22..5374db9b96d 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
@@ -8,7 +8,6 @@
 import java.util.concurrent.lazy.KeyMapper;
 import java.util.concurrent.lazy.Lazy;
 import java.util.concurrent.lazy.LazyReferenceArray;
-import java.util.concurrent.lazy.playground.DemoMapObject;
 import java.util.function.Function;
 
 import static java.util.stream.Collectors.toMap;
diff --git a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
index 1576df9a236..b875d9b103c 100644
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -111,6 +111,7 @@
     exports java.util;
     exports java.util.concurrent;
     exports java.util.concurrent.atomic;
+    exports java.util.concurrent.lazy;
     exports java.util.concurrent.locks;
     exports java.util.function;
     exports java.util.jar;
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
index 52c9693f4c5..995be34ccbb 100644
--- a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
@@ -24,6 +24,7 @@
 /*
  * @test
  * @summary Verify basic BasicLazyReferenceArray operations
+ * @enablePreview
  * @run junit BasicLazyReferenceArrayTest
  */
 
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
index 6fa16cacf47..3f8ce01d33b 100644
--- a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
@@ -24,6 +24,7 @@
 /*
  * @test
  * @summary Verify basic LazyReference operations
+ * @enablePreview
  * @run junit BasicLazyReferenceTest
  */
 
diff --git a/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
index 4a2d53bd596..7c1fa425394 100644
--- a/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
+++ b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
@@ -24,6 +24,7 @@
 /*
  * @test
  * @summary Verify basic BasicLazyReferenceArray operations
+ * @enablePreview
  * @run junit LazyReferenceArrayMappingTest
  */
 
@@ -47,38 +48,20 @@ final class LazyReferenceArrayMappingTest {
     CountingIntegerMapper mapper;
 
     LazyReferenceArray.IntKeyMapper intKeyMapper;
-    LazyReferenceArray.KeyMapper<String> keyMapper;
 
     @BeforeEach
     void setup() {
         lazy = Lazy.ofEmptyArray(SIZE);
         mapper = new CountingIntegerMapper(SIZE);
         intKeyMapper = LazyReferenceArray.IntKeyMapper.ofConstant(2);
-        // keyMapper = LazyReferenceArray.KeyMapper.ofHashing("A", "B", "C");
     }
 
-/*    @Test
+    @Test
     void mapInt() {
         int two = lazy.mapIntAndApply(intKeyMapper, 2, i -> 2, i -> 0);
         assertEquals(2, two);
         int three = lazy.mapIntAndApply(intKeyMapper, 3, i -> 2, i -> 0);
         assertEquals(0, three);
-    }*/
-
-    @Test
-    void a() {
-        var pm = LazyReferenceArray.KeyMapper.polynomialMapper("A", "B", "C");
-        System.out.println(pm);
-    }
-
-    @Test
-    void mapString() {
-        LazyReferenceArray<String> lazyStrings = Lazy.ofEmptyArray(keyMapper.requiredLength().getAsInt());
-        Function<String, String> mapper = s -> s.repeat(10);
-        String as = lazyStrings.mapAndApply(keyMapper, "A", mapper, Function.identity());
-        assertEquals(mapper.apply("A"), as);
-        String x = lazyStrings.mapAndApply(keyMapper, "X", mapper, Function.identity());
-        assertEquals("X", x);
     }
 
     static private final class CountingIntegerMapper implements IntFunction<Integer> {

From 1dde0365b60106f4251996fbadc694de722ca2c8 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 11 Apr 2023 18:37:58 +0200
Subject: [PATCH 04/16] Use real snippets and improve docs

---
 .../java/util/concurrent/lazy/KeyMapper.java  |  44 ++-
 .../java/util/concurrent/lazy/Lazy.java       | 137 ++++++---
 .../concurrent/lazy/LazyReferenceArray.java   |   1 +
 .../util/concurrent/lazy/package-info.java    | 197 +++++++------
 .../snippet-files/PackageInfoSnippets.java    | 274 ++++++++++++++++++
 .../concurrent/lazy/StandardKeyMapper.java    |   8 +
 6 files changed, 520 insertions(+), 141 deletions(-)
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
index c4ff32bcaac..950519afb51 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
@@ -1,18 +1,50 @@
 package java.util.concurrent.lazy;
 
+import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.StandardKeyMapper;
+
+import java.util.Objects;
 import java.util.function.Function;
 
 /**
- * This class represents a binding between a key
+ * This class represents an association between a key
  * of type K and a mapper that can compute an associated
  * value of type V at a later time.
  *
  * @param <K>    the type of the key maintained by this association
  * @param <V>    the type of mapped values
- * @param key    to bind to a mapper
- * @param mapper to be applied for the key at a later time
+ *
+ * @since 22
  */
-public record KeyMapper<K, V>(
-        K key,
-        Function<? super K, ? extends V> mapper) {
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public sealed interface KeyMapper<K, V>
+    permits StandardKeyMapper {
+
+    /**
+     * {@return the key for this KeyMapper for
+     * the associated {@linkplain #mapper() mapper}}.
+     */
+    K key();
+
+    /**
+     * {@return the mapper for this KeyMapper to be applied for
+     * the associated {@linkplain #key key} at a later time}.
+     */
+    Function<? super K, ? extends V> mapper();
+
+    /**
+     * {@return a new KeyMapper for the provided {@code key}/{@code mapper} association}.
+     *
+     * @param <K>    the type of the key maintained by this association
+     * @param <V>    the type of mapped values
+     * @param key    to associate to a mapper
+     * @param mapper to associate to a key and to be applied for the key at a later time
+     */
+    public static <K, V> KeyMapper<K, V> of(K key,
+                                            Function<? super K, ? extends V> mapper) {
+        Objects.requireNonNull(key);
+        Objects.requireNonNull(mapper);
+        return new StandardKeyMapper<>(key, mapper);
+    }
+
 }
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 726e6ac6de6..72278c64d77 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -14,6 +14,8 @@
 /**
  * This class provides common factories and builders classes for all
  * Lazy class variants.
+ *
+ * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
 public final class Lazy {
@@ -109,12 +111,14 @@ public enum Evaluation {
      * an exception will be thrown.
      * <p>
      * {@snippet lang = java:
-     *    LazyReference<T> lazy = LazyReference.ofEmpty();
-     *    T value = lazy.getOrNull();
-     *    assertIsNull(value); // Value is initially null
-     *    // ...
-     *    T value = lazy.supplyIfEmpty(Value::new);
-     *    assertNotNull(value); // Value is non-null
+     *     class Fox {
+     *
+     *         private final LazyReference<String> lazy = Lazy.ofEmpty();
+     *
+     *         String init(String color) {
+     *             return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+     *         }
+     *     }
      *}
      *
      * @param <T> The type of the value
@@ -131,9 +135,15 @@ public static <T> LazyReference<T> ofEmpty() {
      * {@link LazyReference#supplyIfEmpty(Supplier)}.
      * <p>
      * {@snippet lang = java:
-     *    LazyReference<T> lazy = Lazy.of(Value::new);
-     *    // ...
-     *    T value = lazy.get();
+     *     class DemoPreset {
+     *
+     *         private static final LazyReference<Foo> FOO = Lazy.of(Foo::new);
+     *
+     *         public Foo theBar() {
+     *             // Foo is lazily constructed and recorded here upon first invocation
+     *             return FOO.get();
+     *         }
+     *     }
      *}
      *
      * @param <T>            The type of the value
@@ -147,6 +157,23 @@ public static <T> LazyReference<T> of(Supplier<? extends T> presetSupplier) {
     /**
      * {@return a builder that can be used to build a custom LazyReference}.
      * @param <T> type of the value the LazyReference will handle.
+     * Here is how a lazy value can be computed in the background and that may already be computed
+     * when first requested from user code:
+     * {@snippet lang = java:
+     *     class DemoBackground {
+     *
+     *         private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
+     *                 .withSupplier(Foo::new)
+     *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+     *                 .build();
+     *
+     *         public static void main(String[] args) throws InterruptedException {
+     *             Thread.sleep(1000);
+     *             // lazy is likely already pre-computed here by a background thread
+     *             System.out.println("lazy.get() = " + lazy.get());
+     *         }
+     *     }
+     * }
      */
     // Todo: Figure out a better way for determining the type (e.g. type token)
     public static <T> LazyReference.Builder<T> builder() {
@@ -160,12 +187,17 @@ public static <T> LazyReference.Builder<T> builder() {
      * an exception will be thrown.
      * <p>
      * {@snippet lang = java:
-     *    // Cache the first 64 users
-     *    private static final LazyReferenceArray<User> lazy = Lazy.ofEmptyArray(64);
-     *    ...
-     *    Connection c = ...
-     *    User value = lazy.computeIfEmpty(42, i -> findUserById(c, i));
-     *    assertNotNull(value); // Value is non-null
+     * class UserCache {
+     *
+     *         // Cache the first 64 users
+     *         private static final LazyReferenceArray<User> USER_CACHE =
+     *                 Lazy.ofEmptyArray(64);
+     *
+     *         public User user(int id) {
+     *             Connection c = getDatabaseConnection();
+     *             return USER_CACHE.computeIfEmpty(id, i -> findUserById(c, i));
+     *         }
+     *     }
      *}
      *
      * @param <T>  The type of the values
@@ -186,10 +218,20 @@ public static <T> LazyReferenceArray<T> ofEmptyArray(int size) {
      * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
      * <p>
      * {@snippet lang = java:
-     *    LazyReferenceArray<Value> lazy = Lazy.ofArray(32, index -> new Value(1L << index));
-     *    // ...
-     *    Value value = lazy.get(16);
-     *}
+     *     class DemoArray {
+     *
+     *         private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+     *                 Lazy.ofArray(32, index -> new Value(1L << index));
+     *
+     *         public Value powerOfTwoValue(int n) {
+     *             if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
+     *                 throw new IllegalArgumentException(Integer.toString(n));
+     *             }
+     *
+     *             return VALUE_PO2_CACHE.apply(n);
+     *         }
+     *     }
+     * }
      *
      * @param <T>          The type of the values
      * @param size         the size of the array
@@ -214,17 +256,16 @@ public static <T> LazyReferenceArray<T> ofArray(int size,
      * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
      * <p>
      * {@snippet lang = java:
-     *    Function<String, Optional<String>> pageCache = Lazy.ofMapper(
-     *                      List.of("home", "products", "contact"), DbTools::lookupPage);
-     *    // ...
-     *     String pageName = ...;
+     *     class DemoLazyMapper {
+     *
+     *         private final Function<String, Optional<String>> pageCache = Lazy.mapping(
+     *                 List.of("home", "products", "contact"), DbTools::lookupPage);
      *
-     *    String text = pageCache.apply(pageName)
-     *                      .orElseGet(() -> lookupPage(pageName));
-     *    // ...
-     *    String lookupPage(String pageName) {
-     *      // Gets the HTML code for the named page from the content database
-     *    }
+     *         public String renderPage(String pageName) {
+     *             return pageCache.apply(pageName)
+     *                     .orElseGet(() -> DbTools.lookupPage(pageName));
+     *         }
+     *     }
      *}
      *
      * @param <K> the type of keys maintained by this mapper
@@ -232,8 +273,8 @@ public static <T> LazyReferenceArray<T> ofArray(int size,
      * @param keys to be mapped
      * @param mapper to apply when computing and recording values
      */
-    public static <K, V> Function<K, Optional<V>> ofMapper(Collection<K> keys,
-                                                           Function<? super K, ? extends V> mapper) {
+    public static <K, V> Function<K, Optional<V>> mapping(Collection<K> keys,
+                                                          Function<? super K, ? extends V> mapper) {
         Objects.requireNonNull(keys);
         Objects.requireNonNull(mapper);
         return new LazySingleMapper<>(keys, mapper);
@@ -246,24 +287,34 @@ public static <K, V> Function<K, Optional<V>> ofMapper(Collection<K> keys,
      * provided to the returned Function}.
      * <p>
      * {@snippet lang = java:
-     *    Function<Integer, Optional<String>> lazy = Lazy.ofMapper(List.of(
-     *            new KeyMapper(400, this::loadBadRequestFromDb),
-     *            new KeyMapper(401, this::loadUnaothorizedFromDb),
-     *            new KeyMapper(403, this::loadForbiddenFromDb),
-     *            new KeyMapper(404, this::loadNotFoundFromDb)
-     *         );
-     *    // ...
-     *    if (returnCode >= 400) {
-     *        response.println(lazy.apply(returnCode)
-     *                             .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
-     *    }
+     * class DemoErrorPageMapper {
+     *
+     *         private static final Function<Integer, Optional<String>> lazy =
+     *                 Lazy.mapping(
+     *                         List.of(
+     *                                 KeyMapper.of(400, DbTools::loadBadRequestPage),
+     *                                 KeyMapper.of(401, DbTools::loadUnaothorizedPage),
+     *                                 KeyMapper.of(403, DbTools::loadForbiddenPage),
+     *                                 KeyMapper.of(404, DbTools::loadNotFoundPage)
+     *                         )
+     *                 );
+     *
+     *         public String servePage(Request request) {
+     *             int returnCode = check(request);
+     *             if (returnCode >= 400) {
+     *                 return lazy.apply(returnCode)
+     *                         .orElse("<!DOCTYPE html><title>Oops: " + returnCode + "</title>");
+     *             }
+     *             return render(request);
+     *         }
+     *     }
      *}
      *
      * @param <K> the type of keys maintained by this mapper
      * @param <V> the type of mapped values
      * @param keyMappers to be lazily evaluated and recorded
      */
-    public static <K, V> Function<K, Optional<V>> ofMapper(Collection<KeyMapper<K, V>> keyMappers) {
+    public static <K, V> Function<K, Optional<V>> mapping(Collection<KeyMapper<K, V>> keyMappers) {
         Objects.requireNonNull(keyMappers);
         return new LazyMapper<>(keyMappers);
     }
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
index 9d642bbf6ab..4b3fb0a9735 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
@@ -64,6 +64,7 @@
  * at most as described by {@link Stable}.
  *
  * @param <V> The type of the values to be recorded
+ * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
 public final class LazyReferenceArray<V> implements IntFunction<V> {
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index c21a8f1ab3a..fe0b26d630b 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -43,42 +43,49 @@
  *
  * In its simplest form, Lazy can provide atomic lazy evaluation using a <em>preset-supplier</em>:
  *
+ * {@snippet class="PackageInfoSnippets" region="DemoPreset"}
+ *
  * {@snippet lang = java :
- * class Foo {
- *   private static final LazyReference<Bar> BAR = Lazy.of(Bar::new);
+ *     class DemoPreset {
  *
- *   public Bar theBar() {
- *     return BAR.get(); // Bar is lazily computed here on first invocation
- *   }
- * }
+ *         private static final LazyReference<Foo> FOO = Lazy.of(Foo::new);
+ *
+ *         public Foo theBar() {
+ *             // Foo is lazily constructed and recorded here upon first invocation
+ *             return FOO.get();
+ *         }
+ *     }
  *}
  * The performance of the example above is on pair with using an inner/private class
  * holding a lazily initialized variable but with no overhead imposed by the extra
  * class as illustraded hereunder:
  *
  {@snippet lang = java :
- * class Foo {
+ *     class DemoHolder {
  *
- *   public Bar theBar() {
- *      class Holder {
- *          Bar bar = new Bar();
- *      }
- *     return Holder.bar; // Bar is lazily computed here on first invocation
- *   }
- * }
+ *         public Foo theBar() {
+ *             class Holder {
+ *                 private static final Foo FOO = new Foo();
+ *             }
+ *
+ *             // Foo is lazily constructed and recorded here upon first invocation
+ *             return Holder.FOO;
+ *         }
+ *     }
  *}
  *
  * On some occasions, a preset-supplier might not be known a priori or the
  * lazy value to compute might depend on values not known at declaration time.  In
  * such cases, an empty LazyReference can be obtained and used as exemplified below:
  * {@snippet lang = java:
- * class Fox {
- *     private final LazyReference<String> lazy = Lazy.ofEmpty();
+ *     class Fox {
+ *
+ *         private final LazyReference<String> lazy = Lazy.ofEmpty();
  *
- *     String init(String color) {
- *         return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+ *         String init(String color) {
+ *             return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+ *         }
  *     }
- * }
  *}
  *
  * A custom configurable LazyReference can be obtained via the
@@ -86,39 +93,39 @@
  * Here is how a lazy value can be computed in the background and that may already be computed
  * when first requested from user code:
  * {@snippet lang = java:
- * class BackgroundDemo {
- *    private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
- *             .withSupplier(Foo::new)
- *             .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
- *             .build();
- *
- *     public static void main(String[] args) throws InterruptedException {
- *         Thread.sleep(1000);
- *         // lazy is likely already pre-computed here by a background thread
- *         System.out.println("lazy.get() = " + lazy.get());
+ *     class DemoBackground {
+ *
+ *         private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
+ *                 .withSupplier(Foo::new)
+ *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+ *                 .build();
+ *
+ *         public static void main(String[] args) throws InterruptedException {
+ *             Thread.sleep(1000);
+ *             // lazy is likely already pre-computed here by a background thread
+ *             System.out.println("lazy.get() = " + lazy.get());
+ *         }
  *     }
  * }
- * }
  *
  * {@code LazyReference<T>} implements {@code Supplier<T>} allowing simple
  * interoperability with legacy code and less specific type declaration
  * as shown in the example hereunder:
  * {@snippet lang = java:
- *    class SupplierDemo {
+ *     class SupplierDemo {
  *
  *         // Eager Supplier of Foo
  *         private static final Supplier<Foo> EAGER_FOO = Foo::new;
  *
  *         // Turns an eager Supplier into a caching lazy Supplier
- *         private static final Supplier<Foo> LAZY_CACHE_FOO = Lazy.of(EAGER_FOO);
+ *         private static final Supplier<Foo> LAZILY_CACHED_FOO = Lazy.of(EAGER_FOO);
  *
  *         public static void main(String[] args) {
- *            // Lazily compute the one and only Foo
- *            Foo theFoo = LAZY_CACHE_FOO.get();
+ *             // Lazily compute the one-and-only Foo
+ *             Foo theFoo = LAZILY_CACHED_FOO.get();
  *         }
- *    }
+ *     }
  *}
- *
  * LazyReference contains additional methods for checking its
  * {@linkplain java.util.concurrent.lazy.LazyReference#state() state} and getting
  * any {@linkplain java.util.concurrent.lazy.LazyReference#exception()} that might be thrown
@@ -131,14 +138,19 @@
  * for LazyReference instance but with an extra initial arity, indicating the desired length/index
  * of the array:
  * {@snippet lang = java:
- * class ArrayDemo {
- *    private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
- *            Lazy.ofArray(32, index -> new Value(1L << index));
+ *     class DemoArray {
  *
- *    Value powerOfTwoValue(int n) {
- *        return VALUE_PO2_CACHE.get(n);
- *    }
- * }
+ *         private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+ *                 Lazy.ofArray(32, index -> new Value(1L << index));
+ *
+ *         public Value powerOfTwoValue(int n) {
+ *             if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
+ *                 throw new IllegalArgumentException(Integer.toString(n));
+ *             }
+ *
+ *             return VALUE_PO2_CACHE.apply(n);
+ *         }
+ *     }
  * }
  * As can be seen above, an array takes an {@link java.util.function.IntFunction} rather
  * than a {@link java.util.function.Supplier }, allowing custom values to be
@@ -147,35 +159,36 @@
  * As was the case for LazyReference, empty LazyReferenceArray instances can also be
  * constructed, allowing lazy mappers known at a later stage to be used:
  * {@snippet lang = java:
- * class UserCache {
- *     // Cache the first 64 users
- *     private static final LazyReferenceArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
- *
- *     User user(int id) {
- *         Connection c = getDatabaseConnection();
- *         User value = lazy.computeIfEmpty(id, i -> findUserById(c, i));
- *         assertNotNull(value); // Value is non-null
+ *     class UserCache {
+ *
+ *         // Cache the first 64 users
+ *         private static final LazyReferenceArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
+ *
+ *         public User user(int id) {
+ *             Connection c = getDatabaseConnection();
+ *             return USER_CACHE.computeIfEmpty(id, i -> findUserById(c, i));
+ *         }
  *     }
  * }
- * }
  *
  * {@code LazyReferenceArray<T>} implements {@code IntFunction<T>} allowing simple interoperability
  * with existing code and with less specific type declarations as shown hereunder:
  * {@snippet lang = java:
- * class IntFunctionDemo {
- *     // Eager Supplier of Foo
- *     private static final IntFunction<Foo> EAGER_FOO =
- *             index -> new Foo(index);
+ *     class DemoIntFunction {
+ *
+ *         // Eager IntFunction<Value>
+ *         private static final IntFunction<Value> EAGER_VALUE =
+ *                 index -> new Value(index);
  *
- *     // Turns an eager Supplier into a caching lazy Supplier
- *     private static final IntSupplier<Foo> LAZY_CACHE_FOO =
- *             Lazy.ofArray(64, eagerFoo);
+ *         // Turns an eager IntFunction into a caching lazy IntFunction
+ *         private static final IntFunction<Value> LAZILY_CACHED_VALUES =
+ *                 Lazy.ofArray(64, EAGER_VALUE);
  *
- *     public static void main(String[] args) {
- *        Foo foo42 = LAZY_CACHE_FOO.apply(42);
+ *         public static void main(String[] args) {
+ *             Value value42 = LAZILY_CACHED_VALUES.apply(42);
+ *         }
  *     }
  * }
- * }
  *
  * Todo: Describe IntKeyMapper
  *
@@ -186,41 +199,41 @@
  * regular Java Map, special constructs are available providing equivalent
  * functionality but with potentially better performance and lower memory usage.
  * {@snippet lang = java:
- * class LazyMapperDemo {
- *    private final Function<String, Optional<String>> pageCache = Lazy.ofMapper(
- *                      List.of("home", "products", "contact"), DbTools::lookupPage);
-
- *     String renderPage(String pageName) {
- *         return pageCache.apply(pageName)
- *                      .orElseGet(() -> lookupPage(pageName));
+ *     class DemoLazyMapper {
+ *
+ *         private final Function<String, Optional<String>> pageCache = Lazy.mapping(
+ *                 List.of("home", "products", "contact"), DbTools::lookupPage);
+ *
+ *         public String renderPage(String pageName) {
+ *             return pageCache.apply(pageName)
+ *                     .orElseGet(() -> DbTools.lookupPage(pageName));
+ *         }
  *     }
-
- *    String lookupPage(String pageName) {
- *      // Gets the HTML code for the named page from a content database
- *    }
- * }
  *}
  * Individual key mapping can also be provided via a collection of
  * {@linkplain java.util.concurrent.lazy.KeyMapper key mappers} as shown in this example:
  * {@snippet lang = java:
- * class MapperDemo {
- *
- *    private static final Function<Integer, Optional<String>> lazy =
- *            Lazy.ofMapper(List.of(
- *                new KeyMapper(400, this::loadBadRequestFromDb),
- *                new KeyMapper(401, this::loadUnaothorizedFromDb),
- *                new KeyMapper(403, this::loadForbiddenFromDb),
- *                new KeyMapper(404, this::loadNotFoundFromDb)
- *            ));
- *
- *    void servePage(Request request, Response response) {
- *        int returnCode = renderPage(request, response);
- *        if (returnCode >= 400) {
- *            response.println(lazy.apply(returnCode)
- *                                 .orElse("<!DOCTYPE html><title>Oops: "+returnCode+"</title>"));
- *        }
- *    }
- * }
+ * class DemoErrorPageMapper {
+ *
+ *         private static final Function<Integer, Optional<String>> lazy =
+ *                 Lazy.mapping(
+ *                         List.of(
+ *                                 KeyMapper.of(400, DbTools::loadBadRequestPage),
+ *                                 KeyMapper.of(401, DbTools::loadUnaothorizedPage),
+ *                                 KeyMapper.of(403, DbTools::loadForbiddenPage),
+ *                                 KeyMapper.of(404, DbTools::loadNotFoundPage)
+ *                         )
+ *                 );
+ *
+ *         public String servePage(Request request) {
+ *             int returnCode = check(request);
+ *             if (returnCode >= 400) {
+ *                 return lazy.apply(returnCode)
+ *                         .orElse("<!DOCTYPE html><title>Oops: " + returnCode + "</title>");
+ *             }
+ *             return render(request);
+ *         }
+ *     }
  *}
  *
  * <h3 id="general">General Properties of the Lazy Constructs</h3>
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
new file mode 100644
index 00000000000..49b8591f88b
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.concurrent.lazy.snippets;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.lazy.KeyMapper;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+
+/**
+ * Sippets for the package-info file
+ */
+public class PackageInfoSnippets {
+
+    private PackageInfoSnippets() {
+    }
+
+    // @start region="DemoPreset"
+    class DemoPreset {
+
+        private static final LazyReference<Foo> FOO = Lazy.of(Foo::new);
+
+        public Foo theBar() {
+            // Foo is lazily constructed and recorded here upon first invocation
+            return FOO.get();
+        }
+    }
+    // @end
+
+    // @start region="DemoHolder"
+    class DemoHolder {
+
+        public Foo theBar() {
+            class Holder {
+                private static final Foo FOO = new Foo();
+            }
+
+            // Foo is lazily constructed and recorded here upon first invocation
+            return Holder.FOO;
+        }
+    }
+    // @end
+
+    // @start region="Fox"
+    class Fox {
+
+        private final LazyReference<String> lazy = Lazy.ofEmpty();
+
+        String init(String color) {
+            return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+        }
+    }
+    // @end
+
+    // @start region="DemoBackground"
+    class DemoBackground {
+
+        private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
+                .withSupplier(Foo::new)
+                .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+                .build();
+
+        public static void main(String[] args) throws InterruptedException {
+            Thread.sleep(1000);
+            // lazy is likely already pre-computed here by a background thread
+            System.out.println("lazy.get() = " + lazy.get());
+        }
+    }
+    // @end
+
+    // @start region="SupplierDemo"
+    class SupplierDemo {
+
+        // Eager Supplier of Foo
+        private static final Supplier<Foo> EAGER_FOO = Foo::new;
+
+        // Turns an eager Supplier into a caching lazy Supplier
+        private static final Supplier<Foo> LAZILY_CACHED_FOO = Lazy.of(EAGER_FOO);
+
+        public static void main(String[] args) {
+            // Lazily construct and record the one-and-only Foo
+            Foo theFoo = LAZILY_CACHED_FOO.get();
+        }
+    }
+    // @end
+
+    // @start region="DemoArray"
+    class DemoArray {
+
+        private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+                Lazy.ofArray(32, index -> new Value(1L << index));
+
+        public Value powerOfTwoValue(int n) {
+            if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
+                throw new IllegalArgumentException(Integer.toString(n));
+            }
+
+            return VALUE_PO2_CACHE.apply(n);
+        }
+    }
+    // @end
+
+    // @start region="UserCache"
+    class UserCache {
+
+        // Cache the first 64 users
+        private static final LazyReferenceArray<User> USER_CACHE =
+                Lazy.ofEmptyArray(64);
+
+        public User user(int id) {
+            Connection c = getDatabaseConnection();
+            return USER_CACHE.computeIfEmpty(id, i -> findUserById(c, i));
+        }
+    }
+    // @end
+
+    // @start region="DemoIntFunction"
+    class DemoIntFunction {
+
+        // Eager IntFunction<Value>
+        private static final IntFunction<Value> EAGER_VALUE =
+                index -> new Value(index);
+
+        // Turns an eager IntFunction into a caching lazy IntFunction
+        private static final IntFunction<Value> LAZILY_CACHED_VALUES =
+                Lazy.ofArray(64, EAGER_VALUE);
+
+        public static void main(String[] args) {
+            Value value42 = LAZILY_CACHED_VALUES.apply(42);
+        }
+    }
+    // @end
+
+    // @start region="DemoLazyMapper"
+    class DemoLazyMapper {
+
+        private final Function<String, Optional<String>> pageCache = Lazy.mapping(
+                List.of("home", "products", "contact"), DbTools::lookupPage);
+
+        public String renderPage(String pageName) {
+            return pageCache.apply(pageName)
+                    .orElseGet(() -> DbTools.lookupPage(pageName));
+        }
+    }
+    // @end
+
+    // @start region="DemoErrorPageMapper"
+    class DemoErrorPageMapper {
+
+        private static final Function<Integer, Optional<String>> lazy =
+                Lazy.mapping(
+                        List.of(
+                                KeyMapper.of(400, DbTools::loadBadRequestPage),
+                                KeyMapper.of(401, DbTools::loadUnaothorizedPage),
+                                KeyMapper.of(403, DbTools::loadForbiddenPage),
+                                KeyMapper.of(404, DbTools::loadNotFoundPage)
+                        )
+                );
+
+        public String servePage(Request request) {
+            int returnCode = check(request);
+            if (returnCode >= 400) {
+                return lazy.apply(returnCode)
+                        .orElse("<!DOCTYPE html><title>Oops: " + returnCode + "</title>");
+            }
+            return render(request);
+        }
+    }
+    // @end
+
+    static class Foo {
+    }
+
+    static class Value {
+
+        long value;
+
+        public Value(long value) {
+            this.value = value;
+        }
+
+        long asLong() {
+            return value;
+        }
+    }
+
+    static class User {
+
+        private final int id;
+        private String name;
+
+
+        public User(int id) {
+            this.id = id;
+        }
+
+    }
+
+    static class Connection {
+    }
+
+    static class Request {
+    }
+
+    static Connection getDatabaseConnection() {
+        return new Connection();
+    }
+
+    User findUserById(Connection c,
+                              int id) {
+        return new User(id);
+    }
+
+    static class DbTools {
+        static String lookupPage(String pageName) {
+            // Gets the HTML code for the named page from a content database
+            return ""; // Whatever ...
+        }
+
+        static String loadBadRequestPage(int code) {
+            return "";
+        }
+
+        static String loadUnaothorizedPage(int code) {
+            return "";
+        }
+
+        static String loadForbiddenPage(int code) {
+            return "";
+        }
+
+        static String loadNotFoundPage(int code) {
+            return "";
+        }
+
+
+    }
+
+    int check(Request request) {
+        return 0;
+    }
+
+    String render(Request request) {
+        return "";
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java
new file mode 100644
index 00000000000..7bcc075f42e
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java
@@ -0,0 +1,8 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.concurrent.lazy.KeyMapper;
+import java.util.function.Function;
+
+public record StandardKeyMapper<K, V>(K key,
+                                      Function<? super K, ? extends V> mapper)
+        implements KeyMapper<K, V> {}

From e538f27d848ee1892c81cf5508abcabdefc0d79e Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 11 Apr 2023 18:57:46 +0200
Subject: [PATCH 05/16] Add int mapper example

---
 .../util/concurrent/lazy/package-info.java    | 12 ++++-
 .../snippet-files/PackageInfoSnippets.java    | 53 ++++++++++++++++++-
 2 files changed, 62 insertions(+), 3 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index fe0b26d630b..74e9980d6fb 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -190,10 +190,18 @@
  *     }
  * }
  *
- * Todo: Describe IntKeyMapper
+ * Sometimes, there is a mapping from an {@code int} key to an index, preventing
+ * the key to be used directly. For example, when caching only certain
+ * values as shown below where we cache every 10th value:
+ * {@snippet lang = java:
+ *
+ *   // Todo: refactor how int mappers are obtained and show an example here.
+ *
+ * }
  *
  * <h3 id="lazymapper">LazyMapper</h3>
- * When several lazy values are to be held and accessible via arbitrary keys of
+ *
+ * When several lazy values are to be held and accessible via keys of arbitrary
  * type {@code K}, general mappers can be obtained for any pre-given collection
  * of keys.  Even though this could be modeled by users via a second level of a
  * regular Java Map, special constructs are available providing equivalent
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
index 49b8591f88b..b75a5e7623a 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
@@ -195,6 +195,57 @@ public String servePage(Request request) {
     }
     // @end
 
+    // @start region="DemoFibMapped"
+    final class DemoFibMapped {
+
+        // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 ...
+        // fib(11) = 89
+        // n non-negative
+        static int fib(int n) {
+            return (n <= 1)
+                    ? n
+                    : fib(n - 1) + fib(n - 2);
+        }
+
+        private static final int INTERVAL = 10; // Must be > 2
+
+        private static final LazyReferenceArray<Integer> FIB_10_CACHE =
+                Lazy.ofEmptyArray(3);
+
+        private static final LazyReferenceArray.IntKeyMapper KEY_MAPPER =
+                LazyReferenceArray.IntKeyMapper.ofConstant(INTERVAL);
+
+        /**
+         * Main method
+         *
+         * @param args from command line
+         * @throws InterruptedException if a thred was interrupted
+         */
+        public static void main(String[] args) throws InterruptedException {
+            System.out.println("fib(11) = " + fib(11)); // 288 invocations
+
+            System.out.println(FIB_10_CACHE);
+            System.out.println("cachedFib(11) = " + cachedFib(11)); // 288 invocations
+
+            System.out.println(FIB_10_CACHE);
+            System.out.println("cachedFib(11) = " + cachedFib(11)); // 111 invocations
+        }
+
+        // Only works for values up to ~30
+
+        static int cachedFib(int n) {
+            if (n <= 1)
+                return n;
+            return FIB_10_CACHE.mapIntAndApply(KEY_MAPPER, n,
+                    DemoFibMapped::fib,
+                    DemoFibMapped::fib);
+        }
+
+        private DemoFibMapped() {
+        }
+    }
+    // @end
+
     static class Foo {
     }
 
@@ -234,7 +285,7 @@ static Connection getDatabaseConnection() {
     }
 
     User findUserById(Connection c,
-                              int id) {
+                      int id) {
         return new User(id);
     }
 

From bca2f060c5b5e8be94775b4c877deb55983faa47 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 12 Apr 2023 18:45:42 +0200
Subject: [PATCH 06/16] Remove Semaphore

---
 .../util/concurrent/lazy/LazyReference.java   | 89 ++++++++-----------
 .../util/concurrent/lazy/LazyUtil.java        | 43 +++++++++
 2 files changed, 80 insertions(+), 52 deletions(-)
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index 2418383f6c1..47006b18290 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -25,6 +25,7 @@
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.LazyUtil;
 import jdk.internal.vm.annotation.Stable;
 
 import java.lang.invoke.MethodHandles;
@@ -32,10 +33,11 @@
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
+import static jdk.internal.util.concurrent.lazy.LazyUtil.varHandle;
+
 /**
  * An object reference in which the value can be lazily and atomically computed.
  * <p>
@@ -70,14 +72,25 @@
 public final class LazyReference<V>
         implements Supplier<V> {
 
-    // Allows access to the state variable with arbitary memory semantics
-    private static final VarHandle VALUE_HANDLE = valueHandle();
+    // Allows access to the "value" field with arbitary memory semantics
+    private static final VarHandle VALUE_HANDLE;
+
+    static {
+        try {
+            VALUE_HANDLE = MethodHandles.lookup()
+                    .findVarHandle(LazyReference.class, "value", Object.class);
+            // .withInvokeExactBehavior(); // Make sure no boxing is made?
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
 
     private final Lazy.Evaluation earliestEvaluation;
-    private final Semaphore semaphore;
 
     private Supplier<? extends V> presetProvider;
 
+    private volatile boolean supplying;
+
     @Stable
     private Object value;
 
@@ -85,7 +98,6 @@
                   Supplier<? extends V> presetSupplier) {
         this.earliestEvaluation = earliestEvaluation;
         this.presetProvider = presetSupplier;
-        this.semaphore = new Semaphore(1);
         if (earliestEvaluation != Lazy.Evaluation.AT_USE && presetSupplier != null) {
             // Start computing the value via a background Thread.
             Thread.ofVirtual()
@@ -99,7 +111,6 @@
         this.earliestEvaluation = Lazy.Evaluation.CREATION;
         this.presetProvider = null;
         this.value = Objects.requireNonNull(value);
-        this.semaphore = null;
     }
 
     /**
@@ -121,6 +132,7 @@
      *}
      */
     public Lazy.State state() {
+        // Try normal memory semantics first
         Object o = value;
         if (o != null) {
             return o instanceof Exception
@@ -128,23 +140,19 @@ public Lazy.State state() {
                     : Lazy.State.PRESENT;
         }
 
-        if (semaphore.availablePermits() == 0) {
+        if (supplying) {
             return Lazy.State.CONSTRUCTING;
         }
 
-        semaphore.acquireUninterruptibly();
-        try {
-            o = value;
-            if (o instanceof Exception) {
-                return Lazy.State.ERROR;
-            }
-            if (o == null) {
-                return Lazy.State.EMPTY;
-            }
-            return Lazy.State.PRESENT;
-        } finally {
-            semaphore.release();
+        // Use volatile semantics
+        o = VALUE_HANDLE.getVolatile(this);
+        if (o instanceof Exception) {
+            return Lazy.State.ERROR;
+        }
+        if (o == null) {
+            return Lazy.State.EMPTY;
         }
+        return Lazy.State.PRESENT;
     }
 
     /**
@@ -238,44 +246,34 @@ private V supplyIfEmpty0(Supplier<? extends V> supplier) {
             return castOrThrow(o);
         }
 
-        // implies acquire/release semantics when entering/leaving the monitor
-        semaphore.acquireUninterruptibly();
-        try {
+        // implies volatile semantics when entering/leaving the monitor
+        synchronized (this) {
             // Here, visibility is guaranteed
             o = value;
             if (o != null) {
                 return castOrThrow(o);
             }
+            if (supplier == null) {
+                throw new IllegalStateException("No pre-set supplier given");
+            }
             try {
-                if (supplier == null) {
-                    throw new IllegalStateException("No pre-set supplier given");
-                }
-
+                supplying = true;
                 V v = supplier.get();
                 if (v == null) {
                     throw new NullPointerException("Supplier returned null");
                 }
-
-                // Alt 1
-                // Prevents reordering. Changes only go in one direction.
-                // https://developer.arm.com/documentation/102336/0100/Load-Acquire-and-Store-Release-instructions
-                setValueRelease(v);
-
-                // Alt 2
-                // VarHandle.fullFence();
-                // VarHandle.fullFence();
+                VALUE_HANDLE.setVolatile(this, v);
                 return v;
             } catch (Throwable e) {
                 // Record the throwable instead of the value.
-                // Prevents reordering.
-                setValueRelease(e);
+                VALUE_HANDLE.setVolatile(this, e);
                 // Rethrow
                 throw e;
             } finally {
+                // Volatile semantics
+                supplying = false;
                 forgetPresetProvided();
             }
-        } finally {
-            semaphore.release();
         }
     }
 
@@ -394,23 +392,10 @@ private V castOrThrow(Object o) {
         return (V) o;
     }
 
-    private void setValueRelease(Object value) {
-        VALUE_HANDLE.setRelease(this, value);
-    }
-
     private void forgetPresetProvided() {
         // Stops preventing the provider from being collected once it has been
         // used (if initially set).
         this.presetProvider = null;
     }
 
-    private static VarHandle valueHandle() {
-        try {
-            return MethodHandles.lookup()
-                    .findVarHandle(LazyReference.class, "value", Object.class);
-            // .withInvokeExactBehavior(); // Make sure no boxing is made?
-        } catch (ReflectiveOperationException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
 }
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
new file mode 100644
index 00000000000..cc65c4b7e45
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
@@ -0,0 +1,43 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.concurrent.lazy.LazyReference;
+
+public final class LazyUtil {
+    private LazyUtil() {
+    }
+/*
+    // Atomically aquires (sets) the provided flag and returns if it was not previously set
+    // (using volatile semantics)
+    private boolean acquire(int flag) {
+        int previousFlag = (int) FLAGS_HANDLE.getAndBitwiseOr(this, flag);
+        return (previousFlag & flag) == 0;
+    }
+
+    // Atomically releases (clears) the provided flag and returns if it was previously set
+    // (using volatile semantics)
+    private boolean release(int flag) {
+        int previousFlag = (int) FLAGS_HANDLE.getAndBitwiseAnd(this, ~flag);
+        return (previousFlag & flag) != 0;
+    }
+
+    // Atomically obtains (gets) the provided flag (using volatile semantics)
+    private boolean get(int flag) {
+        int flags = (int) FLAGS_HANDLE.getVolatile(this);
+        return (flags & flag) != 0;
+    }*/
+
+    public static VarHandle varHandle(MethodHandles.Lookup lookup,
+                                      String fieldName,
+                                      Class<?> fieldType) {
+        try {
+            return lookup
+                    .findVarHandle(LazyReference.class, fieldName, fieldType);
+            // .withInvokeExactBehavior(); // Make sure no boxing is made?
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+}

From ad8d7bc6160112a5ee63d5c4ed550d2c3220c913 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Thu, 13 Apr 2023 11:20:10 +0200
Subject: [PATCH 07/16] Add Unsafe::isLocked

---
 .../util/concurrent/lazy/LazyReference.java   |  9 ++-
 .../java/util/concurrent/lazy/MarkWord.java   | 62 +++++++++++++++++++
 .../classes/jdk/internal/misc/Unsafe.java     | 18 ++++++
 3 files changed, 84 insertions(+), 5 deletions(-)
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index 47006b18290..e779c5eb9e6 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -25,6 +25,7 @@
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.misc.Unsafe;
 import jdk.internal.util.concurrent.lazy.LazyUtil;
 import jdk.internal.vm.annotation.Stable;
 
@@ -72,6 +73,8 @@
 public final class LazyReference<V>
         implements Supplier<V> {
 
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
     // Allows access to the "value" field with arbitary memory semantics
     private static final VarHandle VALUE_HANDLE;
 
@@ -89,8 +92,6 @@
 
     private Supplier<? extends V> presetProvider;
 
-    private volatile boolean supplying;
-
     @Stable
     private Object value;
 
@@ -140,7 +141,7 @@ public Lazy.State state() {
                     : Lazy.State.PRESENT;
         }
 
-        if (supplying) {
+        if (UNSAFE.isLocked(this)) {
             return Lazy.State.CONSTRUCTING;
         }
 
@@ -257,7 +258,6 @@ private V supplyIfEmpty0(Supplier<? extends V> supplier) {
                 throw new IllegalStateException("No pre-set supplier given");
             }
             try {
-                supplying = true;
                 V v = supplier.get();
                 if (v == null) {
                     throw new NullPointerException("Supplier returned null");
@@ -271,7 +271,6 @@ private V supplyIfEmpty0(Supplier<? extends V> supplier) {
                 throw e;
             } finally {
                 // Volatile semantics
-                supplying = false;
                 forgetPresetProvided();
             }
         }
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java b/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java
new file mode 100644
index 00000000000..d94efda4389
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java
@@ -0,0 +1,62 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.misc.Unsafe;
+
+import java.util.Arrays;
+import java.util.HexFormat;
+import java.util.stream.Collectors;
+
+/**
+ * To be removed!
+ */
+public class MarkWord {
+
+    private MarkWord() {
+    }
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    /**
+     * A
+     * @param args a
+     */
+    public static void main(String[] args) {
+
+        Foo foo = new Foo();
+
+        printMark(foo);
+        synchronized (foo) {
+            printMark(foo);
+        }
+        printMark(foo);
+
+        int LOCK_OFFSET = UNSAFE.addressSize();
+
+        System.out.println("UNSAFE.isLocked(foo) = " + UNSAFE.isLocked(foo));
+        System.out.println("UNSAFE.getIntVolatile(foo, LOCK_OFFSET) = " + UNSAFE.getIntVolatile(foo, LOCK_OFFSET));
+        synchronized (foo) {
+            System.out.println("UNSAFE.isLocked(foo) = " + UNSAFE.isLocked(foo));
+            System.out.println("UNSAFE.getIntVolatile(foo, LOCK_OFFSET) = " + UNSAFE.getIntVolatile(foo, LOCK_OFFSET));
+        }
+
+
+    }
+
+    static void printMark(Object o) {
+        int[] mark = new int[3];
+        for (int i = 0; i < mark.length; i++) {
+            mark[i] = UNSAFE.getInt(o, i * Integer.BYTES);
+        }
+
+        var hex = Arrays.stream(mark)
+                .boxed()
+                .map(i -> Integer.toHexString(i))
+                .collect(Collectors.joining(", "));
+
+        System.out.println(hex);
+    }
+
+    static final class Foo {
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
index 47e8bf80c50..f022357fc4d 100644
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -3861,6 +3861,24 @@ public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
         }
     }
 
+    /** The offset in the object header to the lock flags */
+    private static final int LOCK_OFFSET = ADDRESS_SIZE == 8 ? 4 : 0;
+
+    /**
+     * {@return {@code true} if the provided Object is locked
+     * by a Thread using {@code synchronized}}.
+     *
+     * @param o Object to check if locked
+     * @see src/hotspot/share/oops/markWord.hpp
+     */
+    @ForceInline
+    public boolean isLocked(Object o) {
+        // 0x03 is the mask for the two lock bits ("lock_mask_in_place" in markWord.hpp)
+        // 0x01 is the value for "unlocked_value" in markWord.hpp
+        // Todo: make this method intrinsic in vmIntrinsics.hpp calling markWord::is_locked
+        return (getIntVolatile(o, LOCK_OFFSET) & 0x03) == 0x01; // ??
+    }
+
     // The following deprecated methods are used by JSR 166.
 
     @Deprecated(since="12", forRemoval=true)

From 00546ec248da76347ae176aa78a6598107a429d4 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Tue, 18 Apr 2023 17:07:12 +0200
Subject: [PATCH 08/16] Refactor

---
 .../util/concurrent/lazy/BaseLazyArray.java   | 153 ++++
 .../concurrent/lazy/BaseLazyReference.java    |  74 ++
 .../util/concurrent/lazy/EmptyLazyArray.java  |  75 ++
 .../concurrent/lazy/EmptyLazyReference.java   |  57 ++
 .../java/util/concurrent/lazy/Lazy.java       | 183 ++--
 .../java/util/concurrent/lazy/LazyArray.java  |  87 ++
 .../util/concurrent/lazy/LazyReference.java   | 347 +-------
 .../concurrent/lazy/LazyReferenceArray.java   | 804 ------------------
 .../java/util/concurrent/lazy/MarkWord.java   |  62 --
 .../util/concurrent/lazy/ObjectLayout.java    |  85 ++
 .../util/concurrent/lazy/package-info.java    |  29 +-
 .../snippet-files/PackageInfoSnippets.java    |  53 +-
 .../lazy/AbstractBaseLazyReference.java       | 155 ++++
 .../util/concurrent/lazy/AbstractMapper.java  |   4 +-
 .../AbstractPreComputedLazyReference.java     |  38 +
 .../util/concurrent/lazy/LazyMapper.java      |   4 -
 .../concurrent/lazy/LazySingleMapper.java     |   4 -
 .../util/concurrent/lazy/LazyUtil.java        |  68 +-
 .../lazy/PreComputedEmptyLazyReference.java   |  24 +
 .../lazy/PreComputedLazyReference.java        |  24 +
 .../lazy/StandardEmptyLazyReference.java      |  31 +
 .../StandardEmptyLazyReferenceBuilder.java    |  29 +
 .../lazy/StandardLazyReference.java           |  34 +
 .../lazy/StandardLazyReferenceBuilder.java    |  35 +
 .../lazy/array/AbstractBaseLazyArray.java     | 392 +++++++++
 .../lazy/array/StandardEmptyLazyArray.java    |  33 +
 .../lazy/array/StandardLazyArray.java         |  39 +
 .../lazy/array/TranslatedEmptyLazyArray.java  |  37 +
 .../lazy/BasicLazyReferenceArrayTest.java     |  17 +-
 .../lazy/BasicLazyReferenceTest.java          |  35 +-
 .../lazy/LazyReferenceArrayMappingTest.java   |  29 +-
 31 files changed, 1661 insertions(+), 1380 deletions(-)
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
 delete mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
 delete mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java
 create mode 100644 src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
 create mode 100644 src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
new file mode 100644
index 00000000000..77f09edde90
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
@@ -0,0 +1,153 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Optional;
+import java.util.concurrent.lazy.Lazy.State;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+/**
+ * Base interface for lazy reference arrays , which are ... // Todo: write more here
+ *
+ * @param <V> The type of the value to be recorded
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public interface BaseLazyArray<V> {
+
+    /**
+     * {@return the length of the array}.
+     */
+    public int length();
+
+    /**
+     * {@return The {@link State } of this Lazy}.
+     * <p>
+     * The value is a snapshot of the current State.
+     * No attempt is made to compute a value if it is not already present.
+     * <p>
+     * If the returned State is either {@link State#PRESENT} or
+     * {@link State#ERROR}, it is guaranteed the state will
+     * never change in the future.
+     * <p>
+     * This method can be used to act on a value if it is present:
+     * {@snippet lang = java:
+     *     if (lazy.state() == State.PRESENT) {
+     *         // perform action on the value
+     *     }
+     *}
+     * @param index to retrieve the State from
+     */
+    public State state(int index);
+
+    /**
+     * {@return the excption thrown by the supplier invoked or
+     * {@link Optional#empty()} if no exception was thrown}.
+     *
+     * @param index to retrieve the exception from
+     */
+    public Optional<Throwable> exception(int index);
+
+    /**
+     * {@return the value at the provided {@code index} if the value is {@link State#PRESENT}
+     * or {@code defaultValue} if the value is {@link State#EMPTY} or {@link State#CONSTRUCTING}}.
+     *
+     * @param index        for which the value shall be obtained.
+     * @param defaultValue to use if no value is present
+     * @throws NoSuchElementException if a provider for the provided {@code index} has previously
+     *                                thrown an exception.
+     */
+    V getOr(int index, V defaultValue);
+
+    /**
+     * Returns an unmodifiable view of the elements in this lazy array
+     * where the empty elements will be replaced with {@code null}.
+     * <p>
+     * If a mapper has previously thrown an exception for an
+     * accessed element at a certain index, accessing that index will result in
+     * a NoSuchElementException being thrown.
+     *
+     * @return a view of the elements
+     */
+    public List<V> asList();
+
+    /**
+     * Returns an unmodifiable view of the elements in this lazy array
+     * where the empty elements will be replaced with the provided {@code defaulValue}.
+     * <p>
+     * If a mapper has previously thrown an exception for an
+     * accessed element at a certain index, accessing that index will result in
+     * a NoSuchElementException being thrown.
+     *
+     * @param defaulValue to use for elements not yet created
+     * @return a view of the elements
+     */
+    public List<V> asList(V defaulValue);
+
+    /**
+     * {@return A Stream with the lazy elements in this lazy array}.
+     * <p>
+     * Upon encountering a state at position {@code index} in the array, the following actions
+     * will be taken:
+     * <ul>
+     *     <li><b>EMPTY</b>
+     *     <p>An Optional.empty() element is selected.</p></li>
+     *     <li><b>CONSTRUCTING</b>
+     *     <p>An Optional.empty() element is selected.</p></li>
+     *     <li><b>PRESENT</b>
+     *     <p>An Optional.ofNullable(lazy.get(index)) element is selected.</p></li>
+     *     <li><b>ERROR</b>
+     *     <p>A NoSuchElementException is thrown.</p></li>
+     * </ul>
+     *
+     */
+    public Stream<Optional<V>> stream();
+
+    /**
+     * {@return A Stream with the lazy elements in this LazyReferenceArray}.
+     * <p>
+     * Upon encountering a state at position {@code index} in the array, the following actions
+     * will be taken:
+     * <ul>
+     *     <li><b>EMPTY</b>
+     *     <p>The provided {@code defaultValue} is selected.</p></li>
+     *     <li><b>CONSTRUCTING</b>
+     *     <p>The provided {@code defaultValue} is selected.</p></li>
+     *     <li><b>PRESENT</b>
+     *     <p>lazy.get(index)) is selected.</p></li>
+     *     <li><b>ERROR</b>
+     *     <p>A NoSuchElementException is thrown.</p></li>
+     * </ul>
+     *
+     * @param defaultValue the default value to use for empty/contructing slots.
+     */
+    public Stream<V> stream(V defaultValue);
+
+    /**
+     * A builder that can be used to configure a lazy array.
+     *
+     * @param <V> the type of the value.
+     * @param <L> the lazy reference array type to build
+     * @param <B> the builder type
+     */
+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+    public interface Builder<V, L extends BaseLazyArray<V>, B extends Builder<V, L, B>> {
+
+        /**
+         * {@return a builder that will use the provided eagerly computed {@code value} when
+         * eventially {@linkplain #build() building} a lazy array reference}.
+         *
+         * @param index to retrieve the State from
+         * @param value to use
+         */
+        B withValue(int index, V value);
+
+        /**
+         * {@return a new lazy reference array with the builder's configured setting}.
+         */
+        L build();
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
new file mode 100644
index 00000000000..5bd63dee7dc
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
@@ -0,0 +1,74 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+
+import java.util.NoSuchElementException;
+import java.util.Optional;
+
+/**
+ * Base interface for lazy references , which are ... // Todo: write more here
+ *
+ * @param <V> The type of the value to be recorded
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public interface BaseLazyReference<V> {
+
+    /**
+     * {@return The {@link Lazy.State } of this Lazy}.
+     * <p>
+     * The value is a snapshot of the current State.
+     * No attempt is made to compute a value if it is not already present.
+     * <p>
+     * If the returned State is either {@link Lazy.State#PRESENT} or
+     * {@link Lazy.State#ERROR}, it is guaranteed the state will
+     * never change in the future.
+     * <p>
+     * This method can be used to act on a value if it is present:
+     * {@snippet lang = java:
+     *     if (lazy.state() == State.PRESENT) {
+     *         // perform action on the value
+     *     }
+     *}
+     */
+    public Lazy.State state();
+
+    /**
+     * {@return the excption thrown by the supplier invoked or
+     * {@link Optional#empty()} if no exception was thrown}.
+     */
+    public Optional<Throwable> exception();
+
+    /**
+     * {@return the value if the value is {@link Lazy.State#PRESENT}
+     * or {@code defaultValue} if the value is {@link Lazy.State#EMPTY} or {@link Lazy.State#CONSTRUCTING}}.
+     *
+     * @param defaultValue to use if no value is present
+     * @throws NoSuchElementException if a provider has previously thrown an exception.
+     */
+    V getOr(V defaultValue);
+
+    /**
+     * A builder that can be used to configure a LazyReference.
+     *
+     * @param <V> the type of the value.
+     * @param <L> the lazy reference type to build
+     * @param <B> the builder type
+     */
+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+    public interface Builder<V, L extends BaseLazyReference<V>, B extends Builder<V, L, B>> {
+
+        /**
+         * {@return a builder that will use the provided eagerly computed {@code value} when
+         * eventially {@linkplain #build() building} a lazy reference}.
+         *
+         * @param value to use
+         */
+        B withValue(V value);
+
+        /**
+         * {@return a new lazy reference with the builder's configured setting}.
+         */
+        L build();
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
new file mode 100644
index 00000000000..539c8a43063
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
@@ -0,0 +1,75 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.function.IntFunction;
+
+/**
+ * An empty lazy references with no pre-set supplier...
+ *
+ * @param <V> The type of the value to be recorded
+ *
+ * @since 22
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public interface EmptyLazyArray<V>
+        extends BaseLazyArray<V> {
+
+    /**
+     * Returns the present value at the provided {@code index} or, if no present value exists,
+     * atomically attempts to compute the value using the <em>provided {@code mappper}</em>.
+     *
+     * <p>If the mapper returns {@code null}, an exception is thrown.
+     * If the provided {@code ,mapper} itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded.  The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    EmptyLazyArray<V> lazy = Lazy.ofEmptyArray(64);
+     *    // ...
+     *    V value = lazy.supplyIfAbsent(42, Value::new);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param index   to the slot to be used
+     * @param mappper to apply if no previous value exists
+     * @return the value (pre-existing or newly computed)
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     * @throws NullPointerException           if the provided {@code mappper} is {@code null}.
+     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
+     *                                        provided {@code index}.
+     */
+    public V computeIfEmpty(int index,
+                            IntFunction<? extends V> mappper);
+
+/*    *//**
+     * A builder that can be used to configure a LazyReference.
+     *
+     * @param <V> the type of the value.
+     *//*
+    public interface Builder<V>
+            extends BaseLazyReference.Builder<V, EmptyLazyArray<V>, EmptyLazyArray.Builder<V>> {
+
+        *//**
+         * {@return a builder that will use the provided {@code earliestEvaluation} when
+         * eventially {@linkplain #build() building} a LazyArray}.
+         * <p>
+         * Any supplier configured with this builder must be referentially transparent
+         * and thus must have no side-effect in order to allow transparent time-shifting of
+         * evaluation.
+         * <p>
+         * No guarantees are made with respect to the latest time of evaluation and
+         * consequently, the value might always be evaliate {@linkplain Lazy.Evaluation#AT_USE at use}.
+         *
+         * @param earliestEvaluation to use.
+         *//*
+        Builder<V> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
+
+    }*/
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
new file mode 100644
index 00000000000..bcb3fc500cd
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
@@ -0,0 +1,57 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+
+import java.util.NoSuchElementException;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * An empty lazy references has no pre-set supplier...
+ *
+ * @param <V> The type of the value to be recorded
+ *
+ * @since 22
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public interface EmptyLazyReference<V>
+        extends BaseLazyReference<V>, Function<Supplier<? extends V>, V> {
+
+    /**
+     * Returns the present value or, if no present value exists, atomically attempts
+     * to compute the value using the <em>provided {@code supplier}</em>.
+     * <p>
+     * If the provided {@code supplier} itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded.  The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    EmptyLazyReference<V> lazy = Lazy.ofEmpty();
+     *    // ...
+     *    V value = lazy.apply(Value::new);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param supplier to apply if no previous value exists
+     * @return the value (pre-existing or newly computed)
+     * @throws NullPointerException   if the provided {@code supplier} is {@code null} or if the provider
+     *                                {@code supplier} returns {@code null}.
+     * @throws NoSuchElementException if a supplier has previously thrown an exception.
+     */
+    @Override
+    public V apply(Supplier<? extends V> supplier);
+
+    /**
+     * A builder that can be used to configure an EmptyLazyReference.
+     *
+     * @param <V> the type of the value.
+     */
+    public interface Builder<V>
+            extends BaseLazyReference.Builder<V, EmptyLazyReference<V>, Builder<V>> {
+
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 72278c64d77..6db9865d0cd 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -3,6 +3,13 @@
 import jdk.internal.javac.PreviewFeature;
 import jdk.internal.util.concurrent.lazy.LazyMapper;
 import jdk.internal.util.concurrent.lazy.LazySingleMapper;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReferenceBuilder;
+import jdk.internal.util.concurrent.lazy.StandardLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardLazyReferenceBuilder;
+import jdk.internal.util.concurrent.lazy.array.StandardEmptyLazyArray;
+import jdk.internal.util.concurrent.lazy.array.StandardLazyArray;
+import jdk.internal.util.concurrent.lazy.array.TranslatedEmptyLazyArray;
 
 import java.util.Collection;
 import java.util.Objects;
@@ -21,7 +28,8 @@
 public final class Lazy {
 
     // Suppresses default constructor, ensuring non-instantiability.
-    private Lazy() {}
+    private Lazy() {
+    }
 
     /**
      * The State indicates the current state of a Lazy instance:
@@ -105,26 +113,23 @@ public enum Evaluation {
     }
 
     /**
-     * {@return a new empty LazyReference with no pre-set supplier}.
-     * <p>
-     * If an attempt is made to invoke the {@link LazyReference#get()} method when no element is present,
-     * an exception will be thrown.
+     * {@return a new EmptyLazyReference with no pre-set supplier}.
      * <p>
      * {@snippet lang = java:
      *     class Fox {
      *
-     *         private final LazyReference<String> lazy = Lazy.ofEmpty();
+     *         private final EmptyLazyReference<String> lazy = Lazy.ofEmpty();
      *
      *         String init(String color) {
-     *             return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+     *             return lazy.apply(() -> "The quick " + color + " fox");
      *         }
      *     }
      *}
      *
-     * @param <T> The type of the value
+     * @param <V> The type of the value
      */
-    public static <T> LazyReference<T> ofEmpty() {
-        return new LazyReference<>(Evaluation.AT_USE, null);
+    public static <V> EmptyLazyReference<V> ofEmpty() {
+        return new StandardEmptyLazyReference<>();
     }
 
     /**
@@ -132,7 +137,7 @@ public static <T> LazyReference<T> ofEmpty() {
      * <p>
      * If an attempt is made to invoke the {@link LazyReference#get()} method when no element is present,
      * the provided {@code presetSupplier} will automatically be invoked as specified by
-     * {@link LazyReference#supplyIfEmpty(Supplier)}.
+     * {@link EmptyLazyReference#apply(Object)}.
      * <p>
      * {@snippet lang = java:
      *     class DemoPreset {
@@ -146,24 +151,47 @@ public static <T> LazyReference<T> ofEmpty() {
      *     }
      *}
      *
-     * @param <T>            The type of the value
+     * @param <V>            The type of the value
      * @param presetSupplier to invoke when lazily constructing a value
      */
-    public static <T> LazyReference<T> of(Supplier<? extends T> presetSupplier) {
+    public static <V> LazyReference<V> of(Supplier<? extends V> presetSupplier) {
         Objects.requireNonNull(presetSupplier);
-        return new LazyReference<>(Evaluation.AT_USE, presetSupplier);
+        return new StandardLazyReference<>(presetSupplier);
+    }
+
+    /**
+     * {@return a builder that can be used to build a custom EmptyLazyReference}.
+     *
+     * @param <V> type of the value the EmptyLazyReference will handle.
+     *            Here is how a lazy value can be pre-computed:
+     *            {@snippet lang = java:
+     *                           class DemoPrecomputed {
+     *
+     *                               private static final EmptyLazyReference<Foo> lazy = Lazy.<Foo>emptyBuilder()
+     *                                       .withValue(new Foo())
+     *                                       .build();
+     *
+     *                               public static void main(String[] args) throws InterruptedException {
+     *                                   // lazy is already pre-computed here
+     *                                   System.out.println("lazy.apply(Foo::new) = " + lazy.apply(Foo::new));
+     *                               }
+     *                           }
+     *}
+     */
+    // Todo: Figure out a better way for determining the type (e.g. type token)
+    public static <V> EmptyLazyReference.Builder<V> emptyBuilder() {
+        return new StandardEmptyLazyReferenceBuilder<>();
     }
 
     /**
      * {@return a builder that can be used to build a custom LazyReference}.
-     * @param <T> type of the value the LazyReference will handle.
+     * <p>
      * Here is how a lazy value can be computed in the background and that may already be computed
      * when first requested from user code:
      * {@snippet lang = java:
      *     class DemoBackground {
      *
-     *         private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
-     *                 .withSupplier(Foo::new)
+     *         private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
      *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
      *                 .build();
      *
@@ -173,25 +201,25 @@ public static <T> LazyReference<T> of(Supplier<? extends T> presetSupplier) {
      *             System.out.println("lazy.get() = " + lazy.get());
      *         }
      *     }
-     * }
+     *}
+     *
+     * @param <V>            type of the value the LazyReference will handle.
+     * @param presetSupplier to use when computing and storing the value
      */
-    // Todo: Figure out a better way for determining the type (e.g. type token)
-    public static <T> LazyReference.Builder<T> builder() {
-        return new LazyReference.LazyReferenceBuilder<>();
+    public static <V> LazyReference.Builder<V> builder(Supplier<? extends V> presetSupplier) {
+        Objects.requireNonNull(presetSupplier);
+        return new StandardLazyReferenceBuilder<>(presetSupplier);
     }
 
     /**
-     * {@return a new empty LazyReferenceArray with no pre-set mapper}.
-     * <p>
-     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} method when no element is present,
-     * an exception will be thrown.
+     * {@return a new EmptyLazyArray with no pre-set mapper}.
      * <p>
+     * Below an example of how an EmptyLazyArray is used as a cache:
      * {@snippet lang = java:
-     * class UserCache {
+     *     class UserCache {
      *
      *         // Cache the first 64 users
-     *         private static final LazyReferenceArray<User> USER_CACHE =
-     *                 Lazy.ofEmptyArray(64);
+     *         private static final EmptyLazyArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
      *
      *         public User user(int id) {
      *             Connection c = getDatabaseConnection();
@@ -200,50 +228,90 @@ public static <T> LazyReference.Builder<T> builder() {
      *     }
      *}
      *
-     * @param <T>  The type of the values
+     * @param <V>  The type of the values
      * @param size the size of the array
      */
-    public static <T> LazyReferenceArray<T> ofEmptyArray(int size) {
+    public static <V> EmptyLazyArray<V> ofEmptyArray(int size) {
         if (size < 0) {
             throw new IllegalArgumentException();
         }
-        return new LazyReferenceArray<>(size);
+        return new StandardEmptyLazyArray<>(size);
     }
 
     /**
-     * {@return a new empty LazyReferenceArray with a pre-set mapper}.
-     * <p>
-     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} ()} method when no element is present,
-     * the provided {@code presetMapper} will automatically be invoked as specified by
-     * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
+     * {@return a new EmptyLazyArray with a pre-set mapper}.
      * <p>
+     * Below, an example of how to cache values in an array is shown:
      * {@snippet lang = java:
-     *     class DemoArray {
+     * class DemoArray {
      *
-     *         private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
-     *                 Lazy.ofArray(32, index -> new Value(1L << index));
+     * private static final LazyArray<Value> VALUE_PO2_CACHE =
+     * Lazy.ofArray(32, index -> new Value(1L << index));
      *
-     *         public Value powerOfTwoValue(int n) {
-     *             if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
-     *                 throw new IllegalArgumentException(Integer.toString(n));
-     *             }
+     * public Value powerOfTwoValue(int n) {
+     * if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
+     * throw new IllegalArgumentException(Integer.toString(n));
+     * }
      *
-     *             return VALUE_PO2_CACHE.apply(n);
-     *         }
-     *     }
+     * return VALUE_PO2_CACHE.apply(n);
+     * }
      * }
+     *}
      *
-     * @param <T>          The type of the values
+     * @param <V>          The type of the values
      * @param size         the size of the array
      * @param presetMapper to invoke when lazily constructing a value
      */
-    public static <T> LazyReferenceArray<T> ofArray(int size,
-                                                    IntFunction<? extends T> presetMapper) {
+    public static <V> LazyArray<V> ofArray(int size,
+                                           IntFunction<? extends V> presetMapper) {
         if (size < 0) {
             throw new IllegalArgumentException();
         }
         Objects.requireNonNull(presetMapper);
-        return new LazyReferenceArray<>(size, presetMapper);
+        return new StandardLazyArray<>(size, presetMapper);
+    }
+
+    /**
+     * {@return a new EmptyLazyArray with no pre-set mapper and with the index translated
+     * by the provided {@code translation}}.
+     * <p>
+     * Translated lazy arrays are useful for caching certain values as shown in the example below:
+     * <p>
+     * {@snippet lang = java:
+     *     class DemoFibMapped {
+     *
+     *          static int fib(int n) {
+     *             return (n <= 1)
+     *                     ? n
+     *                     : fib(n - 1) + fib(n - 2);
+     *         }
+     *
+     *         private static final EmptyLazyArray<Integer> FIB_10_CACHE =
+     *                 Lazy.ofEmptyTranslatedArray(3, 10);
+     *
+     *         // Only works for values up to ~30
+     *
+     *         static int cachedFib(int n) {
+     *             if (n <= 1)
+     *                 return n;
+     *             return FIB_10_CACHE.computeIfEmpty(n, DemoFibMapped::fib);
+     *         }
+     *     }
+     *}
+     *
+     * @param <V>         The type of the values
+     * @param size        the size of the array
+     * @param translation the translation factor to use
+     */
+    public static <V> EmptyLazyArray<V> ofEmptyTranslatedArray(int size,
+                                                               int translation) {
+        if (size < 0 || translation < 0) {
+            throw new IllegalArgumentException();
+        }
+        if ((long) size * translation > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("Out of int range.");
+        }
+        return new TranslatedEmptyLazyArray<>(size, translation);
     }
 
     /**
@@ -251,10 +319,7 @@ public static <T> LazyReferenceArray<T> ofArray(int size,
      * lazily computed and recorded by the provided {@code mapper} or {@linkplain Optional#empty() Optional.empty()}
      * if a key that is not part of the provided collection of {@code keys} is provided to the returned Function}.
      * <p>
-     * If an attempt is made to invoke the {@link LazyReferenceArray#apply(int)} ()} method when no element is present,
-     * the provided {@code presetMapper} will automatically be invoked as specified by
-     * {@link LazyReferenceArray#computeIfEmpty(int, IntFunction)}.
-     * <p>
+     * Here is an example of how to construct a cache for three pre-known strings:
      * {@snippet lang = java:
      *     class DemoLazyMapper {
      *
@@ -268,9 +333,9 @@ public static <T> LazyReferenceArray<T> ofArray(int size,
      *     }
      *}
      *
-     * @param <K> the type of keys maintained by this mapper
-     * @param <V> the type of mapped values
-     * @param keys to be mapped
+     * @param <K>    the type of keys maintained by this mapper
+     * @param <V>    the type of mapped values
+     * @param keys   to be mapped
      * @param mapper to apply when computing and recording values
      */
     public static <K, V> Function<K, Optional<V>> mapping(Collection<K> keys,
@@ -310,8 +375,8 @@ public static <K, V> Function<K, Optional<V>> mapping(Collection<K> keys,
      *     }
      *}
      *
-     * @param <K> the type of keys maintained by this mapper
-     * @param <V> the type of mapped values
+     * @param <K>        the type of keys maintained by this mapper
+     * @param <V>        the type of mapped values
      * @param keyMappers to be lazily evaluated and recorded
      */
     public static <K, V> Function<K, Optional<V>> mapping(Collection<KeyMapper<K, V>> keyMappers) {
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
new file mode 100644
index 00000000000..2cb306a9c80
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
@@ -0,0 +1,87 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.javac.PreviewFeature;
+
+import java.util.NoSuchElementException;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+
+/**
+ * A lazy references with a pre-set supplier...
+ *
+ * @param <V> The type of the value to be recorded
+ *
+ * @since 22
+ */
+@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
+public interface LazyArray<V>
+        extends BaseLazyArray<V>, IntFunction<V> {
+
+    /**
+     * Returns the present value at the provided {@code index} or, if no present value exists,
+     * atomically attempts to compute the value using the <em>pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper}</em>.
+     * If no pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper} exists,
+     * throws an IllegalStateException exception.
+     * <p>
+     * If the pre-set mapper itself throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. The most
+     * common usage is to construct a new object serving as a memoized result, as in:
+     * <p>
+     * {@snippet lang = java:
+     *    LazyArray<V> lazy = Lazy.ofArray(64, Value::new);
+     *    // ...
+     *    V value = lazy.apply(42);
+     *    assertNotNull(value); // Value is non-null
+     *}
+     * <p>
+     * If another thread attempts to compute the value, the current thread will be suspended until
+     * the atempt completes (successfully or not).
+     *
+     * @param index to the slot to be used
+     * @return the value (pre-existing or newly computed)
+     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
+     *                                        or {@code index >= length()}
+     * @throws IllegalStateException          if a value was not already present and no
+     *                                        pre-set mapper was specified.
+     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
+     *                                        provided {@code index}.
+     */
+    @Override
+    public V apply(int index);
+
+    /**
+     * Forces computation of all {@link java.util.concurrent.lazy.Lazy.State#EMPTY} slots in
+     * slot order.
+     * <p>
+     * If the pre-set mapper throws an (unchecked) exception, the
+     * exception is rethrown, and no value is recorded. This means, subsequent slots
+     * are not computed.
+     *
+     */
+    public void force();
+
+    /**
+     * A builder that can be used to configure a lazy array.
+     *
+     * @param <V> the type of the value.
+     */
+    public interface Builder<V>
+            extends BaseLazyArray.Builder<V, LazyArray<V>, LazyArray.Builder<V>> {
+
+        /**
+         * {@return a builder that will use the provided {@code earliestEvaluation} when
+         * eventially {@linkplain #build() building} a LazyArray}.
+         * <p>
+         * Any supplier configured with this builder must be referentially transparent
+         * and thus must have no side-effect in order to allow transparent time-shifting of
+         * evaluation.
+         * <p>
+         * No guarantees are made with respect to the latest time of evaluation and
+         * consequently, the value might always be evaliate {@linkplain Lazy.Evaluation#AT_USE at use}.
+         *
+         * @param earliestEvaluation to use.
+         */
+        Builder<V> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
+
+    }
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index e779c5eb9e6..23dcfe00ada 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -1,173 +1,24 @@
-/*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
-import jdk.internal.misc.Unsafe;
-import jdk.internal.util.concurrent.lazy.LazyUtil;
-import jdk.internal.vm.annotation.Stable;
 
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.VarHandle;
 import java.util.NoSuchElementException;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
-import static jdk.internal.util.concurrent.lazy.LazyUtil.varHandle;
-
 /**
- * An object reference in which the value can be lazily and atomically computed.
- * <p>
- * At most one invocation is made of any provided set of suppliers.
- * <p>
- * This contrasts to {@link AtomicReference } where any number of updates can be done
- * and where there is no simple way to atomically compute
- * a value (guaranteed to only be computed once) if missing.
- * <p>
- * The implementation is optimized for the case where there are N invocations
- * trying to obtain the value and where N >> 1, for example where N is > 2<sup>20</sup>.
- * <p>
- * A supplier may return {@code null} which then will be perpetually recorded as the value.
- * <p>
- * This class is thread-safe.
- * <p>
- * The JVM may apply certain optimizations as it knows the value is updated just once
- * at most as described by {@link Stable} as exemplified here:
- * {@snippet lang = java:
- *     private static final LazyReference<Value> MY_LAZY_VALUE = Lazy.of(Value::new);
- *     // ...
- *     public Value value() {
- *         // This will likely be constant-folded by the JIT C2 compiler.
- *         return MY_LAZY_VALUE.get();
- *     }
- *}
+ * A lazy references with a pre-set supplier...
  *
  * @param <V> The type of the value to be recorded
+ *
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public final class LazyReference<V>
-        implements Supplier<V> {
-
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
-
-    // Allows access to the "value" field with arbitary memory semantics
-    private static final VarHandle VALUE_HANDLE;
-
-    static {
-        try {
-            VALUE_HANDLE = MethodHandles.lookup()
-                    .findVarHandle(LazyReference.class, "value", Object.class);
-            // .withInvokeExactBehavior(); // Make sure no boxing is made?
-        } catch (ReflectiveOperationException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
-
-    private final Lazy.Evaluation earliestEvaluation;
-
-    private Supplier<? extends V> presetProvider;
-
-    @Stable
-    private Object value;
-
-    LazyReference(Lazy.Evaluation earliestEvaluation,
-                  Supplier<? extends V> presetSupplier) {
-        this.earliestEvaluation = earliestEvaluation;
-        this.presetProvider = presetSupplier;
-        if (earliestEvaluation != Lazy.Evaluation.AT_USE && presetSupplier != null) {
-            // Start computing the value via a background Thread.
-            Thread.ofVirtual()
-                    .name("Lazy evaluator: " + presetSupplier)
-                    .start(() -> supplyIfEmpty0(presetSupplier));
-        }
-    }
-
-    // To be called by builders/compilers/destillers to eagerly pre-compute a value (e.g. Constable)
-    LazyReference(V value) {
-        this.earliestEvaluation = Lazy.Evaluation.CREATION;
-        this.presetProvider = null;
-        this.value = Objects.requireNonNull(value);
-    }
-
-    /**
-     * {@return The {@link Lazy.State } of this Lazy}.
-     * <p>
-     * The value is a snapshot of the current State.
-     * No attempt is made to compute a value if it is not already present.
-     * <p>
-     * If the returned State is either {@link Lazy.State#PRESENT} or
-     * {@link Lazy.State#ERROR}, it is guaranteed the state will
-     * never change in the future.
-     * <p>
-     * This method can be used to act on a value if it is present:
-     * {@snippet lang = java:
-     *     if (lazy.state() == State.PRESENT) {
-     *         T value = lazy.get();
-     *         // perform action on the value
-     *     }
-     *}
-     */
-    public Lazy.State state() {
-        // Try normal memory semantics first
-        Object o = value;
-        if (o != null) {
-            return o instanceof Exception
-                    ? Lazy.State.ERROR
-                    : Lazy.State.PRESENT;
-        }
-
-        if (UNSAFE.isLocked(this)) {
-            return Lazy.State.CONSTRUCTING;
-        }
-
-        // Use volatile semantics
-        o = VALUE_HANDLE.getVolatile(this);
-        if (o instanceof Exception) {
-            return Lazy.State.ERROR;
-        }
-        if (o == null) {
-            return Lazy.State.EMPTY;
-        }
-        return Lazy.State.PRESENT;
-    }
-
-    /**
-     * {@return The erliest point at which this Lazy can be evaluated}.
-     */
-    Lazy.Evaluation earliestEvaluation() {
-        return earliestEvaluation;
-    }
+public interface LazyReference<V>
+        extends BaseLazyReference<V>, Supplier<V> {
 
     /**
      * Returns the present value or, if no present value exists, atomically attempts
      * to compute the value using the <em>pre-set {@linkplain Lazy#of(Supplier)} supplier}</em>.
-     * If no pre-set {@linkplain Lazy#of(Supplier)} supplier} exists,
-     * throws an IllegalStateException exception.
      * <p>
      * If the pre-set supplier itself throws an (unchecked) exception, the
      * exception is rethrown, and no value is recorded. The most
@@ -190,126 +41,16 @@ Lazy.Evaluation earliestEvaluation() {
      * @throws NoSuchElementException if a supplier has previously thrown an exception.
      */
     @SuppressWarnings("unchecked")
-    public V get() {
-        try {
-            V v = (V) value;
-            if (v != null) {
-                return v;
-            }
-            return supplyIfEmpty0(presetProvider);
-        } catch (ClassCastException cce) {
-            throw new NoSuchElementException((Throwable) value);
-        }
-    }
-
-    /**
-     * Returns the present value or, if no present value exists, atomically attempts
-     * to compute the value using the <em>provided {@code supplier}</em>.
-     * <p>
-     * If the provided {@code supplier} itself throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded.  The most
-     * common usage is to construct a new object serving as a memoized result, as in:
-     * <p>
-     * {@snippet lang = java:
-     *    LazyReference<V> lazy = Lazy.ofEmpty();
-     *    // ...
-     *    V value = lazy.supplyIfAbsent(Value::new);
-     *    assertNotNull(value); // Value is non-null
-     *}
-     * <p>
-     * If another thread attempts to compute the value, the current thread will be suspended until
-     * the atempt completes (successfully or not).
-     *
-     * @param supplier to apply if no previous value exists
-     * @return the value (pre-existing or newly computed)
-     * @throws NullPointerException   if the provided {@code supplier} is {@code null} or if the provider
-     *                                {@code supplier} returns {@code null}.
-     * @throws NoSuchElementException if a supplier has previously thrown an exception.
-     */
-    public V supplyIfEmpty(Supplier<? extends V> supplier) {
-        Objects.requireNonNull(supplier);
-        return supplyIfEmpty0(supplier);
-    }
-
-    /**
-     * {@return the excption thrown by the supplier invoked or
-     * {@link Optional#empty()} if no exception was thrown}.
-     */
-    public Optional<Throwable> exception() {
-        return state() == Lazy.State.ERROR
-                ? Optional.of((Throwable) value)
-                : Optional.empty();
-    }
-
-    private V supplyIfEmpty0(Supplier<? extends V> supplier) {
-        Object o = value;
-        if (o != null) {
-            return castOrThrow(o);
-        }
-
-        // implies volatile semantics when entering/leaving the monitor
-        synchronized (this) {
-            // Here, visibility is guaranteed
-            o = value;
-            if (o != null) {
-                return castOrThrow(o);
-            }
-            if (supplier == null) {
-                throw new IllegalStateException("No pre-set supplier given");
-            }
-            try {
-                V v = supplier.get();
-                if (v == null) {
-                    throw new NullPointerException("Supplier returned null");
-                }
-                VALUE_HANDLE.setVolatile(this, v);
-                return v;
-            } catch (Throwable e) {
-                // Record the throwable instead of the value.
-                VALUE_HANDLE.setVolatile(this, e);
-                // Rethrow
-                throw e;
-            } finally {
-                // Volatile semantics
-                forgetPresetProvided();
-            }
-        }
-    }
-
     @Override
-    public final String toString() {
-        return getClass().getSimpleName() + "[" + switch (state()) {
-            case EMPTY -> Lazy.State.EMPTY;
-            case CONSTRUCTING -> Lazy.State.CONSTRUCTING;
-            case PRESENT -> Objects.toString(value);
-            case ERROR -> Lazy.State.ERROR + " [" + value + "]";
-        } + "]";
-    }
-
-    // Todo: Consider adding checked exception constructior. E.g. Cache value from an SQL query (Check with Ron)
-    // Todo: Consider adding a lazy that shields a POJO
+    public V get();
 
     /**
      * A builder that can be used to configure a LazyReference.
      *
-     * @param <T> the type of the value.
+     * @param <V> the type of the value.
      */
-    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-    public interface Builder<T> {
-
-        /**
-         * {@return a builder that will use the provided {@code supplier} when
-         * eventially {@linkplain #build() building} a LazyReference}.
-         *
-         * @param supplier to use
-         */
-        Builder<T> withSupplier(Supplier<? extends T> supplier);
-
-        /**
-         * {@return a builder that will have no {@code supplier} when
-         * eventially {@linkplain #build() building} a LazyReference}.
-         */
-        Builder<T> withoutSuplier();
+    public interface Builder<V>
+            extends BaseLazyReference.Builder<V, LazyReference<V>, LazyReference.Builder<V>> {
 
         /**
          * {@return a builder that will use the provided {@code earliestEvaluation} when
@@ -324,77 +65,7 @@ public final String toString() {
          *
          * @param earliestEvaluation to use.
          */
-        Builder<T> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
+        Builder<V> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation);
 
-        /**
-         * {@return a builder that will use the provided eagerly computed {@code value} when
-         * eventially {@linkplain #build() building} a LazyReference}.
-         *
-         * @param value to use
-         */
-        Builder<T> withValue(T value);
-
-        /**
-         * {@return a new LazyReference with the builder's configured setting}.
-         */
-        LazyReference<T> build();
     }
-
-    record LazyReferenceBuilder<T>(Lazy.Evaluation binding,
-                                   Supplier<? extends T> supplier,
-                                   boolean hasValue,
-                                   T value) implements Builder<T> {
-
-        LazyReferenceBuilder() {
-            this(null);
-        }
-
-        LazyReferenceBuilder(Supplier<? extends T> supplier) {
-            this(Lazy.Evaluation.AT_USE, supplier, false, null);
-        }
-
-        @Override
-        public Builder<T> withEarliestEvaluation(Lazy.Evaluation earliestEvaluation) {
-            return new LazyReferenceBuilder<>(Objects.requireNonNull(earliestEvaluation), supplier, hasValue, value);
-        }
-
-        @Override
-        public Builder<T> withSupplier(Supplier<? extends T> supplier) {
-            return new LazyReferenceBuilder<>(binding, Objects.requireNonNull(supplier), hasValue, value);
-        }
-
-        @Override
-        public Builder<T> withoutSuplier() {
-            return new LazyReferenceBuilder<>(binding, null, hasValue, value);
-        }
-
-        @Override
-        public Builder<T> withValue(T value) {
-            return new LazyReferenceBuilder<>(binding, supplier, true, value);
-        }
-
-        @Override
-        public LazyReference<T> build() {
-            return hasValue
-                    ? new LazyReference<>(value)
-                    : new LazyReference<>(binding, supplier);
-        }
-    }
-
-    // Private support methods
-
-    @SuppressWarnings("unchecked")
-    private V castOrThrow(Object o) {
-        if (o instanceof Throwable throwable) {
-            throw new NoSuchElementException(throwable);
-        }
-        return (V) o;
-    }
-
-    private void forgetPresetProvided() {
-        // Stops preventing the provider from being collected once it has been
-        // used (if initially set).
-        this.presetProvider = null;
-    }
-
 }
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
deleted file mode 100644
index 4b3fb0a9735..00000000000
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReferenceArray.java
+++ /dev/null
@@ -1,804 +0,0 @@
-/*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package java.util.concurrent.lazy;
-
-import jdk.internal.javac.PreviewFeature;
-import jdk.internal.vm.annotation.Stable;
-
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.IntFunction;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import java.util.stream.Stream;
-
-/**
- * An object reference array in which the values are lazily and atomically computed.
- * <p>
- * At most one invocation is made of any provided set of mapper per slot.
- * <p>
- * This contrasts to {@link java.util.concurrent.atomic.AtomicReferenceArray } where any number of updates can be done
- * and where there is no simple way to atomically compute
- * a value (guaranteed to only be computed once) if missing.
- * <p>
- * The implementation is optimized for the case where there are N invocations
- * trying to obtain a slot value and where N >> 1, for example where N is > 2<sup>20</sup>.
- * <p>
- * This class is thread-safe.
- * <p>
- * The JVM may apply certain optimizations as it knows the value is updated just once
- * at most as described by {@link Stable}.
- *
- * @param <V> The type of the values to be recorded
- * @since 22
- */
-@PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public final class LazyReferenceArray<V> implements IntFunction<V> {
-
-    private static int hi = 0;
-
-    private final IntFunction<? extends V> presetMapper;
-
-    @Stable
-    private final LazyReference<V>[] lazyReferences;
-
-    private final LazyReference<ListView> listView = Lazy.of(() -> new ListView(null));
-
-    // Todo: use an array of V and a bit-set (3 bits per element or perhaps an entire int)
-    // Todo: Bit CAS granularity. Perhaps int[] or several arrays (@Stable and non-@Stable)
-
-    @SuppressWarnings("unchecked")
-    LazyReferenceArray(int size,
-                       IntFunction<? extends V> presetMapper) {
-        lazyReferences = IntStream.range(0, size)
-                .mapToObj(i -> Lazy.<V>of(toSupplier(i, presetMapper)))
-                .toArray(LazyReference[]::new);
-        this.presetMapper = presetMapper;
-    }
-
-    @SuppressWarnings("unchecked")
-    LazyReferenceArray(int size) {
-        lazyReferences = IntStream.range(0, size)
-                .mapToObj(i -> Lazy.<V>ofEmpty())
-                .toArray(LazyReference[]::new);
-        this.presetMapper = null;
-    }
-
-    /**
-     * {@return the length of the array}.
-     */
-    public int length() {
-        return lazyReferences.length;
-    }
-
-    /**
-     * Returns the present value at the provided {@code index} or, if no present value exists,
-     * atomically attempts to compute the value using the <em>pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper}</em>.
-     * If no pre-set {@linkplain Lazy#ofArray(int, IntFunction) mapper} exists,
-     * throws an IllegalStateException exception.
-     * <p>
-     * If the pre-set mapper itself throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded. The most
-     * common usage is to construct a new object serving as a memoized result, as in:
-     * <p>
-     * {@snippet lang = java:
-     *    LazyReferenceArray<V> lazy = Lazy.ofArray(64, Value::new);
-     *    // ...
-     *    V value = lazy.apply(42);
-     *    assertNotNull(value); // Value is non-null
-     *}
-     * <p>
-     * If another thread attempts to compute the value, the current thread will be suspended until
-     * the atempt completes (successfully or not).
-     *
-     * @param index to the slot to be used
-     * @return the value (pre-existing or newly computed)
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
-     * @throws IllegalStateException          if a value was not already present and no
-     *                                        pre-set mapper was specified.
-     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
-     *                                        provided {@code index}.
-     */
-    @Override
-    public V apply(int index) {
-        return lazyReferences[index]
-                .get();
-    }
-
-    /**
-     * {@return if a value is present at the provided {@code index}}.
-     * <p>
-     * No attempt is made to compute a value if it is not already present.
-     * <p>
-     * This method can be used to act on a value if it is present:
-     * {@snippet lang = java:
-     *     if (lazy.isPresent(index)) {
-     *         V value = lazy.get(index);
-     *         // perform action on the value
-     *     }
-     *}
-     *
-     * @param index to the slot to be used
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
-     */
-    public Lazy.State state(int index) {
-        return lazyReferences[index]
-                .state();
-    }
-
-    /**
-     * Returns the present value at the provided {@code index} or, if no present value exists,
-     * atomically attempts to compute the value using the <em>provided {@code mappper}</em>.
-     *
-     * <p>If the mapper returns {@code null}, an exception is thrown.
-     * If the provided {@code ,mapper} itself throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded.  The most
-     * common usage is to construct a new object serving as a memoized result, as in:
-     * <p>
-     * {@snippet lang = java:
-     *    LazyReference<V> lazy = LazyReferenceArray.ofEmpty();
-     *    // ...
-     *    V value = lazy.supplyIfAbsent(42, Value::new);
-     *    assertNotNull(value); // Value is non-null
-     *}
-     * <p>
-     * If another thread attempts to compute the value, the current thread will be suspended until
-     * the atempt completes (successfully or not).
-     *
-     * @param index   to the slot to be used
-     * @param mappper to apply if no previous value exists
-     * @return the value (pre-existing or newly computed)
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
-     * @throws NullPointerException           if the provided {@code mappper} is {@code null}.
-     * @throws NoSuchElementException         if a maper has previously thrown an exception for the
-     *                                        provided {@code index}.
-     */
-    public V computeIfEmpty(int index,
-                            IntFunction<? extends V> mappper) {
-        Objects.requireNonNull(mappper);
-        return lazyReferences[index]
-                .supplyIfEmpty(
-                        toSupplier(index, mappper));
-    }
-
-    /**
-     * {@return the excption thrown by the mapper invoked at the provided
-     * {@code index} or {@link Optional#empty()} if no exception was thrown}.
-     *
-     * @param index to the slot to be accessed
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
-     */
-    public Optional<Throwable> exception(int index) {
-        return lazyReferences[index]
-                .exception();
-    }
-
-    /**
-     * Returns an unmodifiable view of the elements in this LazyReferenceArray
-     * where the empty elements will be replaced with {@code null}.
-     * <p>
-     * If a mapper has previously thrown an exception for an
-     * accessed element at a certain index, accessing that index will result in
-     * a NoSuchElementException being thrown.
-     *
-     * @return a view of the elements
-     */
-    public List<V> asList() {
-        return listView.get();
-    }
-
-    /**
-     * Returns an unmodifiable view of the elements in this LazyReferenceArray
-     * where the empty elements will be replaced with the provided {@code defaulValue}.
-     * <p>
-     * If a mapper has previously thrown an exception for an
-     * accessed element at a certain index, accessing that index will result in
-     * a NoSuchElementException being thrown.
-     *
-     * @param defaulValue to use for elements not yet created
-     * @return a view of the elements
-     */
-    public List<V> asList(V defaulValue) {
-        return new ListView(defaulValue);
-    }
-
-    /**
-     * {@return A Stream with the lazy elements in this LazyReferenceArray}.
-     * <p>
-     * Upon encountering a state at position {@code index} in the array, the following actions
-     * will be taken:
-     * <ul>
-     *     <li><b>EMPTY</b>
-     *     <p>An Optional.empty() element is selected.</p></li>
-     *     <li><b>CONSTRUCTING</b>
-     *     <p>An Optional.empty() element is selected.</p></li>
-     *     <li><b>PRESENT</b>
-     *     <p>An Optional.ofNullable(lazy.get(index)) element is selected.</p></li>
-     *     <li><b>ERROR</b>
-     *     <p>A NoSuchElementException is thrown.</p></li>
-     * </ul>
-     *
-     * @throws NoSuchElementException if a slot is in state ERROR and is being accessed.
-     */
-    public Stream<Optional<V>> stream() {
-        return IntStream.range(0, length())
-                .mapToObj(i -> {
-                    var lazy = lazyReferences[i];
-                    return switch (lazy.state()) {
-                        case EMPTY, CONSTRUCTING -> Optional.empty();
-                        case PRESENT -> Optional.ofNullable(lazy.get());
-                        case ERROR -> throw new NoSuchElementException("At index: " + i);
-                    };
-                });
-    }
-
-    /**
-     * {@return A Stream with the lazy elements in this LazyReferenceArray}.
-     * <p>
-     * Upon encountering a state at position {@code index} in the array, the following actions
-     * will be taken:
-     * <ul>
-     *     <li><b>EMPTY</b>
-     *     <p>The provided {@code defaultValue} is selected.</p></li>
-     *     <li><b>CONSTRUCTING</b>
-     *     <p>The provided {@code defaultValue} is selected.</p></li>
-     *     <li><b>PRESENT</b>
-     *     <p>lazy.get(index)) is selected.</p></li>
-     *     <li><b>ERROR</b>
-     *     <p>A NoSuchElementException is thrown.</p></li>
-     * </ul>
-     *
-     * @param defaultValue the default value to use for empty/contructing slots.
-     * @throws NoSuchElementException if a slot is in state ERROR and is being accessed.
-     */
-    public Stream<V> stream(V defaultValue) {
-        return IntStream.range(0, length())
-                .mapToObj(i -> {
-                    var lazy = lazyReferences[i];
-                    return switch (lazy.state()) {
-                        case EMPTY, CONSTRUCTING -> defaultValue;
-                        case PRESENT -> lazy.get();
-                        case ERROR -> throw new NoSuchElementException("At index: " + i);
-                    };
-                });
-    }
-
-    /**
-     * Forces computation of all {@link java.util.concurrent.lazy.Lazy.State#EMPTY} slots in
-     * slot order.
-     * <p>
-     * If the pre-set mapper throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded. This means, subsequent slots
-     * are not computed.
-     *
-     * @throws IllegalStateException if no pre-set mapper was specified.
-     */
-    public void force() {
-        if (presetMapper == null) {
-            throw new IllegalStateException();
-        }
-        for (LazyReference<V> lazy : lazyReferences) {
-            lazy.get();
-        }
-    }
-
-    /**
-     * Returns the lazy value associated with the provided {@code key} via the provided
-     * {@code intKeyMapper}, or, if the key is not {@linkplain IntKeyMapper#isMappable(int) mappable}, applies
-     * the provided {@code unmappableHandler} using the provided {@code key}.
-     * <p>
-     * If the underlying lazy pre-set mapper throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded. If the provided {@code unmappableHandler}
-     * throws an (unchecked) exception, the exeption is rethrown.
-     * The most common usage is to construct a new object serving as a cached result, as in:
-     * <p>
-     * {@snippet lang = java:
-     *    private static IntKeyMapper KEY_MAPPER = IntKeyMapper.ofConstant(8);
-     *    LazyReferenceArray<Long> cache = LazyReferenceArray.of(8);
-     *    // ...
-     *
-     *    Long value = cache.mapAndApply(KEY_MAPPER, 16, n -> (1L << n), n -> 0);
-     *    assertEquals(65536, value); // Value is mappable and entered into and taken from the cache
-     *
-     *    Long value2 = cache.mapAndApply(KEY_MAPPER, 15, n -> (1L << n), n -> 0);
-     *    assertEquals(0, value2); // Value is not mappable and will be obtained from the provided lambda
-     *}
-     * <p>
-     * If another thread attempts to compute a lazy value, the current thread will be suspended until
-     * the atempt completes (successfully or not).
-     *
-     * @param intKeyMapper      to use when mapping a key
-     * @param key               to map to an index
-     * @param mappableHandler   to apply if the key {@linkplain IntKeyMapper#isMappable(int) is mappable}
-     * @param unmappableHandler to apply if the key {@linkplain IntKeyMapper#isMappable(int) is NOT mappable}
-     * @return a lazy value (pre-existing or newly computed) or another value from the provided {@code unmappableHandler}.
-     * @throws IllegalStateException  if a value was not already present and no
-     *                                pre-set mapper was specified.
-     * @throws NoSuchElementException if a lazy maper has previously thrown an exception for the
-     *                                provided key mapping to an associated {@code index}.
-     */
-    public V mapIntAndApply(IntKeyMapper intKeyMapper,
-                            int key,
-                            IntFunction<? extends V> mappableHandler,
-                            IntFunction<? extends V> unmappableHandler) {
-        int index = intKeyMapper.keyToIndex(key);
-        return (index >= 0 && index < lazyReferences.length)
-                ? lazyReferences[index]
-                .supplyIfEmpty(() -> mappableHandler.apply(key))
-                : unmappableHandler.apply(key);
-    }
-
-    @Override
-    public String toString() {
-        return IntStream.range(0, length())
-                .mapToObj(i -> lazyReferences[i])
-                .map(lazy -> switch (lazy.state()) {
-                    case EMPTY -> "-";
-                    case CONSTRUCTING -> "+";
-                    case PRESENT -> Objects.toString(lazy.get());
-                    case ERROR -> "!";
-                })
-                .collect(Collectors.joining(", ", "LazyReferenceArray[", "]"));
-    }
-
-    // Todo: Add supplyIfEmpty()?
-
-    Supplier<V> toSupplier(int index,
-                           IntFunction<? extends V> mappper) {
-        return () -> mappper.apply(index);
-    }
-
-    V getOr(int index, V defaultValue) {
-        var lazy = lazyReferences[index];
-        var state = lazy.state();
-        return switch (state) {
-            case EMPTY, CONSTRUCTING -> defaultValue;
-            case PRESENT -> lazy.get();
-            case ERROR -> throw new NoSuchElementException();
-        };
-    }
-
-    /**
-     * A key mapper than can convert between external "keys" and internal indices. The mapper
-     * is said to perform <em>inversly replicable conversions</em> meaning for a KeyMapper
-     * {@code km} used by a LazyReferenceArray {@code lra}:
-     * <ul>
-     *     <li>
-     *     The following holds: {@code km.isApplicable(lra.length))}.
-     *     </li>
-     *     <li>
-     *      For any external value {@code key} for which the mapper {@linkplain IntKeyMapper#isMappable(int)} (int) is convertible},
-     *       the following holds: {@code
-     *           fromIndex(toIndex(key)) = key
-     *       }
-     *     </li>
-     *     <li>
-     *      For any external value {@code key} for which the mapper {@linkplain IntKeyMapper#isMappable(int) is NOT convertibla},
-     *      the following will throw an ArrayOutOfBounds: {@code
-     *           lra.get(toindex(e));
-     *       }
-     *     </li>
-     * </ul>
-     * <p>
-     * Hence, the mapper is not guaranteed to always produce valid mappings but is guaranteed to provide
-     * consistent results when applied to a LazyReferenceArray.
-     * <p>
-     * The mapper is useful when using a LazyReferenceArray as a cache in cases there is not
-     * a one-to-one mapping between the keys used for caching and the actual indices in the
-     * arrary.
-     *
-     * @see LazyReferenceArray#mapIntAndApply(IntKeyMapper, int, IntFunction, IntFunction)
-     */
-    @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-    public interface IntKeyMapper {
-        /**
-         * {@return an index of the LazyReferenceArray by converting the
-         * provided {@code key} or, an invalid index
-         * if no such conversion can be made}.
-         *
-         * @param key to convert to an index
-         */
-        int keyToIndex(int key);
-
-        /**
-         * {@return if the provided {@code key} can be
-         * mapped to an index}.
-         *
-         * @param key to test
-         */
-        boolean isMappable(int key);
-
-        /**
-         * {@return the required array length, or if no such array length exists
-         * {@link OptionalInt#empty()}}.
-         */
-        OptionalInt requiredLength();
-
-        /**
-         * {@return if this KeyMapper can be used on an array with the
-         * provided {@code arrayLength}}.
-         *
-         * @param arrayLength to test
-         */
-        boolean checkArrayLength(int arrayLength);
-
-        /**
-         * {@return an index mapper that will map external values to
-         * indices by dividing with the provided {@code constant}}.
-         *
-         * @param constant used as a divisor when converting external values to indices.
-         * @throws IllegalArgumentException if the provided {@code constant} is zero.
-         */
-        public static IntKeyMapper ofConstant(int constant) {
-            if (constant == 0) {
-                throw new IllegalArgumentException("The constant must be non-zero");
-            }
-            return new IntKeyMapper() {
-                @Override
-                public int keyToIndex(int key) {
-                    if (!isMappable(key)) {
-                        return -1;
-                    }
-                    return key / constant;
-                }
-
-                @Override
-                public boolean isMappable(int key) {
-                    return key % constant == 0;
-                }
-
-                @Override
-                public boolean checkArrayLength(int arrayLength) {
-                    // Todo: Use the maximum array size which is smaller than Integer.MAX_VALUE
-                    return (long) arrayLength * (long) constant < Integer.MAX_VALUE;
-                }
-
-                @Override
-                public OptionalInt requiredLength() {
-                    return OptionalInt.empty();
-                }
-
-                @Override
-                public String toString() {
-                    return "IndexMapper.ofConstant(" + constant + ")";
-                }
-            };
-        }
-
-
-        /**
-         * {@return a index mapper that is a one-to-one mapper where the
-         * external values will be the same as the internal indices}.
-         */
-        // Todo: remove this
-        public static IntKeyMapper ofIdentity() {
-            return new IntKeyMapper() {
-                @Override
-                public int keyToIndex(int key) {
-                    return key;
-                }
-
-                @Override
-                public boolean isMappable(int key) {
-                    return true;
-                }
-
-                @Override
-                public boolean checkArrayLength(int arrayLength) {
-                    return true;
-                }
-
-                @Override
-                public OptionalInt requiredLength() {
-                    return OptionalInt.empty();
-                }
-            };
-        }
-    }
-
-    private final class ListView implements List<V> {
-
-        private final V defaultValue;
-        private final int begin;
-        private final int end;
-
-        ListView(int begin,
-                 int end,
-                 V defaultValue) {
-            if (begin < 0) {
-                throw new IndexOutOfBoundsException("begin: " + begin);
-            }
-            if (end > LazyReferenceArray.this.length()) {
-                throw new IndexOutOfBoundsException("end: " + begin);
-            }
-            this.begin = begin;
-            this.end = end;
-            this.defaultValue = defaultValue;
-        }
-
-        ListView(V defaultValue) {
-            this(0, LazyReferenceArray.this.length(), defaultValue);
-        }
-
-        @Override
-        public int size() {
-            return end - begin;
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return size() == 0;
-        }
-
-        @Override
-        public boolean contains(Object o) {
-            for (int i = begin; i < end; i++) {
-                if (Objects.equals(0, getOr(i, defaultValue))) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        @Override
-        public Iterator<V> iterator() {
-            return new ListIteratorView(0, length(), null);
-        }
-
-        @Override
-        public Object[] toArray() {
-            return IntStream.range(0, size())
-                    .mapToObj(i -> LazyReferenceArray.this.getOr(i, defaultValue))
-                    .toArray();
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        public <T1> T1[] toArray(T1[] a) {
-            if (a.length < size()) {
-                return (T1[]) Arrays.copyOf(toArray(), size(), a.getClass());
-            }
-            System.arraycopy(toArray(), 0, a, 0, size());
-            if (a.length > size())
-                a[size()] = null;
-            return a;
-        }
-
-        @Override
-        public boolean add(V v) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public boolean remove(Object o) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public boolean containsAll(Collection<?> c) {
-            for (Object e : c)
-                if (!contains(e))
-                    return false;
-            return true;
-        }
-
-        @Override
-        public boolean addAll(Collection<? extends V> c) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public boolean addAll(int index, Collection<? extends V> c) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public boolean removeAll(Collection<?> c) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public boolean retainAll(Collection<?> c) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public void clear() {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public V get(int index) {
-            return getOr(index, defaultValue);
-        }
-
-        @Override
-        public V set(int index, V element) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public void add(int index, V element) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public V remove(int index) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public int indexOf(Object o) {
-            for (int i = 0; i < size(); i++) {
-                if (Objects.equals(o, getOr(i, defaultValue))) {
-                    return i;
-                }
-            }
-            return -1;
-        }
-
-        @Override
-        public int lastIndexOf(Object o) {
-            for (int i = size() - 1; i >= 0; i--) {
-                if (Objects.equals(o, getOr(i, defaultValue))) {
-                    return i;
-                }
-            }
-            return -1;
-        }
-
-        @Override
-        public ListIterator<V> listIterator() {
-            return new ListIteratorView(defaultValue);
-        }
-
-        @Override
-        public ListIterator<V> listIterator(int index) {
-            return new ListIteratorView(index, length(), defaultValue);
-        }
-
-        @Override
-        public List<V> subList(int fromIndex, int toIndex) {
-            if (fromIndex < 0) {
-                throw new IndexOutOfBoundsException("fromIndex: " + fromIndex);
-            }
-            if (toIndex > size()) {
-                throw new IndexOutOfBoundsException("toIndex: " + toIndex);
-            }
-            if (fromIndex > toIndex) {
-                throw new IndexOutOfBoundsException("fromIndex > toIndex: " + fromIndex + ", " + toIndex);
-            }
-            return new ListView(begin + fromIndex, begin + toIndex, defaultValue);
-        }
-
-        @Override
-        public void sort(Comparator<? super V> c) {
-            throw newUnsupportedOperation();
-        }
-    }
-
-    final class ListIteratorView implements ListIterator<V> {
-
-        private final V defaultValue;
-        private final int begin;
-        private final int end;
-        private int cursor;
-
-        private ListIteratorView(V defaultValue) {
-            this(0, LazyReferenceArray.this.length(), defaultValue);
-        }
-
-        private ListIteratorView(int begin,
-                                 int end,
-                                 V defaultValue) {
-            this.begin = begin;
-            this.end = end;
-            this.defaultValue = defaultValue;
-            this.cursor = begin;
-        }
-
-        @Override
-        public boolean hasNext() {
-            return cursor < end;
-        }
-
-        @Override
-        public boolean hasPrevious() {
-            return cursor != begin;
-        }
-
-        @Override
-        public V previous() {
-            int i = cursor - 1;
-            if (i < begin)
-                throw new NoSuchElementException();
-            cursor = i;
-            return getOr(i, defaultValue);
-        }
-
-        @Override
-        public int nextIndex() {
-            return cursor;
-        }
-
-        @Override
-        public int previousIndex() {
-            return cursor - 1;
-        }
-
-        @Override
-        public void set(V v) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public void add(V v) {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public V next() {
-            var i = cursor + 1;
-            if (i >= end) {
-                throw new NoSuchElementException();
-            }
-            cursor = i;
-            return getOr(i, defaultValue);
-        }
-
-        @Override
-        public void remove() {
-            throw newUnsupportedOperation();
-        }
-
-        @Override
-        public void forEachRemaining(Consumer<? super V> action) {
-            for (; cursor < end; cursor++) {
-                action.accept(getOr(cursor, defaultValue));
-            }
-        }
-    }
-
-    private UnsupportedOperationException newUnsupportedOperation() {
-        return new UnsupportedOperationException("Not supported on an unmodifiable list.");
-    }
-
-}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java b/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java
deleted file mode 100644
index d94efda4389..00000000000
--- a/src/java.base/share/classes/java/util/concurrent/lazy/MarkWord.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package java.util.concurrent.lazy;
-
-import jdk.internal.misc.Unsafe;
-
-import java.util.Arrays;
-import java.util.HexFormat;
-import java.util.stream.Collectors;
-
-/**
- * To be removed!
- */
-public class MarkWord {
-
-    private MarkWord() {
-    }
-
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
-
-    /**
-     * A
-     * @param args a
-     */
-    public static void main(String[] args) {
-
-        Foo foo = new Foo();
-
-        printMark(foo);
-        synchronized (foo) {
-            printMark(foo);
-        }
-        printMark(foo);
-
-        int LOCK_OFFSET = UNSAFE.addressSize();
-
-        System.out.println("UNSAFE.isLocked(foo) = " + UNSAFE.isLocked(foo));
-        System.out.println("UNSAFE.getIntVolatile(foo, LOCK_OFFSET) = " + UNSAFE.getIntVolatile(foo, LOCK_OFFSET));
-        synchronized (foo) {
-            System.out.println("UNSAFE.isLocked(foo) = " + UNSAFE.isLocked(foo));
-            System.out.println("UNSAFE.getIntVolatile(foo, LOCK_OFFSET) = " + UNSAFE.getIntVolatile(foo, LOCK_OFFSET));
-        }
-
-
-    }
-
-    static void printMark(Object o) {
-        int[] mark = new int[3];
-        for (int i = 0; i < mark.length; i++) {
-            mark[i] = UNSAFE.getInt(o, i * Integer.BYTES);
-        }
-
-        var hex = Arrays.stream(mark)
-                .boxed()
-                .map(i -> Integer.toHexString(i))
-                .collect(Collectors.joining(", "));
-
-        System.out.println(hex);
-    }
-
-    static final class Foo {
-    }
-
-}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
new file mode 100644
index 00000000000..9189feb5f3c
--- /dev/null
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
@@ -0,0 +1,85 @@
+package java.util.concurrent.lazy;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.util.concurrent.lazy.PreComputedEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.PreComputedLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardLazyReference;
+
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * To be removed! This is just a temoporarly debug class to inspect object layout
+ */
+public class ObjectLayout {
+
+    private ObjectLayout() {
+    }
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    /**
+     * A
+     *
+     * @param args a
+     */
+    public static void main(String[] args) {
+
+        analyze(PreComputedEmptyLazyReference.class);
+        analyze(PreComputedLazyReference.class);
+
+        analyze(StandardEmptyLazyReference.class);
+        analyze(StandardLazyReference.class);
+
+    }
+
+    static void analyze(Class<?> c) {
+        System.out.println("Fields of " + c.getName());
+
+/*        intanceFields(c)
+                .forEach(System.out::println);*/
+/*
+        System.out.println("details:");*/
+
+        intanceFields(c)
+                .map(cf -> new ClassFieldOffset(cf.clazz().getSimpleName(), cf.fieldName(), (int) UNSAFE.objectFieldOffset(cf.clazz(), cf.fieldName())))
+                .sorted(Comparator.comparingInt(ClassFieldOffset::offset))
+                .forEach(System.out::println);
+
+        System.out.println();
+    }
+
+    @SuppressWarnings("unchecked")
+    static <T> Stream<ClassFieldName> intanceFields(Class<T> clazz) {
+        return Stream.iterate(clazz, c -> (Class<T>) c.getSuperclass())
+                .takeWhile(c -> c != Object.class)
+                .flatMap(c -> Arrays.stream(c.getDeclaredFields())
+                        .filter(f -> !Modifier.isStatic(f.getModifiers()))
+                        .map(f -> new ClassFieldName(c, f.getName())));
+    }
+
+    record ClassFieldName(Class<?> clazz, String fieldName){
+    }
+
+    record ClassFieldOffset(String klass, String field, int offset) {
+    }
+
+    static void printMark(Object o) {
+        int[] mark = new int[3];
+        for (int i = 0; i < mark.length; i++) {
+            mark[i] = UNSAFE.getInt(o, i * Integer.BYTES);
+        }
+
+        var hex = Arrays.stream(mark)
+                .boxed()
+                .map(i -> Integer.toHexString(i))
+                .collect(Collectors.joining(", "));
+
+        System.out.println(hex);
+    }
+
+}
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index 74e9980d6fb..b734f7386c0 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -45,7 +45,7 @@
  *
  * {@snippet class="PackageInfoSnippets" region="DemoPreset"}
  *
- * {@snippet lang = java :
+ * {@snippet lang = java:
  *     class DemoPreset {
  *
  *         private static final LazyReference<Foo> FOO = Lazy.of(Foo::new);
@@ -80,23 +80,22 @@
  * {@snippet lang = java:
  *     class Fox {
  *
- *         private final LazyReference<String> lazy = Lazy.ofEmpty();
+ *         private final EmptyLazyReference<String> lazy = Lazy.ofEmpty();
  *
  *         String init(String color) {
- *             return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+ *             return lazy.apply(() -> "The quick " + color + " fox");
  *         }
  *     }
  *}
  *
  * A custom configurable LazyReference can be obtained via the
- * {@linkplain java.util.concurrent.lazy.Lazy#builder() builder} method.
+ * {@linkplain java.util.concurrent.lazy.Lazy#builder(java.util.function.Supplier)} method.
  * Here is how a lazy value can be computed in the background and that may already be computed
  * when first requested from user code:
  * {@snippet lang = java:
  *     class DemoBackground {
  *
- *         private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
- *                 .withSupplier(Foo::new)
+ *         private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
  *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
  *                 .build();
  *
@@ -106,7 +105,7 @@
  *             System.out.println("lazy.get() = " + lazy.get());
  *         }
  *     }
- * }
+ *}
  *
  * {@code LazyReference<T>} implements {@code Supplier<T>} allowing simple
  * interoperability with legacy code and less specific type declaration
@@ -126,21 +125,21 @@
  *         }
  *     }
  *}
- * LazyReference contains additional methods for checking its
- * {@linkplain java.util.concurrent.lazy.LazyReference#state() state} and getting
- * any {@linkplain java.util.concurrent.lazy.LazyReference#exception()} that might be thrown
+ * LazyReference and EmptyLazyReference contains additional methods for checking its
+ * {@linkplain java.util.concurrent.lazy.BaseLazyReference#state() state} and getting
+ * any {@linkplain java.util.concurrent.lazy.BaseLazyReference#exception()} that might be thrown
  * by the provider.
  *
  * <h3 id="lazyarray">LazyArray</h3>
  *
- * Arrays of lazy values (i.e. {@link java.util.concurrent.lazy.LazyReferenceArray}) can also be
+ * Arrays of lazy values (i.e. {@link java.util.concurrent.lazy.LazyArray}) can also be
  * obtained via {@link java.util.concurrent.lazy.Lazy} factory methods in the same way as
  * for LazyReference instance but with an extra initial arity, indicating the desired length/index
  * of the array:
  * {@snippet lang = java:
  *     class DemoArray {
  *
- *         private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+ *         private static final LazyArray<Value> VALUE_PO2_CACHE =
  *                 Lazy.ofArray(32, index -> new Value(1L << index));
  *
  *         public Value powerOfTwoValue(int n) {
@@ -151,7 +150,7 @@
  *             return VALUE_PO2_CACHE.apply(n);
  *         }
  *     }
- * }
+ *}
  * As can be seen above, an array takes an {@link java.util.function.IntFunction} rather
  * than a {@link java.util.function.Supplier }, allowing custom values to be
  * computed and entered into the array depending on the current index being used.
@@ -162,14 +161,14 @@
  *     class UserCache {
  *
  *         // Cache the first 64 users
- *         private static final LazyReferenceArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
+ *         private static final EmptyLazyArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
  *
  *         public User user(int id) {
  *             Connection c = getDatabaseConnection();
  *             return USER_CACHE.computeIfEmpty(id, i -> findUserById(c, i));
  *         }
  *     }
- * }
+ *}
  *
  * {@code LazyReferenceArray<T>} implements {@code IntFunction<T>} allowing simple interoperability
  * with existing code and with less specific type declarations as shown hereunder:
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
index b75a5e7623a..88ee614ac69 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
@@ -26,10 +26,12 @@
 
 import java.util.List;
 import java.util.Optional;
+import java.util.concurrent.lazy.EmptyLazyArray;
+import java.util.concurrent.lazy.EmptyLazyReference;
 import java.util.concurrent.lazy.KeyMapper;
 import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyArray;
 import java.util.concurrent.lazy.LazyReference;
-import java.util.concurrent.lazy.LazyReferenceArray;
 import java.util.function.Function;
 import java.util.function.IntFunction;
 import java.util.function.Supplier;
@@ -71,10 +73,10 @@ class Holder {
     // @start region="Fox"
     class Fox {
 
-        private final LazyReference<String> lazy = Lazy.ofEmpty();
+        private final EmptyLazyReference<String> lazy = Lazy.ofEmpty();
 
         String init(String color) {
-            return lazy.supplyIfEmpty(() -> "The quick " + color + " fox");
+            return lazy.apply(() -> "The quick " + color + " fox");
         }
     }
     // @end
@@ -82,8 +84,7 @@ String init(String color) {
     // @start region="DemoBackground"
     class DemoBackground {
 
-        private static final LazyReference<Foo> lazy = Lazy.<Foo>builder()
-                .withSupplier(Foo::new)
+        private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
                 .build();
 
@@ -95,6 +96,20 @@ public static void main(String[] args) throws InterruptedException {
     }
     // @end
 
+    // @start region="DemoBackground"
+    class DemoPrecomputed {
+
+        private static final EmptyLazyReference<Foo> lazy = Lazy.<Foo>emptyBuilder()
+                .withValue(new Foo())
+                .build();
+
+        public static void main(String[] args) throws InterruptedException {
+            // lazy is already pre-computed here
+            System.out.println("lazy.apply(Foo::new) = " + lazy.apply(Foo::new));
+        }
+    }
+    // @end
+
     // @start region="SupplierDemo"
     class SupplierDemo {
 
@@ -114,7 +129,7 @@ public static void main(String[] args) {
     // @start region="DemoArray"
     class DemoArray {
 
-        private static final LazyReferenceArray<Value> VALUE_PO2_CACHE =
+        private static final LazyArray<Value> VALUE_PO2_CACHE =
                 Lazy.ofArray(32, index -> new Value(1L << index));
 
         public Value powerOfTwoValue(int n) {
@@ -131,8 +146,7 @@ public Value powerOfTwoValue(int n) {
     class UserCache {
 
         // Cache the first 64 users
-        private static final LazyReferenceArray<User> USER_CACHE =
-                Lazy.ofEmptyArray(64);
+        private static final EmptyLazyArray<User> USER_CACHE = Lazy.ofEmptyArray(64);
 
         public User user(int id) {
             Connection c = getDatabaseConnection();
@@ -207,13 +221,17 @@ static int fib(int n) {
                     : fib(n - 1) + fib(n - 2);
         }
 
-        private static final int INTERVAL = 10; // Must be > 2
+        private static final EmptyLazyArray<Integer> FIB_10_CACHE =
+                Lazy.ofEmptyTranslatedArray(3, 10);
 
-        private static final LazyReferenceArray<Integer> FIB_10_CACHE =
-                Lazy.ofEmptyArray(3);
 
-        private static final LazyReferenceArray.IntKeyMapper KEY_MAPPER =
-                LazyReferenceArray.IntKeyMapper.ofConstant(INTERVAL);
+        // Only works for values up to ~30
+
+        static int cachedFib(int n) {
+            if (n <= 1)
+                return n;
+            return FIB_10_CACHE.computeIfEmpty(n, DemoFibMapped::fib);
+        }
 
         /**
          * Main method
@@ -231,15 +249,6 @@ public static void main(String[] args) throws InterruptedException {
             System.out.println("cachedFib(11) = " + cachedFib(11)); // 111 invocations
         }
 
-        // Only works for values up to ~30
-
-        static int cachedFib(int n) {
-            if (n <= 1)
-                return n;
-            return FIB_10_CACHE.mapIntAndApply(KEY_MAPPER, n,
-                    DemoFibMapped::fib,
-                    DemoFibMapped::fib);
-        }
 
         private DemoFibMapped() {
         }
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
new file mode 100644
index 00000000000..b6f2943f2a1
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.util.concurrent.lazy;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.Stable;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.Lazy;
+
+public abstract class AbstractBaseLazyReference<V>
+        implements BaseLazyReference<V> {
+
+    static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    // Allows access to the "value" field with arbitary memory semantics
+    static final VarHandle VALUE_HANDLE;
+
+    // Allows access to the "value" field with arbitary memory semantics
+    static final VarHandle AUX_HANDLE;
+
+    static {
+        try {
+            VALUE_HANDLE = MethodHandles.lookup()
+                    .findVarHandle(AbstractBaseLazyReference.class, "value", Object.class);
+            // .withInvokeExactBehavior(); // Make sure no boxing is made?
+            AUX_HANDLE = MethodHandles.lookup()
+                    .findVarHandle(AbstractBaseLazyReference.class, "auxilaryObject", Object.class);
+            // .withInvokeExactBehavior(); // Make sure no boxing is made?
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    // This field holds the lazy value. If != null, a valid value exist
+    @Stable
+    V value;
+
+    // This field has two purposes:
+    // 1) Flag if the lazy is being constucted.
+    // 2) Holds a Throwable, if the computation of the value failed.
+    Object auxilaryObject;
+
+    public AbstractBaseLazyReference() {
+    }
+
+    @Override
+    public final Lazy.State state() {
+        // Try normal memory semantics first
+        Object o = value;
+        if (o != null) {
+            return Lazy.State.PRESENT;
+        }
+
+        Object aux = auxilaryObject;
+        if (aux == LazyUtil.CONSTRUCTING) {
+            return Lazy.State.CONSTRUCTING;
+        }
+        if (aux instanceof Throwable throwable) {
+            return Lazy.State.ERROR;
+        }
+
+        // Retry with volatile semantics
+        o = VALUE_HANDLE.getVolatile(this);
+        if (o != null) {
+            return Lazy.State.PRESENT;
+        }
+
+        aux = AUX_HANDLE.getVolatile(this);
+        if (aux == LazyUtil.CONSTRUCTING) {
+            return Lazy.State.CONSTRUCTING;
+        }
+        if (aux instanceof Throwable throwable) {
+            return Lazy.State.ERROR;
+        }
+
+        return Lazy.State.EMPTY;
+    }
+
+    @Override
+    public final Optional<Throwable> exception() {
+
+        // Try normal memory semantics first
+        Object aux = auxilaryObject;
+        if (auxilaryObject instanceof Throwable throwable) {
+            return Optional.of(throwable);
+        }
+
+        // Retry with volatile semantics
+        aux = AUX_HANDLE.getVolatile(this);
+        return (auxilaryObject instanceof Throwable throwable)
+                ? Optional.of(throwable)
+                : Optional.empty();
+    }
+
+    @Override
+    public V getOr(V defaultValue) {
+        V v = value;
+        if (v != null) {
+            return v;
+        }
+        v = (V) VALUE_HANDLE.getVolatile(this);
+        if (v != null) {
+            return v;
+        }
+
+        // No use trying normal semantics as we have to try volatile semantics anyhow
+        if (AUX_HANDLE.getVolatile(this) instanceof Throwable throwable) {
+            throw new NoSuchElementException(throwable);
+        }
+        return defaultValue;
+    }
+
+    @Override
+    public final String toString() {
+        return getClass().getSimpleName() + "[" +
+                switch (state()) {
+                    case EMPTY -> Lazy.State.EMPTY;
+                    case CONSTRUCTING -> Lazy.State.CONSTRUCTING;
+                    case PRESENT -> value;
+                    case ERROR -> Lazy.State.ERROR + " [" + value + "]";
+                }
+                + "]";
+    }
+
+    abstract void afterSupplying();
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
index a4e081e2d56..cc4c06c0744 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
@@ -2,8 +2,8 @@
 
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.EmptyLazyArray;
 import java.util.concurrent.lazy.Lazy;
-import java.util.concurrent.lazy.LazyReferenceArray;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
@@ -12,7 +12,7 @@
 class AbstractMapper<K, V> {
 
     protected final Map<K, Integer> keyToInt;
-    protected final LazyReferenceArray<V> lazyArray;
+    protected final EmptyLazyArray<V> lazyArray;
 
     protected <T> AbstractMapper(Stream<T> keyHolders,
                                  Function<T, K> keyExtractor) {
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
new file mode 100644
index 00000000000..27e674ffe23
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
@@ -0,0 +1,38 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.EmptyLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.function.Supplier;
+
+abstract class AbstractPreComputedLazyReference<V>
+        implements BaseLazyReference<V> {
+
+    final V value;
+
+    public AbstractPreComputedLazyReference(V value) {
+        this.value = value;
+    }
+
+    @Override
+    public Lazy.State state() {
+        return Lazy.State.PRESENT;
+    }
+
+    @Override
+    public Optional<Throwable> exception() {
+        return Optional.empty();
+    }
+
+    @Override
+    public V getOr(V defaultValue) {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + "[" + value + "]";
+    }
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
index 5374db9b96d..b4c5857b7bc 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
@@ -2,12 +2,8 @@
 
 import java.util.Collection;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.lazy.KeyMapper;
-import java.util.concurrent.lazy.Lazy;
-import java.util.concurrent.lazy.LazyReferenceArray;
 import java.util.function.Function;
 
 import static java.util.stream.Collectors.toMap;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
index 0dfc63f604e..fcc129d9917 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
@@ -1,12 +1,8 @@
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Collection;
-import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.lazy.Lazy;
-import java.util.concurrent.lazy.LazyReferenceArray;
 import java.util.function.Function;
 
 import static java.util.stream.Collectors.toMap;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
index cc65c4b7e45..b16fe8d21f7 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
@@ -2,42 +2,48 @@
 
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
-import java.util.concurrent.lazy.LazyReference;
+import java.util.NoSuchElementException;
+import java.util.function.Supplier;
 
 public final class LazyUtil {
-    private LazyUtil() {
-    }
-/*
-    // Atomically aquires (sets) the provided flag and returns if it was not previously set
-    // (using volatile semantics)
-    private boolean acquire(int flag) {
-        int previousFlag = (int) FLAGS_HANDLE.getAndBitwiseOr(this, flag);
-        return (previousFlag & flag) == 0;
-    }
 
-    // Atomically releases (clears) the provided flag and returns if it was previously set
-    // (using volatile semantics)
-    private boolean release(int flag) {
-        int previousFlag = (int) FLAGS_HANDLE.getAndBitwiseAnd(this, ~flag);
-        return (previousFlag & flag) != 0;
-    }
+    // Object that flags the Lazy is being constucted. Any object that is not a Throwable can be used.
+    public static final Object CONSTRUCTING = LazyUtil.class;
 
-    // Atomically obtains (gets) the provided flag (using volatile semantics)
-    private boolean get(int flag) {
-        int flags = (int) FLAGS_HANDLE.getVolatile(this);
-        return (flags & flag) != 0;
-    }*/
+    private LazyUtil() {
+    }
 
-    public static VarHandle varHandle(MethodHandles.Lookup lookup,
-                                      String fieldName,
-                                      Class<?> fieldType) {
-        try {
-            return lookup
-                    .findVarHandle(LazyReference.class, fieldName, fieldType);
-            // .withInvokeExactBehavior(); // Make sure no boxing is made?
-        } catch (ReflectiveOperationException e) {
-            throw new ExceptionInInitializerError(e);
+    static <V> V supplyIfEmpty(AbstractBaseLazyReference<V> lazy,
+                               Supplier<? extends V> supplier) {
+        // implies volatile semantics when entering/leaving the monitor
+        synchronized (lazy) {
+            // Here, visibility is guaranteed
+            V v = lazy.value;
+            if (v != null) {
+                return v;
+            }
+            if (lazy.auxilaryObject instanceof Throwable throwable) {
+                throw new NoSuchElementException(throwable);
+            }
+            if (supplier == null) {
+                throw new IllegalStateException("No pre-set supplier given");
+            }
+            try {
+                lazy.auxilaryObject = CONSTRUCTING;
+                v = supplier.get();
+                if (v == null) {
+                    throw new NullPointerException("Supplier returned null");
+                }
+                AbstractBaseLazyReference.VALUE_HANDLE.setVolatile(lazy, v);
+                return v;
+            } catch (Throwable e) {
+                // Record the throwable instead of the value.
+                AbstractBaseLazyReference.AUX_HANDLE.setVolatile(lazy, e);
+                // Rethrow
+                throw e;
+            } finally {
+                lazy.afterSupplying();
+            }
         }
     }
-
 }
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
new file mode 100644
index 00000000000..c2e4cfa7c8a
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
@@ -0,0 +1,24 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.lazy.EmptyLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public final class PreComputedEmptyLazyReference<V>
+    extends AbstractPreComputedLazyReference<V>
+        implements EmptyLazyReference<V> {
+
+    public PreComputedEmptyLazyReference(V value) {
+        super(value);
+    }
+
+    @Override
+    public V apply(Supplier<? extends V> supplier) {
+        Objects.requireNonNull(supplier);
+        return value;
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
new file mode 100644
index 00000000000..cf8f2b608b9
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
@@ -0,0 +1,24 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public final class PreComputedLazyReference<V>
+        extends AbstractPreComputedLazyReference<V>
+        implements LazyReference<V> {
+
+    public PreComputedLazyReference(V value) {
+        super(value);
+    }
+
+    @Override
+    public V get() {
+        return value;
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
new file mode 100644
index 00000000000..b5c692d3e49
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
@@ -0,0 +1,31 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.EmptyLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public final class StandardEmptyLazyReference<V>
+        extends AbstractBaseLazyReference<V>
+        implements EmptyLazyReference<V> {
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public V apply(Supplier<? extends V> supplier) {
+        Objects.requireNonNull(supplier);
+        V v = value;
+        if (v != null) {
+            return v;
+        }
+        return LazyUtil.supplyIfEmpty(this, supplier);
+    }
+
+    @Override
+    void afterSupplying() {
+        // Do nothing.
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
new file mode 100644
index 00000000000..0ce8a61ec8f
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
@@ -0,0 +1,29 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Objects;
+import java.util.concurrent.lazy.EmptyLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public record StandardEmptyLazyReferenceBuilder<V>(V v)
+        implements EmptyLazyReference.Builder<V> {
+
+    public StandardEmptyLazyReferenceBuilder() {
+        this(null);
+    }
+
+    @Override
+    public EmptyLazyReference.Builder<V> withValue(V v) {
+        Objects.requireNonNull(v);
+        return new StandardEmptyLazyReferenceBuilder<>(v);
+    }
+
+    @Override
+    public EmptyLazyReference<V> build() {
+        return v != null
+                ? new PreComputedEmptyLazyReference<>(v)
+                : new StandardEmptyLazyReference<>();
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
new file mode 100644
index 00000000000..a30f1859b77
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
@@ -0,0 +1,34 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.NoSuchElementException;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public final class StandardLazyReference<V>
+        extends AbstractBaseLazyReference<V>
+        implements LazyReference<V> {
+
+    private Supplier<? extends V> supplier;
+
+    public StandardLazyReference(Supplier<? extends V> supplier) {
+        this.supplier = supplier;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public V get() {
+        V v = value;
+        if (v != null) {
+            return v;
+        }
+        return LazyUtil.supplyIfEmpty(this, supplier);
+    }
+
+    @Override
+    void afterSupplying() {
+        // Make the supplier elagable for collection
+        supplier = null;
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
new file mode 100644
index 00000000000..57e4fee44eb
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
@@ -0,0 +1,35 @@
+package jdk.internal.util.concurrent.lazy;
+
+import java.util.Objects;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Supplier;
+
+public record StandardLazyReferenceBuilder<V>(Supplier<? extends V> s,
+                                              V v,
+                                              Lazy.Evaluation e)
+        implements LazyReference.Builder<V> {
+
+    public StandardLazyReferenceBuilder(Supplier<? extends V> s) {
+        this(s, null, Lazy.Evaluation.AT_USE);
+    }
+
+    @Override
+    public LazyReference.Builder<V> withValue(V v) {
+        Objects.requireNonNull(v);
+        return new StandardLazyReferenceBuilder<>(s, v, e);
+    }
+
+    @Override
+    public LazyReference.Builder<V> withEarliestEvaluation(Lazy.Evaluation e) {
+        return new StandardLazyReferenceBuilder<>(s, v, e);
+    }
+
+    @Override
+    public LazyReference<V> build() {
+        return (v != null)
+                ? new PreComputedLazyReference<>(v)
+                : new StandardLazyReference<>(s);
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
new file mode 100644
index 00000000000..33a292a3bb4
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
@@ -0,0 +1,392 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.util.concurrent.lazy.array;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.util.concurrent.lazy.AbstractBaseLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+import jdk.internal.vm.annotation.Stable;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.lazy.BaseLazyArray;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyReference;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+abstract class AbstractBaseLazyArray<V, L extends AbstractBaseLazyReference<V>>
+        implements BaseLazyArray<V> {
+
+    private final LazyReference<ListView> listView = Lazy.of(ListView::new);
+
+    final L[] lazyObjects;
+
+    @SuppressWarnings("unchecked")
+    AbstractBaseLazyArray(L[] lazyObjects) {
+        this.lazyObjects = lazyObjects;
+    }
+
+    @Override
+    public final int length() {
+        return lazyObjects.length;
+    }
+
+    @Override
+    public final Lazy.State state(int index) {
+        return lazyObjects[index].state();
+    }
+
+    @Override
+    public final Optional<Throwable> exception(int index) {
+        return lazyObjects[index].exception();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public V getOr(int index, V defaultValue) {
+        return lazyObjects[index].getOr(defaultValue);
+    }
+
+    @Override
+    public List<V> asList() {
+        return listView.get();
+    }
+
+    @Override
+    public List<V> asList(V defaulValue) {
+        return new ListView(defaulValue);
+    }
+
+    @Override
+    public Stream<Optional<V>> stream() {
+        return IntStream.range(0, length())
+                .mapToObj(i -> Optional.ofNullable(getOr(i, null)));
+    }
+
+    @Override
+    public Stream<V> stream(V defaultValue) {
+        return IntStream.range(0, length())
+                .mapToObj(i -> getOr(i, defaultValue));
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + "[" + IntStream.range(0, length())
+                .mapToObj(i -> switch (state(i)) {
+                    case EMPTY -> "-";
+                    case CONSTRUCTING -> "+";
+                    case PRESENT -> Objects.toString(getOr(i, null));
+                    case ERROR -> "!";
+                })
+                .collect(Collectors.joining(", ")) + "]";
+    }
+
+    final class ListView implements List<V> {
+
+        private final V defaultValue;
+        private final int begin;
+        private final int end;
+
+        ListView(int begin,
+                 int end,
+                 V defaultValue) {
+            if (begin < 0) {
+                throw new IndexOutOfBoundsException("begin: " + begin);
+            }
+            if (end > length()) {
+                throw new IndexOutOfBoundsException("end: " + begin);
+            }
+            this.begin = begin;
+            this.end = end;
+            this.defaultValue = defaultValue;
+        }
+
+        public ListView() {
+            this(null);
+        }
+
+        ListView(V defaultValue) {
+            this(0, length(), defaultValue);
+        }
+
+        @Override
+        public int size() {
+            return end - begin;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return size() == 0;
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            for (int i = begin; i < end; i++) {
+                if (Objects.equals(0, getOr(i, defaultValue))) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public Iterator<V> iterator() {
+            return new ListIteratorView(0, length(), null);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return IntStream.range(0, size())
+                    .mapToObj(i -> getOr(i, defaultValue))
+                    .toArray();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public <T1> T1[] toArray(T1[] a) {
+            if (a.length < size()) {
+                return (T1[]) Arrays.copyOf(toArray(), size(), a.getClass());
+            }
+            System.arraycopy(toArray(), 0, a, 0, size());
+            if (a.length > size())
+                a[size()] = null;
+            return a;
+        }
+
+        @Override
+        public boolean add(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            for (Object e : c)
+                if (!contains(e))
+                    return false;
+            return true;
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean addAll(int index, Collection<? extends V> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void clear() {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V get(int index) {
+            return getOr(index, defaultValue);
+        }
+
+        @Override
+        public V set(int index, V element) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void add(int index, V element) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V remove(int index) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public int indexOf(Object o) {
+            for (int i = 0; i < size(); i++) {
+                if (Objects.equals(o, getOr(i, defaultValue))) {
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        @Override
+        public int lastIndexOf(Object o) {
+            for (int i = size() - 1; i >= 0; i--) {
+                if (Objects.equals(o, getOr(i, defaultValue))) {
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        @Override
+        public ListIterator<V> listIterator() {
+            return new ListIteratorView(defaultValue);
+        }
+
+        @Override
+        public ListIterator<V> listIterator(int index) {
+            return new ListIteratorView(index, length(), defaultValue);
+        }
+
+        @Override
+        public List<V> subList(int fromIndex, int toIndex) {
+            if (fromIndex < 0) {
+                throw new IndexOutOfBoundsException("fromIndex: " + fromIndex);
+            }
+            if (toIndex > size()) {
+                throw new IndexOutOfBoundsException("toIndex: " + toIndex);
+            }
+            if (fromIndex > toIndex) {
+                throw new IndexOutOfBoundsException("fromIndex > toIndex: " + fromIndex + ", " + toIndex);
+            }
+            return new ListView(begin + fromIndex, begin + toIndex, defaultValue);
+        }
+
+        @Override
+        public void sort(Comparator<? super V> c) {
+            throw newUnsupportedOperation();
+        }
+    }
+
+    final class ListIteratorView implements ListIterator<V> {
+
+        private final V defaultValue;
+        private final int begin;
+        private final int end;
+        private int cursor;
+
+        private ListIteratorView(V defaultValue) {
+            this(0, length(), defaultValue);
+        }
+
+        private ListIteratorView(int begin,
+                                 int end,
+                                 V defaultValue) {
+            this.begin = begin;
+            this.end = end;
+            this.defaultValue = defaultValue;
+            this.cursor = begin;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor < end;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return cursor != begin;
+        }
+
+        @Override
+        public V previous() {
+            int i = cursor - 1;
+            if (i < begin)
+                throw new NoSuchElementException();
+            cursor = i;
+            return getOr(i, defaultValue);
+        }
+
+        @Override
+        public int nextIndex() {
+            return cursor;
+        }
+
+        @Override
+        public int previousIndex() {
+            return cursor - 1;
+        }
+
+        @Override
+        public void set(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void add(V v) {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public V next() {
+            var i = cursor + 1;
+            if (i >= end) {
+                throw new NoSuchElementException();
+            }
+            cursor = i;
+            return getOr(i, defaultValue);
+        }
+
+        @Override
+        public void remove() {
+            throw newUnsupportedOperation();
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super V> action) {
+            for (; cursor < end; cursor++) {
+                action.accept(getOr(cursor, defaultValue));
+            }
+        }
+    }
+
+    private UnsupportedOperationException newUnsupportedOperation() {
+        return new UnsupportedOperationException("Not supported on an unmodifiable list.");
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
new file mode 100644
index 00000000000..675d4c81f99
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
@@ -0,0 +1,33 @@
+package jdk.internal.util.concurrent.lazy.array;
+
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardLazyReference;
+
+import java.util.Objects;
+import java.util.concurrent.lazy.BaseLazyArray;
+import java.util.concurrent.lazy.EmptyLazyArray;
+import java.util.concurrent.lazy.LazyArray;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+public final class StandardEmptyLazyArray<V>
+        extends AbstractBaseLazyArray<V, StandardEmptyLazyReference<V>>
+        implements EmptyLazyArray<V> {
+
+    @SuppressWarnings("unchecked")
+    public StandardEmptyLazyArray(int length) {
+        super(IntStream.range(0, length)
+                .mapToObj(i -> new StandardEmptyLazyReference<>())
+                .toArray(StandardEmptyLazyReference[]::new));
+    }
+
+    @Override
+    public V computeIfEmpty(int index,
+                            IntFunction<? extends V> mappper) {
+        Objects.requireNonNull(mappper);
+        return lazyObjects[index]
+                .apply(() -> mappper.apply(index));
+    }
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
new file mode 100644
index 00000000000..272ba685ac9
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
@@ -0,0 +1,39 @@
+package jdk.internal.util.concurrent.lazy.array;
+
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardLazyReference;
+
+import java.util.concurrent.lazy.BaseLazyArray;
+import java.util.concurrent.lazy.BaseLazyReference;
+import java.util.concurrent.lazy.Lazy;
+import java.util.concurrent.lazy.LazyArray;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+import java.util.stream.IntStream;
+
+public final class StandardLazyArray<V>
+        extends AbstractBaseLazyArray<V, StandardLazyReference<V>>
+        implements LazyArray<V> {
+
+    @SuppressWarnings("unchecked")
+    public StandardLazyArray(int length,
+                             IntFunction<? extends V> presetMapper) {
+
+        super(IntStream.range(0, length)
+                .mapToObj(i -> new StandardLazyReference<>(() -> presetMapper.apply(i)))
+                .toArray(StandardLazyReference[]::new));
+    }
+
+    @Override
+    public V apply(int index) {
+        return lazyObjects[index].get();
+    }
+
+    @Override
+    public void force() {
+        for (int i = 0; i < length(); i++) {
+            lazyObjects[i].get();
+        }
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java
new file mode 100644
index 00000000000..eab1e4deee6
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java
@@ -0,0 +1,37 @@
+package jdk.internal.util.concurrent.lazy.array;
+
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
+
+import java.util.Objects;
+import java.util.concurrent.lazy.EmptyLazyArray;
+import java.util.function.IntFunction;
+import java.util.stream.IntStream;
+
+public final class TranslatedEmptyLazyArray<V>
+        extends AbstractBaseLazyArray<V, StandardEmptyLazyReference<V>>
+        implements EmptyLazyArray<V> {
+
+    private final int factor;
+
+    @SuppressWarnings("unchecked")
+    public TranslatedEmptyLazyArray(int length,
+                                    int factor) {
+        super(IntStream.range(0, length)
+                .mapToObj(i -> new StandardEmptyLazyReference<>())
+                .toArray(StandardEmptyLazyReference[]::new));
+        this.factor = factor;
+    }
+
+    @Override
+    public V computeIfEmpty(int index,
+                            IntFunction<? extends V> mappper) {
+        Objects.requireNonNull(mappper);
+        if (index % factor == 0) {
+            int translatedIndex = index / factor;
+            return lazyObjects[translatedIndex]
+                    .apply(() -> mappper.apply(index));
+        }
+        return mappper.apply(index);
+    }
+
+}
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
index 995be34ccbb..15a25ecb6fd 100644
--- a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceArrayTest.java
@@ -36,8 +36,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.EmptyLazyArray;
 import java.util.concurrent.lazy.Lazy;
-import java.util.concurrent.lazy.LazyReferenceArray;
+import java.util.concurrent.lazy.LazyArray;
 import java.util.function.Consumer;
 import java.util.function.IntFunction;
 import java.util.stream.IntStream;
@@ -49,7 +50,7 @@ final class BasicLazyReferenceArrayTest {
     private static final int SIZE = 63;
     private static final int INDEX = 13;
 
-    LazyReferenceArray<Integer> lazy;
+    EmptyLazyArray<Integer> lazy;
     CountingIntegerMapper mapper;
 
     @BeforeEach
@@ -78,12 +79,6 @@ void nulls() {
                 () -> lazy.computeIfEmpty(INDEX, i -> null));
     }
 
-    @Test
-    void noPresetGet() {
-        assertThrows(IllegalStateException.class,
-                () -> lazy.apply(INDEX));
-    }
-
     @Test
     void state() {
         assertEquals(Lazy.State.EMPTY, lazy.state(INDEX));
@@ -93,7 +88,7 @@ void state() {
 
     @Test
     void presetMapperBasic() {
-        LazyReferenceArray<Integer> presetLazy = Lazy.ofArray(SIZE, mapper);
+        LazyArray<Integer> presetLazy = Lazy.ofArray(SIZE, mapper);
         assertEquals(0, mapper.invocations(INDEX));
         for (int i = 0; i < 2; i++) {
             assertEquals(INDEX, presetLazy.apply(INDEX));
@@ -164,7 +159,7 @@ void testToString() throws InterruptedException {
 
         var toString = lazy.toString();
 
-        assertEquals("LazyReferenceArray[-, 1, !]", toString);
+        assertTrue(toString.endsWith("EmptyLazyArray[-, 1, !]"));
     }
 
     // Todo:repeate the test 1000 times
@@ -184,7 +179,7 @@ void threadTest() throws InterruptedException {
         Thread.sleep(10);
         gate.set(true);
         join(threads);
-        assertEquals(INDEX, lazy.apply(INDEX));
+        assertEquals(INDEX, lazy.getOr(INDEX, null));
         assertEquals(1, mapper.invocations(INDEX));
     }
 
diff --git a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
index 3f8ce01d33b..81933782666 100644
--- a/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
+++ b/test/jdk/java/util/concurrent/lazy/BasicLazyReferenceTest.java
@@ -35,6 +35,7 @@
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.EmptyLazyReference;
 import java.util.concurrent.lazy.Lazy;
 import java.util.concurrent.lazy.LazyReference;
 import java.util.function.Supplier;
@@ -44,7 +45,7 @@
 
 final class BasicLazyReferenceTest {
 
-    LazyReference<Integer> lazy;
+    EmptyLazyReference<Integer> lazy;
     CountingIntegerSupplier supplier;
 
     @BeforeEach
@@ -55,10 +56,10 @@ void setup() {
 
     @Test
     void supply() {
-        Integer val = lazy.supplyIfEmpty(supplier);
+        Integer val = lazy.apply(supplier);
         assertEquals(CountingIntegerSupplier.MAGIC_VALUE, val);
         assertEquals(1, supplier.invocations());
-        Integer val2 = lazy.supplyIfEmpty(supplier);
+        Integer val2 = lazy.apply(supplier);
         assertEquals(CountingIntegerSupplier.MAGIC_VALUE, val);
         assertEquals(1, supplier.invocations());
     }
@@ -67,22 +68,16 @@ void supply() {
     void nulls() {
         // Mapper is null
         assertThrows(NullPointerException.class,
-                () -> lazy.supplyIfEmpty(null));
+                () -> lazy.apply(null));
         // Mapper returns null
         assertThrows(NullPointerException.class,
-                () -> lazy.supplyIfEmpty(() -> null));
-    }
-
-    @Test
-    void noPresetGet() {
-        assertThrows(IllegalStateException.class,
-                () -> lazy.get());
+                () -> lazy.apply(() -> null));
     }
 
     @Test
     void state() {
         assertEquals(Lazy.State.EMPTY, lazy.state());
-        Integer val = lazy.supplyIfEmpty(supplier);
+        Integer val = lazy.apply(supplier);
         assertEquals(Lazy.State.PRESENT, lazy.state());
     }
 
@@ -119,13 +114,13 @@ void error() {
             throw new UnsupportedOperationException();
         };
         assertThrows(UnsupportedOperationException.class,
-                () -> lazy.supplyIfEmpty(throwSupplier));
+                () -> lazy.apply(throwSupplier));
 
         assertEquals(Lazy.State.ERROR, lazy.state());
         assertTrue(lazy.exception().isPresent());
 
         // Should not invoke the supplier as we are already in ERROR state
-        assertThrows(NoSuchElementException.class, () -> lazy.supplyIfEmpty(throwSupplier));
+        assertThrows(NoSuchElementException.class, () -> lazy.apply(throwSupplier));
     }
 
     // Todo:repeate the test 1000 times
@@ -138,19 +133,23 @@ void threadTest() throws InterruptedException {
                         Thread.onSpinWait();
                     }
                     // Try to access the instance "simultaneously"
-                    lazy.supplyIfEmpty(supplier);
+                    lazy.apply(supplier);
                 }))
                 .toList();
         threads.forEach(Thread::start);
         Thread.sleep(10);
         gate.set(true);
         join(threads);
-        assertEquals(CountingIntegerSupplier.MAGIC_VALUE, lazy.get());
+        assertEquals(CountingIntegerSupplier.MAGIC_VALUE, lazy.apply(supplier));
         assertEquals(1, supplier.invocations());
     }
 
     @Test
     void testToString() throws InterruptedException {
+        assertTrue(lazy.toString().endsWith("EmptyLazyReference[EMPTY]"));
+        lazy.apply(supplier);
+        assertTrue(lazy.toString().endsWith("EmptyLazyReference[42]"));
+
         var lazy0 = Lazy.of(() -> 0);
         var lazy1 = Lazy.of(() -> 1);
         lazy1.get();
@@ -165,8 +164,8 @@ void testToString() throws InterruptedException {
             // Happy path
         }
 
-        assertEquals("LazyReference[EMPTY]", lazy0.toString());
-        assertEquals("LazyReference[1]", lazy1.toString());
+        assertTrue(lazy0.toString().endsWith("LazyReference[EMPTY]"));
+        assertTrue(lazy1.toString().endsWith("LazyReference[1]"));
 
         // Todo: Figure out why this fails
         // assertEquals("LazyReference[ERROR]", lazy2.toString());
diff --git a/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
index 7c1fa425394..4da20e0cd78 100644
--- a/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
+++ b/test/jdk/java/util/concurrent/lazy/LazyReferenceArrayMappingTest.java
@@ -31,9 +31,8 @@
 import org.junit.jupiter.api.*;
 
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.lazy.EmptyLazyArray;
 import java.util.concurrent.lazy.Lazy;
-import java.util.concurrent.lazy.LazyReferenceArray;
-import java.util.function.Function;
 import java.util.function.IntFunction;
 import java.util.stream.IntStream;
 
@@ -44,24 +43,34 @@ final class LazyReferenceArrayMappingTest {
     private static final int SIZE = 63;
     private static final int INDEX = 13;
 
-    LazyReferenceArray<Integer> lazy;
+    EmptyLazyArray<Integer> lazy;
     CountingIntegerMapper mapper;
 
-    LazyReferenceArray.IntKeyMapper intKeyMapper;
-
     @BeforeEach
     void setup() {
         lazy = Lazy.ofEmptyArray(SIZE);
         mapper = new CountingIntegerMapper(SIZE);
-        intKeyMapper = LazyReferenceArray.IntKeyMapper.ofConstant(2);
     }
 
     @Test
     void mapInt() {
-        int two = lazy.mapIntAndApply(intKeyMapper, 2, i -> 2, i -> 0);
-        assertEquals(2, two);
-        int three = lazy.mapIntAndApply(intKeyMapper, 3, i -> 2, i -> 0);
-        assertEquals(0, three);
+        AtomicInteger cnt = new AtomicInteger();
+        IntFunction<Integer> mapper = i -> {
+            return cnt.getAndIncrement();
+        };
+
+        EmptyLazyArray<Integer> translated = Lazy.ofEmptyTranslatedArray(SIZE, 2);
+        // 2 is cached
+        int first = translated.computeIfEmpty(2, mapper);
+        assertEquals(0, first);
+        int second = translated.computeIfEmpty(2, mapper);
+        assertEquals(0, second);
+
+        // 3 is not cached
+        int third = translated.computeIfEmpty(3, mapper);
+        assertEquals(1, third);
+        int fourth = translated.computeIfEmpty(3, mapper);
+        assertEquals(2, fourth);
     }
 
     static private final class CountingIntegerMapper implements IntFunction<Integer> {

From 56378556a8ddbf43d98df9197ba258ecdf301cda Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 09:40:04 +0200
Subject: [PATCH 09/16] Improve docks and seal interfaces

---
 .../util/concurrent/lazy/BaseLazyArray.java   | 33 ++++++++-
 .../concurrent/lazy/BaseLazyReference.java    | 30 ++++++++-
 .../util/concurrent/lazy/EmptyLazyArray.java  | 32 ++++++++-
 .../concurrent/lazy/EmptyLazyReference.java   | 32 ++++++++-
 .../java/util/concurrent/lazy/KeyMapper.java  | 25 +++++++
 .../java/util/concurrent/lazy/Lazy.java       | 25 +++++++
 .../java/util/concurrent/lazy/LazyArray.java  | 31 ++++++++-
 .../util/concurrent/lazy/LazyReference.java   | 32 ++++++++-
 .../util/concurrent/lazy/ObjectLayout.java    | 25 +++++++
 .../util/concurrent/lazy/package-info.java    | 67 ++++++++++++++++---
 10 files changed, 312 insertions(+), 20 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
index 77f09edde90..bd3a6f1bff7 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
@@ -1,6 +1,32 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.array.StandardEmptyLazyArray;
 
 import java.util.List;
 import java.util.NoSuchElementException;
@@ -12,10 +38,13 @@
 /**
  * Base interface for lazy reference arrays , which are ... // Todo: write more here
  *
- * @param <V> The type of the value to be recorded
+ * @param <V> The type of values to be recorded
+ *
+ * @sealedGraph
+ * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface BaseLazyArray<V> {
+public sealed interface BaseLazyArray<V> permits EmptyLazyArray, LazyArray {
 
     /**
      * {@return the length of the array}.
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
index 5bd63dee7dc..14a76278083 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
@@ -9,9 +34,12 @@
  * Base interface for lazy references , which are ... // Todo: write more here
  *
  * @param <V> The type of the value to be recorded
+ *
+ * @sealedGraph
+ * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface BaseLazyReference<V> {
+public sealed interface BaseLazyReference<V> permits EmptyLazyReference, LazyReference {
 
     /**
      * {@return The {@link Lazy.State } of this Lazy}.
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
index 539c8a43063..04d2eb554c5 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
@@ -1,6 +1,33 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.array.StandardEmptyLazyArray;
+import jdk.internal.util.concurrent.lazy.array.TranslatedEmptyLazyArray;
 
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -14,8 +41,9 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface EmptyLazyArray<V>
-        extends BaseLazyArray<V> {
+public sealed interface EmptyLazyArray<V>
+        extends BaseLazyArray<V>
+        permits StandardEmptyLazyArray, TranslatedEmptyLazyArray {
 
     /**
      * Returns the present value at the provided {@code index} or, if no present value exists,
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
index bcb3fc500cd..1dd24ff3061 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
@@ -1,6 +1,33 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.PreComputedEmptyLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
 
 import java.util.NoSuchElementException;
 import java.util.function.Function;
@@ -14,8 +41,9 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface EmptyLazyReference<V>
-        extends BaseLazyReference<V>, Function<Supplier<? extends V>, V> {
+public sealed interface EmptyLazyReference<V>
+        extends BaseLazyReference<V>, Function<Supplier<? extends V>, V>
+        permits PreComputedEmptyLazyReference, StandardEmptyLazyReference {
 
     /**
      * Returns the present value or, if no present value exists, atomically attempts
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
index 950519afb51..eda699c8010 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/KeyMapper.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 6db9865d0cd..6453131a570 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
index 2cb306a9c80..ab7940c59ea 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
@@ -1,6 +1,32 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.array.StandardLazyArray;
 
 import java.util.NoSuchElementException;
 import java.util.function.IntFunction;
@@ -14,8 +40,9 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface LazyArray<V>
-        extends BaseLazyArray<V>, IntFunction<V> {
+public sealed interface LazyArray<V>
+        extends BaseLazyArray<V>, IntFunction<V>
+        permits StandardLazyArray {
 
     /**
      * Returns the present value at the provided {@code index} or, if no present value exists,
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index 23dcfe00ada..7a4bbb2a38f 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -1,6 +1,33 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.PreComputedLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardLazyReference;
 
 import java.util.NoSuchElementException;
 import java.util.function.Supplier;
@@ -13,8 +40,9 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public interface LazyReference<V>
-        extends BaseLazyReference<V>, Supplier<V> {
+public sealed interface LazyReference<V>
+        extends BaseLazyReference<V>, Supplier<V>
+        permits PreComputedLazyReference, StandardLazyReference {
 
     /**
      * Returns the present value or, if no present value exists, atomically attempts
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
index 9189feb5f3c..af1ec17b4ae 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package java.util.concurrent.lazy;
 
 import jdk.internal.misc.Unsafe;
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index b734f7386c0..c6b36ed901a 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -24,20 +24,53 @@
  */
 
 /**
+ * <h2 id="lazy">Lazy</h2>
+ *
+ * <p>
  * A small toolkit of classes supporting lock-free, thread-safe
  * use of lazily initialized values with superior performance.  Providers of
  * lazy values are guaranteed to be invoked at most one time.  This contrasts
  * to {@link java.util.concurrent.atomic.AtomicReferenceArray } where any number
  * of updates can be done and where there is no simple way to atomically compute
  * a value (guaranteed to only be computed once) if missing.
- *  <p>
+ * <p>
  * The lazy implementations are optimized for the case where there are N invocations
  * trying to obtain a value and where N >> 1, for example where N is > 2<sup>20</sup>.
- *
- * <h2 id="lazy">Lazy</h2>
- *
- * Instances of the many lazy types are obtained via the {@link java.util.concurrent.lazy.Lazy} class
- * using factory methods and builders.
+ * <p>
+ * Lazy types are all generic with respect to the reference value of type V they compute and
+ * come in four fundamental flavors grouped in two dimensions; "Element Capacity" and "Preprovidedness":
+ * <h3 id="element-capacity">Element Capacity</h3>
+ * <ol type="1">
+ *    <li>Reference (1 element)</li>
+ *    <li>Array     (N elements)</li>
+ * </ol>
+ * <h3 id="perprovidedness">Preprovidedness</h3>
+ * <ol type="A">
+ *     <li>Preprovided (with a pre-configured value provider)</li>
+ *     <li>Empty (with no value provider)</li>
+ * </ol>
+ * <p>
+ * These dimensions are combined to form:
+ * <ul>
+ *     <li>(1A) {@link LazyReference} with e.g. {@link java.util.concurrent.lazy.LazyReference#get() get()}<p>
+ *     available via {@link java.util.concurrent.lazy.Lazy#of(java.util.function.Supplier) Lazy.of(Supplier&lt;V&gt; presetSupplier)}</li>
+ *     
+ *     <li>(1B) {@link EmptyLazyReference} with e.g. {@link java.util.concurrent.lazy.EmptyLazyReference#apply(java.lang.Object) apply(Supplier&lt;V&gt; supplier)}<p>
+ *     available via {@link java.util.concurrent.lazy.Lazy#ofEmpty() Lazy.ofEmpty()}</li>
+ *
+ *     <li>(2A) {@link LazyArray} with e.g. {@link java.util.concurrent.lazy.LazyArray#apply(int) apply(int index)}<p>
+ *     available via {@link java.util.concurrent.lazy.Lazy#ofArray(int, java.util.function.IntFunction) Lazy.ofArray(int length, IntFunction&lt;V&gt; presetMapper)}</li>
+ *
+ *     <li>(2B) {@link EmptyLazyArray} with e.g. {@link java.util.concurrent.lazy.EmptyLazyArray#computeIfEmpty(int, java.util.function.IntFunction) computeIfEmpty(int index, IntFunction&lt;V&gt; mapper)}<p>
+ *     available via {@link java.util.concurrent.lazy.Lazy#ofEmptyArray(int) Lazy.ofEmptyArray(int length)}</li>
+ * </ul>
+ *
+ * Hence, the Array types provide an extra arity where the index is specified compared to the Reference types.
+ *
+ * <h2 id="lazy-factories">Lazy Factories</h2>
+ *
+ * As shown in the table above, instances of the many lazy types are obtained via the {@link java.util.concurrent.lazy.Lazy} class
+ * using factory methods and can also be obtained and configured via builders.
  *
  * <h3 id="lazyreference">LazyReference</h3>
  *
@@ -190,12 +223,28 @@
  * }
  *
  * Sometimes, there is a mapping from an {@code int} key to an index, preventing
- * the key to be used directly. For example, when caching only certain
- * values as shown below where we cache every 10th value:
+ * the key to be used directly. If there is a constant translation factor between index and
+ * actual keys, the {@linkplain java.util.concurrent.lazy.Lazy .ofEmptyTranslatedArray()} can be used.
+ * <p>
+ * For example, when caching oevery 10th Fibonacci value, the following snippet can be used:
  * {@snippet lang = java:
+ *         static int fib(int n) {
+ *             return (n <= 1)
+ *                     ? n
+ *                     : fib(n - 1) + fib(n - 2);
+ *         }
+ *
+ *         private static final EmptyLazyArray<Integer> FIB_10_CACHE =
+ *                 Lazy.ofEmptyTranslatedArray(3, 10);
  *
- *   // Todo: refactor how int mappers are obtained and show an example here.
  *
+ *         // Only works for values up to ~30
+ *
+ *         static int cachedFib(int n) {
+ *             if (n <= 1)
+ *                 return n;
+ *             return FIB_10_CACHE.computeIfEmpty(n, DemoFibMapped::fib);
+ *         }
  * }
  *
  * <h3 id="lazymapper">LazyMapper</h3>

From 6384e76e4d07dd7d6464ead1ce720a2a45622839 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 10:53:07 +0200
Subject: [PATCH 10/16] Fix sealed interfaces

---
 .../java/util/concurrent/lazy/BaseLazyArray.java       |  4 +++-
 .../java/util/concurrent/lazy/BaseLazyReference.java   |  7 ++++++-
 .../share/classes/java/util/concurrent/lazy/Lazy.java  | 10 +++-------
 .../java/util/concurrent/lazy/ObjectLayout.java        |  5 +++++
 .../concurrent/lazy/AbstractBaseLazyReference.java     |  5 +++--
 .../lazy/AbstractPreComputedLazyReference.java         |  5 +++--
 .../concurrent/lazy/array/AbstractBaseLazyArray.java   |  5 +++--
 7 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
index bd3a6f1bff7..3b1cd6dbe28 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
@@ -26,6 +26,7 @@
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.array.AbstractBaseLazyArray;
 import jdk.internal.util.concurrent.lazy.array.StandardEmptyLazyArray;
 
 import java.util.List;
@@ -44,7 +45,8 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public sealed interface BaseLazyArray<V> permits EmptyLazyArray, LazyArray {
+public sealed interface BaseLazyArray<V>
+        permits EmptyLazyArray, LazyArray, AbstractBaseLazyArray {
 
     /**
      * {@return the length of the array}.
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
index 14a76278083..a068e385d42 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
@@ -26,6 +26,10 @@
 package java.util.concurrent.lazy;
 
 import jdk.internal.javac.PreviewFeature;
+import jdk.internal.util.concurrent.lazy.AbstractBaseLazyReference;
+import jdk.internal.util.concurrent.lazy.AbstractPreComputedLazyReference;
+import jdk.internal.util.concurrent.lazy.PreComputedLazyReference;
+import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
 
 import java.util.NoSuchElementException;
 import java.util.Optional;
@@ -39,7 +43,8 @@
  * @since 22
  */
 @PreviewFeature(feature = PreviewFeature.Feature.LAZY)
-public sealed interface BaseLazyReference<V> permits EmptyLazyReference, LazyReference {
+public sealed interface BaseLazyReference<V>
+        permits EmptyLazyReference, LazyReference, AbstractBaseLazyReference, AbstractPreComputedLazyReference {
 
     /**
      * {@return The {@link Lazy.State } of this Lazy}.
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 6453131a570..259464754f6 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -44,8 +44,8 @@
 import java.util.function.Supplier;
 
 /**
- * This class provides common factories and builders classes for all
- * Lazy class variants.
+ * This class provides common factories and builders for all
+ * Lazy types.
  *
  * @since 22
  */
@@ -78,7 +78,7 @@ public enum State {
         /**
          * Indicates a value is being constructed but is not yet available.
          */
-        CONSTRUCTING, // Todo: Consider dropping this state
+        CONSTRUCTING,
         /**
          * Indicates a value is present. This is a <em>final state</em>.
          */
@@ -97,10 +97,6 @@ static boolean isFinal(State state) {
         }
     }
 
-    static final int EMPTY_ORDINAL = 0;
-    static final int PRESENT_ORDINAL = 2;
-    static final int ERROR_ORDINAL = 3;
-
     /**
      * The Evaluation indicates the erliest point at which a Lazy can be evaluated:
      * <ul>
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
index af1ec17b4ae..620e9abd1f7 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/ObjectLayout.java
@@ -30,6 +30,8 @@
 import jdk.internal.util.concurrent.lazy.PreComputedLazyReference;
 import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
 import jdk.internal.util.concurrent.lazy.StandardLazyReference;
+import jdk.internal.util.concurrent.lazy.array.StandardEmptyLazyArray;
+import jdk.internal.util.concurrent.lazy.array.StandardLazyArray;
 
 import java.lang.reflect.Modifier;
 import java.util.Arrays;
@@ -60,6 +62,9 @@ public static void main(String[] args) {
         analyze(StandardEmptyLazyReference.class);
         analyze(StandardLazyReference.class);
 
+        analyze(StandardLazyArray.class);
+        analyze(StandardEmptyLazyArray.class);
+
     }
 
     static void analyze(Class<?> c) {
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
index b6f2943f2a1..d15fec1316f 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
@@ -35,8 +35,9 @@
 import java.util.concurrent.lazy.BaseLazyReference;
 import java.util.concurrent.lazy.Lazy;
 
-public abstract class AbstractBaseLazyReference<V>
-        implements BaseLazyReference<V> {
+public abstract sealed class AbstractBaseLazyReference<V>
+        implements BaseLazyReference<V>
+        permits StandardEmptyLazyReference, StandardLazyReference {
 
     static final Unsafe UNSAFE = Unsafe.getUnsafe();
 
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
index 27e674ffe23..d271dcabf34 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
@@ -7,8 +7,9 @@
 import java.util.concurrent.lazy.Lazy;
 import java.util.function.Supplier;
 
-abstract class AbstractPreComputedLazyReference<V>
-        implements BaseLazyReference<V> {
+public abstract sealed class AbstractPreComputedLazyReference<V>
+        implements BaseLazyReference<V>
+        permits PreComputedLazyReference,  PreComputedEmptyLazyReference {
 
     final V value;
 
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
index 33a292a3bb4..2022f9bc229 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
@@ -51,8 +51,9 @@
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
-abstract class AbstractBaseLazyArray<V, L extends AbstractBaseLazyReference<V>>
-        implements BaseLazyArray<V> {
+public sealed abstract class AbstractBaseLazyArray<V, L extends AbstractBaseLazyReference<V>>
+        implements BaseLazyArray<V>
+        permits StandardEmptyLazyArray, StandardLazyArray, TranslatedEmptyLazyArray {
 
     private final LazyReference<ListView> listView = Lazy.of(ListView::new);
 

From e14ab56f0333661c977757e7851c153a0ea24050 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 13:28:27 +0200
Subject: [PATCH 11/16] Improve documentation

---
 .../util/concurrent/lazy/BaseLazyArray.java   | 14 ++--
 .../concurrent/lazy/BaseLazyReference.java    |  7 +-
 .../util/concurrent/lazy/EmptyLazyArray.java  | 12 ++--
 .../concurrent/lazy/EmptyLazyReference.java   |  2 +-
 .../java/util/concurrent/lazy/Lazy.java       | 69 ++++++++++---------
 .../java/util/concurrent/lazy/LazyArray.java  | 13 ++--
 .../util/concurrent/lazy/LazyReference.java   |  3 +-
 .../util/concurrent/lazy/package-info.java    | 64 ++++++++---------
 .../snippet-files/PackageInfoSnippets.java    | 31 +++++++--
 9 files changed, 124 insertions(+), 91 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
index 3b1cd6dbe28..cc843a954e2 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
@@ -54,7 +54,7 @@
     public int length();
 
     /**
-     * {@return The {@link State } of this Lazy}.
+     * {@return the {@link State State} of this Lazy}.
      * <p>
      * The value is a snapshot of the current State.
      * No attempt is made to compute a value if it is not already present.
@@ -70,6 +70,7 @@
      *     }
      *}
      * @param index to retrieve the State from
+     * @throws ArrayIndexOutOfBoundsException if {@code index< 0} or {@code index >= length()}
      */
     public State state(int index);
 
@@ -78,17 +79,20 @@
      * {@link Optional#empty()} if no exception was thrown}.
      *
      * @param index to retrieve the exception from
+     * @throws ArrayIndexOutOfBoundsException if {@code index< 0} or {@code index >= length()}
      */
     public Optional<Throwable> exception(int index);
 
     /**
-     * {@return the value at the provided {@code index} if the value is {@link State#PRESENT}
-     * or {@code defaultValue} if the value is {@link State#EMPTY} or {@link State#CONSTRUCTING}}.
+     * {@return the value at the provided {@code index} if the state is {@link State#PRESENT PRESENT}
+     * or {@code defaultValue} if the value is {@link State#EMPTY EMPTY} or
+     * {@link State#CONSTRUCTING CONSTRUCTING}}.
      *
      * @param index        for which the value shall be obtained.
      * @param defaultValue to use if no value is present
-     * @throws NoSuchElementException if a provider for the provided {@code index} has previously
-     *                                thrown an exception.
+     * @throws ArrayIndexOutOfBoundsException if {@code index< 0} or {@code index >= length()}
+     * @throws NoSuchElementException         if a provider for the provided {@code index} has previously
+     *                                        thrown an exception.
      */
     V getOr(int index, V defaultValue);
 
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
index a068e385d42..4c297639a7a 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
@@ -47,7 +47,7 @@
         permits EmptyLazyReference, LazyReference, AbstractBaseLazyReference, AbstractPreComputedLazyReference {
 
     /**
-     * {@return The {@link Lazy.State } of this Lazy}.
+     * {@return the {@link Lazy.State State} of this Lazy}.
      * <p>
      * The value is a snapshot of the current State.
      * No attempt is made to compute a value if it is not already present.
@@ -72,8 +72,9 @@
     public Optional<Throwable> exception();
 
     /**
-     * {@return the value if the value is {@link Lazy.State#PRESENT}
-     * or {@code defaultValue} if the value is {@link Lazy.State#EMPTY} or {@link Lazy.State#CONSTRUCTING}}.
+     * {@return the value if the state is {@link Lazy.State#PRESENT PRESENT}
+     * or {@code defaultValue} if the state is {@link Lazy.State#EMPTY EMPTY}
+     * or {@link Lazy.State#CONSTRUCTING CONSTRUCTING}}.
      *
      * @param defaultValue to use if no value is present
      * @throws NoSuchElementException if a provider has previously thrown an exception.
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
index 04d2eb554c5..d35f9c24022 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
@@ -47,10 +47,10 @@
 
     /**
      * Returns the present value at the provided {@code index} or, if no present value exists,
-     * atomically attempts to compute the value using the <em>provided {@code mappper}</em>.
+     * atomically attempts to compute the value using the provided {@code mappper}.
      *
-     * <p>If the mapper returns {@code null}, an exception is thrown.
-     * If the provided {@code ,mapper} itself throws an (unchecked) exception, the
+     * <p>If the mapper returns {@code null}, an exception is thrown.  If the
+     * provided {@code mapper} itself throws an (unchecked) exception, the
      * exception is rethrown, and no value is recorded.  The most
      * common usage is to construct a new object serving as a memoized result, as in:
      * <p>
@@ -67,9 +67,9 @@
      * @param index   to the slot to be used
      * @param mappper to apply if no previous value exists
      * @return the value (pre-existing or newly computed)
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
-     * @throws NullPointerException           if the provided {@code mappper} is {@code null}.
+     * @throws ArrayIndexOutOfBoundsException if {@code index < 0} or {@code index >= length()}
+     * @throws NullPointerException           if the provided {@code mappper} is {@code null} or if
+     *                                        the provided {@code mapper} itself returns {@code null}.
      * @throws NoSuchElementException         if a maper has previously thrown an exception for the
      *                                        provided {@code index}.
      */
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
index 1dd24ff3061..fdeace1ff72 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
@@ -47,7 +47,7 @@
 
     /**
      * Returns the present value or, if no present value exists, atomically attempts
-     * to compute the value using the <em>provided {@code supplier}</em>.
+     * to compute the value using the provided {@code supplier}.
      * <p>
      * If the provided {@code supplier} itself throws an (unchecked) exception, the
      * exception is rethrown, and no value is recorded.  The most
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 259464754f6..8bf3688ad7f 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -57,17 +57,20 @@ private Lazy() {
     }
 
     /**
-     * The State indicates the current state of a Lazy instance:
+     * The State indicates the current state of a Lazy instance.
+     * <p>
+     * The following values are supported:
      * <ul>
-     *     <li><a id="empty"><b>EMPTY</b></a>
-     *     <p> No value is present (initial state).</p></li>
-     *     <li><a id="constructing"><b>CONSTRUCTING</b></a>
+     *     <li><a id="empty"><b>{@link State#EMPTY}</b></a>
+     *     <p> No value is present (initial non-final state).</p></li>
+     *     <li><a id="constructing"><b>{@link State#CONSTRUCTING}</b></a>
      *     <p> A value is being constructed but the value is not yet available (transient state).</p></li>
-     *     <li><a id="present"><b>PRESENT</b></a>
+     *     <li><a id="present"><b>{@link State#PRESENT}</b></a>
      *     <p> A value is present and is available via an accessor (final state).</p></li>
-     *     <li><a id="error"><b>ERROR</b></a>
+     *     <li><a id="error"><b>{@link State#ERROR}</b></a>
      *     <p> The construction of tha value failed and a value will never be present (final state).
-     *     The error is available via an accessor for some implementations.</p></li>
+     *     The error is available via either the {@link BaseLazyReference#exception()} or
+     *     the {@link BaseLazyArray#exception(int)} accessor.</p></li>
      * </ul>
      */
     public enum State {
@@ -89,7 +92,7 @@ public enum State {
         ERROR;
 
         /**
-         * {@return if this state is final (e.g. can never change)}.
+         * {@return if this state is final (e.g. can no longer change)}.
          */
         static boolean isFinal(State state) {
             return state == PRESENT ||
@@ -98,16 +101,20 @@ static boolean isFinal(State state) {
     }
 
     /**
-     * The Evaluation indicates the erliest point at which a Lazy can be evaluated:
+     * The Evaluation indicates the erliest point at which a Lazy can be evaluated.
+     * <p>
+     * The following values are supported:
      * <ul>
-     *     <li><a id="compilation"><b>COMPILATION</b></a>
-     *     <p> The value can be evaluated at compile time.</p></li>
-     *     <li><a id="distillation"><b>DISTILLATION</b></a>
-     *     <p> The value can be evaluated at distillation time.</p></li>
-     *     <li><a id="creation"><b>CREATION</b></a>
-     *     <p> The value can be evaluated upon creating the Lazy (in another background thread).</p></li>
-     *     <li><a id="at-use"><b>AT_USE</b></a>
+     *     <li><a id="at-use"><b>{@link Evaluation#AT_USE}</b></a>
      *     <p> The value cannot be evaluated before being used (default evaluation).</p></li>
+     *     <li><a id="post-creation"><b>{@link Evaluation#POST_CREATION}</b></a>
+     *     <p> The value can be evaluated after the Lazy has been created (in another background thread).</p></li>
+     *     <li><a id="creation"><b>{@link Evaluation#CREATION}</b></a>
+     *     <p> The value can be evaluated upon creating the Lazy (in the same thread).</p></li>
+     *     <li><a id="distillation"><b>{@link Evaluation#DISTILLATION}</b></a>
+     *     <p> The value can be evaluated at distillation time.</p></li>
+     *     <li><a id="compilation"><b>{@link Evaluation#COMPILATION}</b></a>
+     *     <p> The value can be evaluated at compile time.</p></li>
      * </ul>
      */
     public enum Evaluation {
@@ -116,13 +123,13 @@ public enum Evaluation {
          */
         AT_USE,
         /**
-         * Indicates the value can be evaluated upon creating the Lazy (in the same thread)
+         * Indicates the value can be evaluated after the Lazy has been created (in another background thread).
          */
-        CREATION,
+        POST_CREATION,
         /**
-         * Indicates the value can be evaluated upon creating the Lazy (in another background thread)
+         * Indicates the value can be evaluated upon defining the Lazy (in the same thread).
          */
-        CREATION_BACKGROUND,
+        CREATION,
         /**
          * Indicates the value can be evaluated at distillation time.
          */
@@ -185,18 +192,18 @@ public static <V> LazyReference<V> of(Supplier<? extends V> presetSupplier) {
      *
      * @param <V> type of the value the EmptyLazyReference will handle.
      *            Here is how a lazy value can be pre-computed:
-     *            {@snippet lang = java:
-     *                           class DemoPrecomputed {
+     * {@snippet lang = java:
+     *      class DemoPrecomputed {
      *
-     *                               private static final EmptyLazyReference<Foo> lazy = Lazy.<Foo>emptyBuilder()
-     *                                       .withValue(new Foo())
-     *                                       .build();
+     *         private static final EmptyLazyReference<Foo> lazy = Lazy.<Foo>emptyBuilder()
+     *                 .withValue(new Foo())
+     *                 .build();
      *
-     *                               public static void main(String[] args) throws InterruptedException {
-     *                                   // lazy is already pre-computed here
-     *                                   System.out.println("lazy.apply(Foo::new) = " + lazy.apply(Foo::new));
-     *                               }
-     *                           }
+     *         public static void main(String[] args) throws InterruptedException {
+     *             // lazy is already pre-computed here
+     *             System.out.println("lazy.apply(Foo::new) = " + lazy.apply(Foo::new));
+     *         }
+     *     }
      *}
      */
     // Todo: Figure out a better way for determining the type (e.g. type token)
@@ -213,7 +220,7 @@ public static <V> EmptyLazyReference.Builder<V> emptyBuilder() {
      *     class DemoBackground {
      *
      *         private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
-     *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+     *                 .withEarliestEvaluation(Lazy.Evaluation.POST_CREATION)
      *                 .build();
      *
      *         public static void main(String[] args) throws InterruptedException {
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
index ab7940c59ea..550147c1d61 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyArray.java
@@ -33,9 +33,10 @@
 import java.util.function.Supplier;
 
 /**
- * A lazy references with a pre-set supplier...
+ * A lazy array with a pre-set supplier which will be invoken at most once,
+ * per slot, for example when {@link LazyArray#apply(int) apply(index)} is invoked.
  *
- * @param <V> The type of the value to be recorded
+ * @param <V> The type of the values to be recorded
  *
  * @since 22
  */
@@ -66,8 +67,7 @@
      *
      * @param index to the slot to be used
      * @return the value (pre-existing or newly computed)
-     * @throws ArrayIndexOutOfBoundsException if the provided {@code index} is {@code < 0}
-     *                                        or {@code index >= length()}
+     * @throws ArrayIndexOutOfBoundsException if {@code index< 0} or {@code index >= length()}
      * @throws IllegalStateException          if a value was not already present and no
      *                                        pre-set mapper was specified.
      * @throws NoSuchElementException         if a maper has previously thrown an exception for the
@@ -77,13 +77,12 @@
     public V apply(int index);
 
     /**
-     * Forces computation of all {@link java.util.concurrent.lazy.Lazy.State#EMPTY} slots in
+     * Forces computation of all {@link java.util.concurrent.lazy.Lazy.State#EMPTY EMPTY} slots in
      * slot order.
      * <p>
      * If the pre-set mapper throws an (unchecked) exception, the
-     * exception is rethrown, and no value is recorded. This means, subsequent slots
+     * exception is rethrown, and no value is recorded. This also means, subsequent slots
      * are not computed.
-     *
      */
     public void force();
 
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
index 7a4bbb2a38f..b41dca5e92f 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/LazyReference.java
@@ -33,7 +33,8 @@
 import java.util.function.Supplier;
 
 /**
- * A lazy references with a pre-set supplier...
+ * A lazy reference with a pre-set supplier which will be invoken at most once,
+ * for example when {@link LazyReference#get() get()} is invoked.
  *
  * @param <V> The type of the value to be recorded
  *
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index c6b36ed901a..5c92024af1c 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -24,19 +24,18 @@
  */
 
 /**
- * <h2 id="lazy">Lazy</h2>
- *
- * <p>
  * A small toolkit of classes supporting lock-free, thread-safe
- * use of lazily initialized values with superior performance.  Providers of
- * lazy values are guaranteed to be invoked at most one time.  This contrasts
+ * use of lazily initialized values and arrays with superior performance.  Providers
+ * of lazy values are guaranteed to be invoked at most one time.  This contrasts
  * to {@link java.util.concurrent.atomic.AtomicReferenceArray } where any number
  * of updates can be done and where there is no simple way to atomically compute
  * a value (guaranteed to only be computed once) if missing.
  * <p>
  * The lazy implementations are optimized for the case where there are N invocations
  * trying to obtain a value and where N >> 1, for example where N is > 2<sup>20</sup>.
- * <p>
+ *
+ *  <h2 id="lazy">Lazy</h2>
+ *
  * Lazy types are all generic with respect to the reference value of type V they compute and
  * come in four fundamental flavors grouped in two dimensions; "Element Capacity" and "Preprovidedness":
  * <h3 id="element-capacity">Element Capacity</h3>
@@ -65,7 +64,7 @@
  *     available via {@link java.util.concurrent.lazy.Lazy#ofEmptyArray(int) Lazy.ofEmptyArray(int length)}</li>
  * </ul>
  *
- * Hence, the Array types provide an extra arity where the index is specified compared to the Reference types.
+ * Hence, the Array type methods provide an extra arity where the index is specified compared to the Reference types.
  *
  * <h2 id="lazy-factories">Lazy Factories</h2>
  *
@@ -76,8 +75,6 @@
  *
  * In its simplest form, Lazy can provide atomic lazy evaluation using a <em>preset-supplier</em>:
  *
- * {@snippet class="PackageInfoSnippets" region="DemoPreset"}
- *
  * {@snippet lang = java:
  *     class DemoPreset {
  *
@@ -91,7 +88,7 @@
  *}
  * The performance of the example above is on pair with using an inner/private class
  * holding a lazily initialized variable but with no overhead imposed by the extra
- * class as illustraded hereunder:
+ * class. A corresponding private class is illustraded hereunder:
  *
  {@snippet lang = java :
  *     class DemoHolder {
@@ -129,7 +126,7 @@
  *     class DemoBackground {
  *
  *         private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
- *                 .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+ *                 .withEarliestEvaluation(Lazy.Evaluation.POST_CREATION)
  *                 .build();
  *
  *         public static void main(String[] args) throws InterruptedException {
@@ -226,8 +223,9 @@
  * the key to be used directly. If there is a constant translation factor between index and
  * actual keys, the {@linkplain java.util.concurrent.lazy.Lazy .ofEmptyTranslatedArray()} can be used.
  * <p>
- * For example, when caching oevery 10th Fibonacci value, the following snippet can be used:
+ * For example, when caching every 10th Fibonacci value, the following snippet can be used:
  * {@snippet lang = java:
+ *         // Un-cached fibonacci method
  *         static int fib(int n) {
  *             return (n <= 1)
  *                     ? n
@@ -235,11 +233,10 @@
  *         }
  *
  *         private static final EmptyLazyArray<Integer> FIB_10_CACHE =
- *                 Lazy.ofEmptyTranslatedArray(3, 10);
- *
+ *                 Lazy.ofEmptyTranslatedArray(5, 10);
  *
- *         // Only works for values up to ~30
  *
+ *         // Only works for values up to ~50 as the backing array is of length 5.
  *         static int cachedFib(int n) {
  *             if (n <= 1)
  *                 return n;
@@ -247,13 +244,13 @@
  *         }
  * }
  *
- * <h3 id="lazymapper">LazyMapper</h3>
+ * <h3 id="lazy-mapper">Lazy Mapper</h3>
  *
  * When several lazy values are to be held and accessible via keys of arbitrary
  * type {@code K}, general mappers can be obtained for any pre-given collection
- * of keys.  Even though this could be modeled by users via a second level of a
+ * of keys.  Even though this could be modeled directly by users via a second level of a
  * regular Java Map, special constructs are available providing equivalent
- * functionality but with potentially better performance and lower memory usage.
+ * functionality but with potentially better performance and lower memory usage:
  * {@snippet lang = java:
  *     class DemoLazyMapper {
  *
@@ -299,21 +296,24 @@
  *
  * All lazy constructs are "nullofobic" meaning a provider can never return {@code null}.  If nullablilty
  * for values stored are desired, the values have to be modeled using a construct that can express
- * {@code null} values in an explicit way such as {@link java.util.Optional#empty()}:
+ * {@code null} values in an explicit way such as {@link java.util.Optional#empty()} as exemplified here:
  * {@snippet lang = java:
- * import java.util.Optional;class NullDemo {
- *   private Supplier<Optional<Color>> backgroundColor =
- *           Lazy.of(() -> Optional.ofNullable(calculateBgColor()));
- *
- *   Color backgroundColor() {
- *       return backgroundColor.get()
- *                  .orElse("<unknown>");
- *    }
- *
- *   private Color calculateBgColor() {
- *       // Read background color from file returning "null" if it fails.
- *   }
- * }
+ *     class NullDemo {
+ *
+ *         private Supplier<Optional<Color>> backgroundColor =
+ *                 Lazy.of(() -> Optional.ofNullable(calculateBgColor()));
+ *
+ *         Color backgroundColor(Color defaultColor) {
+ *             return backgroundColor.get()
+ *                     .orElse(defaultColor);
+ *         }
+ *
+ *         private Color calculateBgColor() {
+ *             // Read background color from file returning "null" if it fails.
+ *             // ...
+ *             return null;
+ *         }
+ *     }
  *}
  *
  * @since 22
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
index 88ee614ac69..c867ce18127 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/snippet-files/PackageInfoSnippets.java
@@ -85,7 +85,7 @@ String init(String color) {
     class DemoBackground {
 
         private static final LazyReference<Foo> lazy = Lazy.builder(Foo::new)
-                .withEarliestEvaluation(Lazy.Evaluation.CREATION_BACKGROUND)
+                .withEarliestEvaluation(Lazy.Evaluation.POST_CREATION)
                 .build();
 
         public static void main(String[] args) throws InterruptedException {
@@ -96,7 +96,7 @@ public static void main(String[] args) throws InterruptedException {
     }
     // @end
 
-    // @start region="DemoBackground"
+    // @start region="DemoPrecomputed"
     class DemoPrecomputed {
 
         private static final EmptyLazyReference<Foo> lazy = Lazy.<Foo>emptyBuilder()
@@ -209,12 +209,34 @@ public String servePage(Request request) {
     }
     // @end
 
+    class NullDemo {
+
+        private Supplier<Optional<Color>> backgroundColor =
+                Lazy.of(() -> Optional.ofNullable(calculateBgColor()));
+
+        Color backgroundColor(Color defaultColor) {
+            return backgroundColor.get()
+                    .orElse(defaultColor);
+        }
+
+        private Color calculateBgColor() {
+            // Read background color from file returning "null" if it fails.
+            // ...
+            return null;
+        }
+    }
+
+    private static final class Color{}
+
+
     // @start region="DemoFibMapped"
     final class DemoFibMapped {
 
         // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 ...
         // fib(11) = 89
         // n non-negative
+
+        // Un-cached fibonacci method
         static int fib(int n) {
             return (n <= 1)
                     ? n
@@ -222,11 +244,10 @@ static int fib(int n) {
         }
 
         private static final EmptyLazyArray<Integer> FIB_10_CACHE =
-                Lazy.ofEmptyTranslatedArray(3, 10);
-
+                Lazy.ofEmptyTranslatedArray(5, 10);
 
-        // Only works for values up to ~30
 
+        // Only works for values up to ~50 as the backing array is of length 5.
         static int cachedFib(int n) {
             if (n <= 1)
                 return n;

From e6eac21ccbf57b592160f8e65c6b92a2a9c9e172 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 14:05:30 +0200
Subject: [PATCH 12/16] Add benchmark for LazyReference

---
 .../util/concurrent/LazyReferenceBench.java   | 315 ++++++++++++++++++
 1 file changed, 315 insertions(+)
 create mode 100644 test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java

diff --git a/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java b/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java
new file mode 100644
index 00000000000..54d7f28adc1
--- /dev/null
+++ b/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.bench.java.util.concurrent;
+
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.BenchmarkMode;
+import org.openjdk.jmh.annotations.Fork;
+import org.openjdk.jmh.annotations.Level;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Mode;
+import org.openjdk.jmh.annotations.OperationsPerInvocation;
+import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.Warmup;
+import org.openjdk.jmh.infra.Blackhole;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.lazy.Lazy;
+import java.util.function.Supplier;
+
+@BenchmarkMode(Mode.AverageTime)
+@OutputTimeUnit(TimeUnit.NANOSECONDS)
+@State(Scope.Benchmark)
+@Warmup(iterations = 5, time = 1)
+@Measurement(iterations = 5, time = 1)
+@Fork(value=3, jvmArgsAppend = "--enable-preview")
+public class LazyReferenceBench {
+
+    private static final Supplier<Integer> SUPPLIER = () -> 2 << 16;
+
+    public static final Supplier<Integer> LAZY = Lazy.of(SUPPLIER);
+    public static final Supplier<Integer> LAZY_DC = new VolatileDoubleChecked<>(SUPPLIER);
+
+    // Add chain
+
+    public Supplier<Integer> lazy;
+
+    public Supplier<Integer> threadUnsafe;
+    public Supplier<Integer> volatileDoubleChecked;
+    public Supplier<Integer> volatileVhDoubleChecked;
+
+    public Supplier<Integer> acquireReleaseDoubleChecked;
+    public Supplier<Integer> delegated;
+
+    /**
+     * The test variables are allocated every iteration so you can assume
+     * they are initialized to get similar behaviour across iterations
+     */
+    @Setup(Level.Iteration)
+    public void setupIteration() {
+        lazy = Lazy.of(SUPPLIER);
+        threadUnsafe = new ThreadUnsafe<>(SUPPLIER);
+        volatileDoubleChecked = new VolatileDoubleChecked<>(SUPPLIER);
+        volatileVhDoubleChecked = new VolatileVhDoubleChecked<>(SUPPLIER);
+        acquireReleaseDoubleChecked = new AquireReleaseDoubleChecked<>(SUPPLIER);
+        delegated = new DelegatorLazy<>(SUPPLIER);
+    }
+
+    @Benchmark
+    public void staticLazyRef(Blackhole bh) {
+        bh.consume(LAZY.get());
+    }
+
+    @Benchmark
+    public void staticLocalClass(Blackhole bh) {
+        class Lazy {
+            private static final int INT = SUPPLIER.get();
+        }
+        bh.consume(Lazy.INT);
+    }
+
+    @Benchmark
+    public void staticVolatileDoubleChecked(Blackhole bh) {
+        bh.consume(LAZY_DC.get());
+    }
+
+    @Benchmark
+    public void lazyRef(Blackhole bh) {
+        bh.consume(lazy.get());
+    }
+
+    @Benchmark
+    public void lazyRefBlackHole(Blackhole bh) {
+        bh.consume(lazy.get());
+    }
+
+    @Benchmark
+    public void threadUnsafe(Blackhole bh) {
+        bh.consume(threadUnsafe.get());
+    }
+
+    @Benchmark
+    public void volatileDoubleChecked(Blackhole bh) {
+        bh.consume(volatileDoubleChecked.get());
+    }
+    @Benchmark
+    public void volatileVhDoubleChecked(Blackhole bh) {
+        bh.consume(volatileVhDoubleChecked.get());
+    }
+
+    @Benchmark
+    public void acquireReleaseDoubleChecked(Blackhole bh) {
+        bh.consume(acquireReleaseDoubleChecked.get());
+    }
+
+    @Benchmark
+    public void delegated(Blackhole bh) {
+        bh.consume(delegated.get());
+    }
+
+    private static final class ThreadUnsafe<T> implements Supplier<T> {
+
+        private Supplier<? extends T> supplier;
+
+        private T value;
+
+        public ThreadUnsafe(Supplier<? extends T> supplier) {
+            this.supplier = supplier;
+        }
+
+        @Override
+        public T get() {
+            if (value == null) {
+                value = supplier.get();
+                supplier = null;
+            }
+            return value;
+        }
+    }
+
+
+    private static final class DelegatorLazy<T> implements Supplier<T> {
+
+        private final Supplier<T> original;
+
+        public DelegatorLazy(Supplier<T> supplier) {
+            this.original = Objects.requireNonNull(supplier);
+        }
+
+        Supplier<T> delegate = this::firstTime;
+        boolean initialized;
+
+        public T get() {
+            return delegate.get();
+        }
+
+        private synchronized T firstTime() {
+            if (!initialized) {
+                T value = original.get();
+                delegate = () -> value;
+                initialized = true;
+            }
+            return delegate.get();
+        }
+    }
+
+    private static final class VolatileDoubleChecked<T> implements Supplier<T> {
+
+        private Supplier<? extends T> supplier;
+
+        private volatile T value;
+
+        public VolatileDoubleChecked(Supplier<? extends T> supplier) {
+            this.supplier = supplier;
+        }
+
+        @Override
+        public T get() {
+            T v = value;
+            if (v == null) {
+                synchronized (this) {
+                    v = value;
+                    if (v == null) {
+                        v = supplier.get();
+                        if (v == null) {
+                            throw new NullPointerException();
+                        }
+                        value = v;
+                        supplier = null;
+                    }
+                }
+            }
+            return v;
+        }
+    }
+
+    private static final class VolatileVhDoubleChecked<T> implements Supplier<T> {
+
+        private Supplier<? extends T> supplier;
+
+        private T value;
+
+        static final VarHandle VALUE_VH;
+
+        static {
+            try {
+                VALUE_VH = MethodHandles.lookup()
+                        .findVarHandle(VolatileVhDoubleChecked.class, "value", Object.class);
+            } catch (ReflectiveOperationException e) {
+                throw new ExceptionInInitializerError(e);
+            }
+        }
+
+        public VolatileVhDoubleChecked(Supplier<? extends T> supplier) {
+            this.supplier = supplier;
+        }
+
+        @Override
+        public T get() {
+            T v = getVolatile();
+            if (v == null) {
+                synchronized (this) {
+                    v = getVolatile();
+                    if (v == null) {
+                        v = supplier.get();
+                        if (v == null) {
+                            throw new NullPointerException();
+                        }
+                        setVolatile(v);
+                        supplier = null;
+                    }
+                }
+            }
+            return v;
+        }
+
+        T getVolatile() {
+            return (T) VALUE_VH.getVolatile(this);
+        }
+
+        void setVolatile(Object value) {
+            VALUE_VH.setVolatile(this, value);
+        }
+
+    }
+
+    private static final class AquireReleaseDoubleChecked<T> implements Supplier<T> {
+
+        private Supplier<? extends T> supplier;
+
+        private Object value;
+
+        static final VarHandle VALUE_VH;
+
+        static {
+            try {
+                VALUE_VH = MethodHandles.lookup()
+                        .findVarHandle(AquireReleaseDoubleChecked.class, "value", Object.class);
+            } catch (ReflectiveOperationException e) {
+                throw new ExceptionInInitializerError(e);
+            }
+        }
+
+        public AquireReleaseDoubleChecked(Supplier<? extends T> supplier) {
+            this.supplier = supplier;
+        }
+
+        @Override
+        public T get() {
+            T value = getAcquire();
+            if (value == null) {
+                synchronized (this) {
+                    value = getAcquire();
+                    if (value == null) {
+                        if (supplier == null) {
+                            throw new IllegalArgumentException("No pre-set supplier specified.");
+                        }
+                        value = supplier.get();
+                        if (value == null) {
+                            throw new NullPointerException("The supplier returned null: " + supplier);
+                        }
+                        setRelease(value);
+                        supplier = null;
+                    }
+                }
+            }
+            return value;
+        }
+
+        T getAcquire() {
+            return (T) VALUE_VH.getAcquire(this);
+        }
+
+        void setRelease(Object value) {
+            VALUE_VH.setRelease(this, value);
+        }
+
+    }
+
+}

From 13a693dcd8da607d8d75bef1c18a39c53a70ec3a Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 14:20:34 +0200
Subject: [PATCH 13/16] Improve docs

---
 .../share/classes/java/util/concurrent/lazy/BaseLazyArray.java | 3 ++-
 .../classes/java/util/concurrent/lazy/BaseLazyReference.java   | 3 ++-
 .../classes/java/util/concurrent/lazy/EmptyLazyArray.java      | 2 +-
 .../classes/java/util/concurrent/lazy/EmptyLazyReference.java  | 2 +-
 .../share/classes/java/util/concurrent/lazy/package-info.java  | 3 ++-
 5 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
index cc843a954e2..2652c3af2bd 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyArray.java
@@ -37,7 +37,8 @@
 import java.util.stream.Stream;
 
 /**
- * Base interface for lazy reference arrays , which are ... // Todo: write more here
+ * Base interface for lazy reference arrays, which contains metods
+ * common to all lazy array types.
  *
  * @param <V> The type of values to be recorded
  *
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
index 4c297639a7a..cafcb315eed 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/BaseLazyReference.java
@@ -35,7 +35,8 @@
 import java.util.Optional;
 
 /**
- * Base interface for lazy references , which are ... // Todo: write more here
+ * Base interface for lazy references, which contains metods
+ * common to all lazy reference types.
  *
  * @param <V> The type of the value to be recorded
  *
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
index d35f9c24022..96ee2c6c630 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyArray.java
@@ -34,7 +34,7 @@
 import java.util.function.IntFunction;
 
 /**
- * An empty lazy references with no pre-set supplier...
+ * An empty lazy array with no pre-set provider.
  *
  * @param <V> The type of the value to be recorded
  *
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
index fdeace1ff72..a3195257faa 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/EmptyLazyReference.java
@@ -34,7 +34,7 @@
 import java.util.function.Supplier;
 
 /**
- * An empty lazy references has no pre-set supplier...
+ * An empty lazy reference whith no pre-set provider.
  *
  * @param <V> The type of the value to be recorded
  *
diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index 5c92024af1c..25363e55553 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -106,7 +106,8 @@
  *
  * On some occasions, a preset-supplier might not be known a priori or the
  * lazy value to compute might depend on values not known at declaration time.  In
- * such cases, an empty LazyReference can be obtained and used as exemplified below:
+ * such cases, an {@link java.util.concurrent.lazy.EmptyLazyReference EmptyLazyReference} can be obtained
+ * and used as exemplified below:
  * {@snippet lang = java:
  *     class Fox {
  *

From a39e27d8ebdf16e2b1d512c8845546cdda594ae6 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 14:52:34 +0200
Subject: [PATCH 14/16] Improve docs

---
 .../java/util/concurrent/lazy/Lazy.java       | 20 +++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
index 8bf3688ad7f..7a3626c9c97 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/Lazy.java
@@ -271,19 +271,19 @@ public static <V> EmptyLazyArray<V> ofEmptyArray(int size) {
      * <p>
      * Below, an example of how to cache values in an array is shown:
      * {@snippet lang = java:
-     * class DemoArray {
+     *     class DemoArray {
      *
-     * private static final LazyArray<Value> VALUE_PO2_CACHE =
-     * Lazy.ofArray(32, index -> new Value(1L << index));
+     *         private static final LazyArray<Value> VALUE_PO2_CACHE =
+     *                 Lazy.ofArray(32, index -> new Value(1L << index));
      *
-     * public Value powerOfTwoValue(int n) {
-     * if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
-     * throw new IllegalArgumentException(Integer.toString(n));
-     * }
+     *         public Value powerOfTwoValue(int n) {
+     *             if (n < 0 || n >= VALUE_PO2_CACHE.length()) {
+     *                 throw new IllegalArgumentException(Integer.toString(n));
+     *             }
      *
-     * return VALUE_PO2_CACHE.apply(n);
-     * }
-     * }
+     *             return VALUE_PO2_CACHE.apply(n);
+     *         }
+     *     }
      *}
      *
      * @param <V>          The type of the values

From 05af378cc18403735b148509efe9488ca56e1abc Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 15:14:50 +0200
Subject: [PATCH 15/16] Add copyright messages and clean up

---
 .../util/concurrent/lazy/package-info.java    |  2 +-
 .../jdk/internal/javac/PreviewFeature.java    |  2 +-
 .../classes/jdk/internal/misc/Unsafe.java     | 18 -------------
 .../util/concurrent/lazy/AbstractMapper.java  | 25 +++++++++++++++++++
 .../AbstractPreComputedLazyReference.java     | 25 +++++++++++++++++++
 .../util/concurrent/lazy/LazyMapper.java      | 25 +++++++++++++++++++
 .../concurrent/lazy/LazySingleMapper.java     | 25 +++++++++++++++++++
 .../util/concurrent/lazy/LazyUtil.java        | 25 +++++++++++++++++++
 .../lazy/PreComputedEmptyLazyReference.java   | 25 +++++++++++++++++++
 .../lazy/PreComputedLazyReference.java        | 25 +++++++++++++++++++
 .../lazy/StandardEmptyLazyReference.java      | 25 +++++++++++++++++++
 .../StandardEmptyLazyReferenceBuilder.java    | 25 +++++++++++++++++++
 .../concurrent/lazy/StandardKeyMapper.java    | 25 +++++++++++++++++++
 .../lazy/StandardLazyReference.java           | 25 +++++++++++++++++++
 .../lazy/StandardLazyReferenceBuilder.java    | 25 +++++++++++++++++++
 .../lazy/array/StandardEmptyLazyArray.java    | 25 +++++++++++++++++++
 .../lazy/array/StandardLazyArray.java         | 25 +++++++++++++++++++
 .../lazy/array/TranslatedEmptyLazyArray.java  | 25 +++++++++++++++++++
 .../util/concurrent/LazyReferenceBench.java   |  1 +
 19 files changed, 378 insertions(+), 20 deletions(-)

diff --git a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
index 25363e55553..7aa8493022c 100644
--- a/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
+++ b/src/java.base/share/classes/java/util/concurrent/lazy/package-info.java
@@ -53,7 +53,7 @@
  * <ul>
  *     <li>(1A) {@link LazyReference} with e.g. {@link java.util.concurrent.lazy.LazyReference#get() get()}<p>
  *     available via {@link java.util.concurrent.lazy.Lazy#of(java.util.function.Supplier) Lazy.of(Supplier&lt;V&gt; presetSupplier)}</li>
- *     
+ *
  *     <li>(1B) {@link EmptyLazyReference} with e.g. {@link java.util.concurrent.lazy.EmptyLazyReference#apply(java.lang.Object) apply(Supplier&lt;V&gt; supplier)}<p>
  *     available via {@link java.util.concurrent.lazy.Lazy#ofEmpty() Lazy.ofEmpty()}</li>
  *
diff --git a/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java b/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
index d3ee061a090..186692a850d 100644
--- a/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
+++ b/src/java.base/share/classes/jdk/internal/javac/PreviewFeature.java
@@ -72,7 +72,7 @@ public enum Feature {
         VIRTUAL_THREADS,
         @JEP(number=434, title="Foreign Function & Memory API", status="Second Preview")
         FOREIGN,
-        // JEP TBI
+        // JEP number TBD
         @JEP(number=-1, title="Lazy Initialization", status="First Preview")
         LAZY,
         /**
diff --git a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
index f022357fc4d..47e8bf80c50 100644
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -3861,24 +3861,6 @@ public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
         }
     }
 
-    /** The offset in the object header to the lock flags */
-    private static final int LOCK_OFFSET = ADDRESS_SIZE == 8 ? 4 : 0;
-
-    /**
-     * {@return {@code true} if the provided Object is locked
-     * by a Thread using {@code synchronized}}.
-     *
-     * @param o Object to check if locked
-     * @see src/hotspot/share/oops/markWord.hpp
-     */
-    @ForceInline
-    public boolean isLocked(Object o) {
-        // 0x03 is the mask for the two lock bits ("lock_mask_in_place" in markWord.hpp)
-        // 0x01 is the value for "unlocked_value" in markWord.hpp
-        // Todo: make this method intrinsic in vmIntrinsics.hpp calling markWord::is_locked
-        return (getIntVolatile(o, LOCK_OFFSET) & 0x03) == 0x01; // ??
-    }
-
     // The following deprecated methods are used by JSR 166.
 
     @Deprecated(since="12", forRemoval=true)
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
index cc4c06c0744..1eb8b8d1772 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractMapper.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Map;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
index d271dcabf34..903d7d661ac 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractPreComputedLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Objects;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
index b4c5857b7bc..749f491f6e1 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyMapper.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Collection;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
index fcc129d9917..637b3e668f4 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazySingleMapper.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Collection;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
index b16fe8d21f7..fdcfdb1e599 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/LazyUtil.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.lang.invoke.MethodHandles;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
index c2e4cfa7c8a..2e4b2ef0b14 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedEmptyLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Objects;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
index cf8f2b608b9..71d10824af1 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/PreComputedLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.NoSuchElementException;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
index b5c692d3e49..e3ea0eed2cb 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.NoSuchElementException;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
index 0ce8a61ec8f..8475cb49e7d 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardEmptyLazyReferenceBuilder.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Objects;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java
index 7bcc075f42e..344cedae3c6 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardKeyMapper.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.concurrent.lazy.KeyMapper;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
index a30f1859b77..df7ed2e8f69 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReference.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.NoSuchElementException;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
index 57e4fee44eb..20ff681996c 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/StandardLazyReferenceBuilder.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy;
 
 import java.util.Objects;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
index 675d4c81f99..509a6a677d1 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardEmptyLazyArray.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy.array;
 
 import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
index 272ba685ac9..2ea8d143627 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/StandardLazyArray.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy.array;
 
 import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java
index eab1e4deee6..b65ff3c1a0e 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/TranslatedEmptyLazyArray.java
@@ -1,3 +1,28 @@
+/*
+ * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
 package jdk.internal.util.concurrent.lazy.array;
 
 import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
diff --git a/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java b/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java
index 54d7f28adc1..9933fd8cfa1 100644
--- a/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java
+++ b/test/micro/org/openjdk/bench/java/util/concurrent/LazyReferenceBench.java
@@ -20,6 +20,7 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+
 package org.openjdk.bench.java.util.concurrent;
 
 import org.openjdk.jmh.annotations.Benchmark;

From 4d39b101345c9aa63431380b3f6b640dca349732 Mon Sep 17 00:00:00 2001
From: Per Minborg <pminborg@gmail.com>
Date: Wed, 19 Apr 2023 15:30:11 +0200
Subject: [PATCH 16/16] Remove Unsafe use

---
 .../util/concurrent/lazy/AbstractBaseLazyReference.java        | 3 ---
 .../util/concurrent/lazy/array/AbstractBaseLazyArray.java      | 1 -
 2 files changed, 4 deletions(-)

diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
index d15fec1316f..7c3c014e3b3 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/AbstractBaseLazyReference.java
@@ -24,7 +24,6 @@
  */
 package jdk.internal.util.concurrent.lazy;
 
-import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.Stable;
 
 import java.lang.invoke.MethodHandles;
@@ -39,8 +38,6 @@
         implements BaseLazyReference<V>
         permits StandardEmptyLazyReference, StandardLazyReference {
 
-    static final Unsafe UNSAFE = Unsafe.getUnsafe();
-
     // Allows access to the "value" field with arbitary memory semantics
     static final VarHandle VALUE_HANDLE;
 
diff --git a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
index 2022f9bc229..7968ceeb604 100644
--- a/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
+++ b/src/java.base/share/classes/jdk/internal/util/concurrent/lazy/array/AbstractBaseLazyArray.java
@@ -24,7 +24,6 @@
  */
 package jdk.internal.util.concurrent.lazy.array;
 
-import jdk.internal.misc.Unsafe;
 import jdk.internal.util.concurrent.lazy.AbstractBaseLazyReference;
 import jdk.internal.util.concurrent.lazy.StandardEmptyLazyReference;
 import jdk.internal.vm.annotation.Stable;
