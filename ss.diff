diff --git a/src/java.base/share/classes/java/io/Console.java b/src/java.base/share/classes/java/io/Console.java
index 96df4c5fd24..c0ab44a459a 100644
--- a/src/java.base/share/classes/java/io/Console.java
+++ b/src/java.base/share/classes/java/io/Console.java
@@ -564,7 +564,7 @@ private static UnsupportedOperationException newUnsupportedOperationException()
     private static final Console cons = instantiateConsole();
     static {
         // Set up JavaIOAccess in SharedSecrets
-        SharedSecrets.setJavaIOAccess(new JavaIOAccess() {
+        SharedSecrets.set(JavaIOAccess.class, new JavaIOAccess() {
             public Console console() {
                 return cons;
             }
diff --git a/src/java.base/share/classes/java/io/DataInputStream.java b/src/java.base/share/classes/java/io/DataInputStream.java
index e019589ac61..feac36e93fb 100644
--- a/src/java.base/share/classes/java/io/DataInputStream.java
+++ b/src/java.base/share/classes/java/io/DataInputStream.java
@@ -49,7 +49,7 @@
  * @since   1.0
  */
 public class DataInputStream extends FilterInputStream implements DataInput {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
     private static final char[] EMPTY_CHAR_ARRAY = new char[0];
diff --git a/src/java.base/share/classes/java/io/DataOutputStream.java b/src/java.base/share/classes/java/io/DataOutputStream.java
index 2a0a7526591..9998f2a27d1 100644
--- a/src/java.base/share/classes/java/io/DataOutputStream.java
+++ b/src/java.base/share/classes/java/io/DataOutputStream.java
@@ -52,7 +52,7 @@
  * @since   1.0
  */
 public class DataOutputStream extends FilterOutputStream implements DataOutput {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * The number of bytes written to the data output stream so far.
diff --git a/src/java.base/share/classes/java/io/DeleteOnExitHook.java b/src/java.base/share/classes/java/io/DeleteOnExitHook.java
index 5c0b9dd1666..201cff4ec59 100644
--- a/src/java.base/share/classes/java/io/DeleteOnExitHook.java
+++ b/src/java.base/share/classes/java/io/DeleteOnExitHook.java
@@ -26,6 +26,7 @@
 
 import java.util.*;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -42,7 +43,7 @@ class DeleteOnExitHook {
         // delete-on-exit list and cause the DeleteOnExitHook to be
         // registered during shutdown in progress. So set the
         // registerShutdownInProgress parameter to true.
-        SharedSecrets.getJavaLangAccess()
+        SharedSecrets.get(JavaLangAccess.class)
             .registerShutdownHook(2 /* Shutdown hook invocation order */,
                 true /* register even if shutdown in progress */,
                 new Runnable() {
diff --git a/src/java.base/share/classes/java/io/FileCleanable.java b/src/java.base/share/classes/java/io/FileCleanable.java
index 2e09efcaf81..b8e80676594 100644
--- a/src/java.base/share/classes/java/io/FileCleanable.java
+++ b/src/java.base/share/classes/java/io/FileCleanable.java
@@ -47,7 +47,7 @@ final class FileCleanable extends PhantomCleanable<FileDescriptor> {
     // Access to FileDescriptor private fields;
     // avoids making fd and handle package private
     private static final JavaIOFileDescriptorAccess fdAccess =
-            SharedSecrets.getJavaIOFileDescriptorAccess();
+            SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     /*
      * Raw close of the file fd and/or handle.
diff --git a/src/java.base/share/classes/java/io/FileDescriptor.java b/src/java.base/share/classes/java/io/FileDescriptor.java
index f6466f56eab..26368910332 100644
--- a/src/java.base/share/classes/java/io/FileDescriptor.java
+++ b/src/java.base/share/classes/java/io/FileDescriptor.java
@@ -67,7 +67,7 @@ public final class FileDescriptor {
 
     // Set up JavaIOFileDescriptorAccess in SharedSecrets
     static {
-        SharedSecrets.setJavaIOFileDescriptorAccess(
+        SharedSecrets.set(JavaIOFileDescriptorAccess.class,
                 new JavaIOFileDescriptorAccess() {
                     public void set(FileDescriptor fdo, int fd) {
                         fdo.set(fd);
diff --git a/src/java.base/share/classes/java/io/FileOutputStream.java b/src/java.base/share/classes/java/io/FileOutputStream.java
index 022aa44397a..758358c7962 100644
--- a/src/java.base/share/classes/java/io/FileOutputStream.java
+++ b/src/java.base/share/classes/java/io/FileOutputStream.java
@@ -67,7 +67,7 @@ public class FileOutputStream extends OutputStream
      * Access to FileDescriptor internals.
      */
     private static final JavaIOFileDescriptorAccess FD_ACCESS =
-        SharedSecrets.getJavaIOFileDescriptorAccess();
+        SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     /**
      * Flag set by jdk.internal.event.JFRTracing to indicate if
diff --git a/src/java.base/share/classes/java/io/ObjectInputFilter.java b/src/java.base/share/classes/java/io/ObjectInputFilter.java
index 9232111de07..116d20003c9 100644
--- a/src/java.base/share/classes/java/io/ObjectInputFilter.java
+++ b/src/java.base/share/classes/java/io/ObjectInputFilter.java
@@ -25,6 +25,7 @@
 
 package java.io;
 
+import jdk.internal.access.JavaObjectInputFilterAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.StaticProperty;
 
@@ -687,7 +688,7 @@ final class Config {
             }
             invalidFactoryMessage = factoryMessage;
             // Setup shared secrets for RegistryImpl to use.
-            SharedSecrets.setJavaObjectInputFilterAccess(Config::createFilter2);
+            SharedSecrets.set(JavaObjectInputFilterAccess.class, Config::createFilter2);
         }
 
         /**
diff --git a/src/java.base/share/classes/java/io/ObjectInputStream.java b/src/java.base/share/classes/java/io/ObjectInputStream.java
index daed5f3cce5..35d5aca22f8 100644
--- a/src/java.base/share/classes/java/io/ObjectInputStream.java
+++ b/src/java.base/share/classes/java/io/ObjectInputStream.java
@@ -38,6 +38,8 @@
 import java.util.Objects;
 
 import jdk.internal.access.JavaLangAccess;
+import jdk.internal.access.JavaObjectInputStreamAccess;
+import jdk.internal.access.JavaObjectInputStreamReadString;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.event.DeserializationEvent;
 import jdk.internal.misc.Unsafe;
@@ -2851,7 +2853,7 @@ private class BlockDataInputStream
         /** readBlockHeader() return value indicating header read may block */
         private static final int HEADER_BLOCKED = -2;
         /** access to internal methods to count ASCII and inflate latin1/ASCII bytes to char */
-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+        private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
         /** buffer for reading general/block data */
         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
@@ -4036,8 +4038,8 @@ private static Object cloneArray(Object array) {
     }
 
     static {
-        SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
-        SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
+        SharedSecrets.set(JavaObjectInputStreamAccess.class, ObjectInputStream::checkArray);
+        SharedSecrets.set(JavaObjectInputStreamReadString.class, ObjectInputStream::readString);
     }
 
 }
diff --git a/src/java.base/share/classes/java/io/ObjectOutputStream.java b/src/java.base/share/classes/java/io/ObjectOutputStream.java
index 40777ca1587..b5fb9f4cbfc 100644
--- a/src/java.base/share/classes/java/io/ObjectOutputStream.java
+++ b/src/java.base/share/classes/java/io/ObjectOutputStream.java
@@ -174,7 +174,7 @@
 public class ObjectOutputStream
     extends OutputStream implements ObjectOutput, ObjectStreamConstants
 {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /** filter stream for handling block data conversion */
     private final BlockDataOutputStream bout;
diff --git a/src/java.base/share/classes/java/io/ObjectStreamReflection.java b/src/java.base/share/classes/java/io/ObjectStreamReflection.java
index 35c7019419c..06d0abdff14 100644
--- a/src/java.base/share/classes/java/io/ObjectStreamReflection.java
+++ b/src/java.base/share/classes/java/io/ObjectStreamReflection.java
@@ -149,7 +149,7 @@ private static void defaultWriteObject(ObjectStreamClass streamClass, Object obj
 
     static final class Access implements JavaObjectStreamReflectionAccess {
         static {
-            SharedSecrets.setJavaObjectStreamReflectionAccess(new Access());
+            SharedSecrets.set(JavaObjectStreamReflectionAccess.class, new Access());
         }
 
         public MethodHandle defaultReadObject(Class<?> clazz) {
diff --git a/src/java.base/share/classes/java/io/RandomAccessFile.java b/src/java.base/share/classes/java/io/RandomAccessFile.java
index a7aa3ea358b..3b6a5841852 100644
--- a/src/java.base/share/classes/java/io/RandomAccessFile.java
+++ b/src/java.base/share/classes/java/io/RandomAccessFile.java
@@ -1269,7 +1269,7 @@ public final void writeUTF(String str) throws IOException {
 
     static {
         initIDs();
-        SharedSecrets.setJavaIORandomAccessFileAccess(new JavaIORandomAccessFileAccess()
+        SharedSecrets.set(JavaIORandomAccessFileAccess.class, new JavaIORandomAccessFileAccess()
         {
             // This is for j.u.z.ZipFile.OPEN_DELETE. The O_TEMPORARY flag
             // is only implemented/supported on Windows.
diff --git a/src/java.base/share/classes/java/lang/ClassFrameInfo.java b/src/java.base/share/classes/java/lang/ClassFrameInfo.java
index 1c0f6011a75..6d00d61fd49 100644
--- a/src/java.base/share/classes/java/lang/ClassFrameInfo.java
+++ b/src/java.base/share/classes/java/lang/ClassFrameInfo.java
@@ -38,7 +38,7 @@
  * @see StackWalker.Option#DROP_METHOD_INFO
  */
 class ClassFrameInfo implements StackFrame {
-    static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
+    static final JavaLangInvokeAccess JLIA = SharedSecrets.get(JavaLangInvokeAccess.class);
 
     Object classOrMemberName;    // Class or ResolvedMemberName initialized by VM
     int flags;                   // updated by VM to set hidden and caller-sensitive bits
diff --git a/src/java.base/share/classes/java/lang/Runtime.java b/src/java.base/share/classes/java/lang/Runtime.java
index 6f44114e533..1e85e01025b 100644
--- a/src/java.base/share/classes/java/lang/Runtime.java
+++ b/src/java.base/share/classes/java/lang/Runtime.java
@@ -35,6 +35,7 @@
 import java.util.Optional;
 import java.util.StringTokenizer;
 
+import jdk.internal.access.JavaLangRefAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.javac.Restricted;
 import jdk.internal.reflect.CallerSensitive;
@@ -709,7 +710,7 @@ public Process exec(String[] cmdarray, String[] envp, File dir)
      */
     @Deprecated(since="18", forRemoval=true)
     public void runFinalization() {
-        SharedSecrets.getJavaLangRefAccess().runFinalization();
+        SharedSecrets.get(JavaLangRefAccess.class).runFinalization();
     }
 
     /**
diff --git a/src/java.base/share/classes/java/lang/System.java b/src/java.base/share/classes/java/lang/System.java
index 5c2b47afe3d..6ad2dcf58a7 100644
--- a/src/java.base/share/classes/java/lang/System.java
+++ b/src/java.base/share/classes/java/lang/System.java
@@ -47,18 +47,14 @@
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.security.ProtectionDomain;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Properties;
-import java.util.ResourceBundle;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.Executor;
 import java.util.function.Supplier;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Stream;
 
+import jdk.internal.access.JavaIOAccess;
+import jdk.internal.access.JavaLangRefAccess;
 import jdk.internal.javac.Restricted;
 import jdk.internal.loader.NativeLibraries;
 import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;
@@ -234,8 +230,6 @@ public static void setErr(PrintStream err) {
         setErr0(err);
     }
 
-    private static volatile Console cons;
-
     /**
      * Returns the unique {@link Console Console} object associated
      * with the current Java virtual machine, if any.
@@ -246,15 +240,7 @@ public static void setErr(PrintStream err) {
      * @since   1.6
      */
      public static Console console() {
-         Console c;
-         if ((c = cons) == null) {
-             synchronized (System.class) {
-                 if ((c = cons) == null) {
-                     cons = c = SharedSecrets.getJavaIOAccess().console();
-                 }
-             }
-         }
-         return c;
+         return SharedSecrets.get(JavaIOAccess.class).console();
      }
 
     /**
@@ -1830,7 +1816,7 @@ private static void initPhase1() {
         VM.initializeOSEnvironment();
 
         // start Finalizer and Reference Handler threads
-        SharedSecrets.getJavaLangRefAccess().startThreads();
+        SharedSecrets.get(JavaLangRefAccess.class).startThreads();
 
         // system properties, java.lang and other core classes are now initialized
         VM.initLevel(1);
@@ -1994,7 +1980,7 @@ private static void initPhase3() {
 
     private static void setJavaLangAccess() {
         // Allow privileged classes outside of java.lang
-        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {
+        SharedSecrets.set(JavaLangAccess.class, new JavaLangAccess() {
             public List<Method> getDeclaredPublicMethods(Class<?> klass, String name, Class<?>... parameterTypes) {
                 return klass.getDeclaredPublicMethods(name, parameterTypes);
             }
diff --git a/src/java.base/share/classes/java/lang/foreign/SymbolLookup.java b/src/java.base/share/classes/java/lang/foreign/SymbolLookup.java
index d0dc60b3f77..d620f66c375 100644
--- a/src/java.base/share/classes/java/lang/foreign/SymbolLookup.java
+++ b/src/java.base/share/classes/java/lang/foreign/SymbolLookup.java
@@ -255,7 +255,7 @@ static SymbolLookup loaderLookup() {
         return name -> {
             Objects.requireNonNull(name);
             if (Utils.containsNullChars(name)) return Optional.empty();
-            JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();
+            JavaLangAccess javaLangAccess = SharedSecrets.get(JavaLangAccess.class);
             // note: ClassLoader::findNative supports a null loader
             NativeLibraries nativeLibraries = javaLangAccess.nativeLibrariesFor(loader);
             long addr = nativeLibraries.find(name);
diff --git a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
index 5b8a4478be5..ab984a80dd1 100644
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1535,7 +1535,7 @@ private static NamedFunction createFunction(byte func) {
     }
 
     static {
-        SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
+        SharedSecrets.set(JavaLangInvokeAccess.class, new JavaLangInvokeAccess() {
             @Override
             public Class<?> getDeclaringClass(Object rmname) {
                 ResolvedMethodName method = (ResolvedMethodName)rmname;
diff --git a/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
index 70592351827..3b92eb70188 100644
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java
@@ -502,7 +502,7 @@ public static Class<?> wrapperInstanceType(Object x) {
         }
     }
 
-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();
+    private static final JavaLangReflectAccess JLRA = SharedSecrets.get(JavaLangReflectAccess.class);
     private static final AtomicInteger counter = new AtomicInteger();
 
     private static String nextModuleName() {
diff --git a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
index feb8aaaa1a9..5ff990c0799 100644
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -25,6 +25,8 @@
 
 package java.lang.invoke;
 
+import jdk.internal.access.JavaLangAccess;
+import jdk.internal.access.JavaLangReflectAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.misc.VM;
@@ -360,7 +362,7 @@ public static <T> T classData(Lookup caller, String name, Class<T> type) throws
      */
     static Object classData(Class<?> c) {
         UNSAFE.ensureClassInitialized(c);
-        return SharedSecrets.getJavaLangAccess().classData(c);
+        return SharedSecrets.get(JavaLangAccess.class).classData(c);
     }
 
     /**
@@ -2352,7 +2354,7 @@ Class<?> defineClass(boolean initialize, Object classData) {
                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;
                 Class<?> c = null;
                 try {
-                    c = SharedSecrets.getJavaLangAccess()
+                    c = SharedSecrets.get(JavaLangAccess.class)
                             .defineClass(loader, lookupClass, internalName, bytes, pd, initialize, classFlags, classData);
                     assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();
                     return c;
@@ -2392,7 +2394,7 @@ private boolean isNestmate() {
         private ProtectionDomain lookupClassProtectionDomain() {
             ProtectionDomain pd = cachedProtectionDomain;
             if (pd == null) {
-                cachedProtectionDomain = pd = SharedSecrets.getJavaLangAccess().protectionDomain(lookupClass);
+                cachedProtectionDomain = pd = SharedSecrets.get(JavaLangAccess.class).protectionDomain(lookupClass);
             }
             return pd;
         }
@@ -3447,7 +3449,7 @@ private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAcc
                 }
                 // check if write access to final field allowed
                 if (!field.isStatic() && isAccessible) {
-                    SharedSecrets.getJavaLangReflectAccess().checkAllowedToUnreflectFinalSetter(lookupClass, f);
+                    SharedSecrets.get(JavaLangReflectAccess.class).checkAllowedToUnreflectFinalSetter(lookupClass, f);
                 }
             }
             assert(isSetter
diff --git a/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java b/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
index 733714b5786..0347e022d87 100644
--- a/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
+++ b/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
@@ -148,7 +148,7 @@ public final class StringConcatFactory {
      */
     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     // StringConcatFactory bootstrap methods are startup sensitive, and may be
     // special cased in java.lang.invoke.BootstrapMethodInvoker to ensure
diff --git a/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java b/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java
index 4f4e35c6727..14be7357b23 100644
--- a/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java
+++ b/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java
@@ -52,6 +52,7 @@
 import static jdk.internal.module.Checks.*;
 import static java.util.Objects.*;
 
+import jdk.internal.access.JavaLangModuleAccess;
 import jdk.internal.module.Checks;
 import jdk.internal.module.ModuleInfo;
 import jdk.internal.vm.annotation.AOTSafeClassInitializer;
@@ -2672,7 +2673,7 @@ private static <E extends Enum<E>> long modsValue(Set<E> set) {
          * private package methods in java.lang.module.
          */
         jdk.internal.access.SharedSecrets
-            .setJavaLangModuleAccess(new jdk.internal.access.JavaLangModuleAccess() {
+            .set(JavaLangModuleAccess.class, new jdk.internal.access.JavaLangModuleAccess() {
                 @Override
                 public Builder newModuleBuilder(String mn,
                                                 boolean strict,
diff --git a/src/java.base/share/classes/java/lang/ref/Finalizer.java b/src/java.base/share/classes/java/lang/ref/Finalizer.java
index a36a1f73c89..80694937b72 100644
--- a/src/java.base/share/classes/java/lang/ref/Finalizer.java
+++ b/src/java.base/share/classes/java/lang/ref/Finalizer.java
@@ -140,7 +140,7 @@ public void run() {
                 // in case of recursive call to run()
                 if (running)
                     return;
-                final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+                final JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
                 running = true;
                 for (Finalizer f; (f = (Finalizer)queue.poll()) != null; )
                     f.runFinalizer(jla);
@@ -158,7 +158,7 @@ public void run() {
             if (running)
                 return;
 
-            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+            final JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
             running = true;
             for (;;) {
                 try {
diff --git a/src/java.base/share/classes/java/lang/ref/Reference.java b/src/java.base/share/classes/java/lang/ref/Reference.java
index 88bdb99dfd6..f2b53624556 100644
--- a/src/java.base/share/classes/java/lang/ref/Reference.java
+++ b/src/java.base/share/classes/java/lang/ref/Reference.java
@@ -291,7 +291,7 @@ static void startReferenceHandlerThread(ThreadGroup tg) {
 
     static {
         // provide access in SharedSecrets
-        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
+        SharedSecrets.set(JavaLangRefAccess.class, new JavaLangRefAccess() {
             @Override
             public void startThreads() {
                 ThreadGroup tg = Thread.currentThread().getThreadGroup();
diff --git a/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java b/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
index 54000b916e2..c1386811085 100644
--- a/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
+++ b/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
@@ -29,6 +29,7 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.ref.WeakReference;
 
+import jdk.internal.access.JavaLangReflectAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.reflect.CallerSensitive;
@@ -75,7 +76,7 @@
 public class AccessibleObject implements AnnotatedElement {
     static {
         // AccessibleObject is initialized early in initPhase1
-        SharedSecrets.setJavaLangReflectAccess(new ReflectAccess());
+        SharedSecrets.set(JavaLangReflectAccess.class, new ReflectAccess());
     }
 
     /**
diff --git a/src/java.base/share/classes/java/lang/reflect/Constructor.java b/src/java.base/share/classes/java/lang/reflect/Constructor.java
index d072971307c..bed02636344 100644
--- a/src/java.base/share/classes/java/lang/reflect/Constructor.java
+++ b/src/java.base/share/classes/java/lang/reflect/Constructor.java
@@ -25,6 +25,7 @@
 
 package java.lang.reflect;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.reflect.CallerSensitive;
@@ -676,7 +677,7 @@ public AnnotatedType getAnnotatedReceiverType() {
 
         // A Constructor for an inner class
         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                     getConstantPool(thisDeclClass),
                 this,
                 thisDeclClass,
diff --git a/src/java.base/share/classes/java/lang/reflect/Executable.java b/src/java.base/share/classes/java/lang/reflect/Executable.java
index 4f32d33048d..5f4fa101ee5 100644
--- a/src/java.base/share/classes/java/lang/reflect/Executable.java
+++ b/src/java.base/share/classes/java/lang/reflect/Executable.java
@@ -33,6 +33,7 @@
 import java.util.StringJoiner;
 import java.util.stream.Collectors;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.vm.annotation.Stable;
 import sun.reflect.annotation.AnnotationParser;
@@ -88,7 +89,7 @@ boolean equalParamTypes(Class<?>[] params1, Class<?>[] params2) {
     Annotation[][] parseParameterAnnotations(byte[] parameterAnnotations) {
         return AnnotationParser.parseParameterAnnotations(
                parameterAnnotations,
-               SharedSecrets.getJavaLangAccess().
+               SharedSecrets.get(JavaLangAccess.class).
                getConstantPool(getDeclaringClass()),
                getDeclaringClass());
     }
@@ -671,7 +672,7 @@ private Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
                     } else {
                         declAnnos = AnnotationParser.parseAnnotations(
                                 getAnnotationBytes(),
-                                SharedSecrets.getJavaLangAccess().
+                                SharedSecrets.get(JavaLangAccess.class).
                                         getConstantPool(getDeclaringClass()),
                                 getDeclaringClass()
                         );
@@ -708,7 +709,7 @@ private Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
      */
     AnnotatedType getAnnotatedReturnType0(Type returnType) {
         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                         getConstantPool(getDeclaringClass()),
                 this,
                 getDeclaringClass(),
@@ -746,7 +747,7 @@ public AnnotatedType getAnnotatedReceiverType() {
         if (Modifier.isStatic(this.getModifiers()))
             return null;
         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                         getConstantPool(getDeclaringClass()),
                 this,
                 getDeclaringClass(),
@@ -799,7 +800,7 @@ Type parameterize(Class<?> c) {
     @SuppressWarnings("doclint:reference") // cross-module links
     public AnnotatedType[] getAnnotatedParameterTypes() {
         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                         getConstantPool(getDeclaringClass()),
                 this,
                 getDeclaringClass(),
@@ -823,7 +824,7 @@ public AnnotatedType[] getAnnotatedParameterTypes() {
      */
     public AnnotatedType[] getAnnotatedExceptionTypes() {
         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                         getConstantPool(getDeclaringClass()),
                 this,
                 getDeclaringClass(),
diff --git a/src/java.base/share/classes/java/lang/reflect/Field.java b/src/java.base/share/classes/java/lang/reflect/Field.java
index a4f0afa0199..8a7de917194 100644
--- a/src/java.base/share/classes/java/lang/reflect/Field.java
+++ b/src/java.base/share/classes/java/lang/reflect/Field.java
@@ -31,6 +31,8 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Objects;
+
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.event.FinalFieldMutationEvent;
 import jdk.internal.loader.ClassLoaders;
@@ -1400,7 +1402,7 @@ private Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
                     } else {
                         declAnnos = AnnotationParser.parseAnnotations(
                                 annotations,
-                                SharedSecrets.getJavaLangAccess()
+                                SharedSecrets.get(JavaLangAccess.class)
                                         .getConstantPool(getDeclaringClass()),
                                 getDeclaringClass());
                     }
@@ -1423,7 +1425,7 @@ private Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
      */
     public AnnotatedType getAnnotatedType() {
         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
-                                                       SharedSecrets.getJavaLangAccess().
+                                                       SharedSecrets.get(JavaLangAccess.class).
                                                            getConstantPool(getDeclaringClass()),
                                                        this,
                                                        getDeclaringClass(),
diff --git a/src/java.base/share/classes/java/lang/reflect/Method.java b/src/java.base/share/classes/java/lang/reflect/Method.java
index 07616206075..67390f5977c 100644
--- a/src/java.base/share/classes/java/lang/reflect/Method.java
+++ b/src/java.base/share/classes/java/lang/reflect/Method.java
@@ -25,6 +25,7 @@
 
 package java.lang.reflect;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.reflect.CallerSensitive;
@@ -756,7 +757,7 @@ public Object getDefaultValue() {
             getReturnType());
         Object result = AnnotationParser.parseMemberValue(
             memberType, ByteBuffer.wrap(annotationDefault),
-            SharedSecrets.getJavaLangAccess().
+            SharedSecrets.get(JavaLangAccess.class).
                 getConstantPool(getDeclaringClass()),
             getDeclaringClass());
         if (result instanceof ExceptionProxy) {
diff --git a/src/java.base/share/classes/java/lang/reflect/Proxy.java b/src/java.base/share/classes/java/lang/reflect/Proxy.java
index b811deb863d..4cd5cfcab8b 100644
--- a/src/java.base/share/classes/java/lang/reflect/Proxy.java
+++ b/src/java.base/share/classes/java/lang/reflect/Proxy.java
@@ -408,7 +408,7 @@ private static Constructor<?> getProxyConstructor(ClassLoader loader,
      * in which the proxy class will be defined.
      */
     private static final class ProxyBuilder {
-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+        private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
         // prefix for all proxy class names
         private static final String proxyClassNamePrefix = "$Proxy";
diff --git a/src/java.base/share/classes/java/lang/reflect/RecordComponent.java b/src/java.base/share/classes/java/lang/reflect/RecordComponent.java
index 5ce7f9bf95d..851d1d06c0f 100644
--- a/src/java.base/share/classes/java/lang/reflect/RecordComponent.java
+++ b/src/java.base/share/classes/java/lang/reflect/RecordComponent.java
@@ -25,6 +25,7 @@
 
 package java.lang.reflect;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.reflect.annotation.AnnotationParser;
 import sun.reflect.annotation.TypeAnnotation;
@@ -152,7 +153,7 @@ private GenericsFactory getFactory() {
      */
     public AnnotatedType getAnnotatedType() {
         return TypeAnnotationParser.buildAnnotatedType(typeAnnotations,
-                SharedSecrets.getJavaLangAccess().
+                SharedSecrets.get(JavaLangAccess.class).
                         getConstantPool(getDeclaringRecord()),
                 this,
                 getDeclaringRecord(),
@@ -196,7 +197,7 @@ private Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
                     } else {
                         declAnnos = AnnotationParser.parseAnnotations(
                                 annotations,
-                                SharedSecrets.getJavaLangAccess()
+                                SharedSecrets.get(JavaLangAccess.class)
                                         .getConstantPool(getDeclaringRecord()),
                                 getDeclaringRecord());
                     }
diff --git a/src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java b/src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java
index 25d8affa474..a59adfa6add 100644
--- a/src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java
+++ b/src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java
@@ -29,6 +29,8 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamField;
+
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -120,7 +122,7 @@ private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundEx
         ObjectInputStream.GetField fields = s.readFields();
         Throwable exception = (Throwable) fields.get("undeclaredThrowable", null);
         if (exception != null) {
-            SharedSecrets.getJavaLangAccess().setCause(this, exception);
+            SharedSecrets.get(JavaLangAccess.class).setCause(this, exception);
         }
     }
 
diff --git a/src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java b/src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
index 30b6df0073e..3f3de2a73a3 100644
--- a/src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
+++ b/src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
@@ -45,6 +45,7 @@
 import java.util.function.BiPredicate;
 import java.util.function.Consumer;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import java.lang.classfile.ClassFile;
 import java.lang.classfile.Label;
@@ -382,7 +383,7 @@ private static <T extends Enum<T>> int mappedEnumSwitch(T value, int restartInde
                 constantsMap = enumCache.constantsMap;
 
                 if (constantsMap == null) {
-                    T[] constants = SharedSecrets.getJavaLangAccess()
+                    T[] constants = SharedSecrets.get(JavaLangAccess.class)
                                                  .getEnumConstantsShared(enumClass);
                     constantsMap = new int[constants.length];
                     int ordinal = 0;
diff --git a/src/java.base/share/classes/java/math/BigDecimal.java b/src/java.base/share/classes/java/math/BigDecimal.java
index 14d81d30c3d..33c9cffde2b 100644
--- a/src/java.base/share/classes/java/math/BigDecimal.java
+++ b/src/java.base/share/classes/java/math/BigDecimal.java
@@ -330,7 +330,7 @@
  * @since 1.1
  */
 public class BigDecimal extends Number implements Comparable<BigDecimal> {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /*
      * Let l = log_2(10).
diff --git a/src/java.base/share/classes/java/net/HttpCookie.java b/src/java.base/share/classes/java/net/HttpCookie.java
index 3c633522bdf..3ebf19d2c82 100644
--- a/src/java.base/share/classes/java/net/HttpCookie.java
+++ b/src/java.base/share/classes/java/net/HttpCookie.java
@@ -1029,7 +1029,7 @@ private static void assignAttribute(HttpCookie cookie,
     }
 
     static {
-        SharedSecrets.setJavaNetHttpCookieAccess(
+        SharedSecrets.set(JavaNetHttpCookieAccess.class,
             new JavaNetHttpCookieAccess() {
                 public List<HttpCookie> parse(String header) {
                     return HttpCookie.parse(header, true, -1L);
diff --git a/src/java.base/share/classes/java/net/InetAddress.java b/src/java.base/share/classes/java/net/InetAddress.java
index 4d8a00249a9..0e8e81302df 100644
--- a/src/java.base/share/classes/java/net/InetAddress.java
+++ b/src/java.base/share/classes/java/net/InetAddress.java
@@ -370,7 +370,7 @@ InetAddressHolder holder() {
         HOSTS_FILE_NAME =
                 System.getProperty("jdk.net.hosts.file");
         jdk.internal.loader.BootLoader.loadLibrary("net");
-        SharedSecrets.setJavaNetInetAddressAccess(
+        SharedSecrets.set(JavaNetInetAddressAccess.class,
                 new JavaNetInetAddressAccess() {
                     public String getOriginalHostName(InetAddress ia) {
                         return ia.holder.getOriginalHostName();
diff --git a/src/java.base/share/classes/java/net/URI.java b/src/java.base/share/classes/java/net/URI.java
index d568ab1c114..e07185d770d 100644
--- a/src/java.base/share/classes/java/net/URI.java
+++ b/src/java.base/share/classes/java/net/URI.java
@@ -3730,7 +3730,7 @@ private int scanHexSeq(int start, int n)
     }
 
     static {
-        SharedSecrets.setJavaNetUriAccess(
+        SharedSecrets.set(JavaNetUriAccess.class,
             new JavaNetUriAccess() {
                 public URI create(String scheme, String path) {
                     return new URI(scheme, path);
diff --git a/src/java.base/share/classes/java/net/URL.java b/src/java.base/share/classes/java/net/URL.java
index 1e86f41fd3f..ba5ec21f88d 100644
--- a/src/java.base/share/classes/java/net/URL.java
+++ b/src/java.base/share/classes/java/net/URL.java
@@ -1746,7 +1746,7 @@ private void setSerializedHashCode(int hc) {
     }
 
     static {
-        SharedSecrets.setJavaNetURLAccess(
+        SharedSecrets.set(JavaNetURLAccess.class,
                 new JavaNetURLAccess() {
                     @Override
                     public URLStreamHandler getHandler(URL u) {
diff --git a/src/java.base/share/classes/java/net/URLClassLoader.java b/src/java.base/share/classes/java/net/URLClassLoader.java
index 4b579554e0a..fa3ac8d9441 100644
--- a/src/java.base/share/classes/java/net/URLClassLoader.java
+++ b/src/java.base/share/classes/java/net/URLClassLoader.java
@@ -44,6 +44,7 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
+import jdk.internal.access.JavaUtilJarAccess;
 import jdk.internal.loader.Resource;
 import jdk.internal.loader.URLClassPath;
 import jdk.internal.access.SharedSecrets;
@@ -476,7 +477,7 @@ protected Package definePackage(String name, Manifest man, URL url) {
         String sealed = null;
         URL sealBase = null;
 
-        Attributes attr = SharedSecrets.javaUtilJarAccess()
+        Attributes attr = SharedSecrets.get(JavaUtilJarAccess.class)
                 .getTrustedAttributes(man, name.replace('.', '/').concat("/"));
         if (attr != null) {
             specTitle   = attr.getValue(Name.SPECIFICATION_TITLE);
@@ -525,7 +526,7 @@ protected Package definePackage(String name, Manifest man, URL url) {
      * @throws SecurityException if the package name is untrusted in the manifest
      */
     private boolean isSealed(String name, Manifest man) {
-        Attributes attr = SharedSecrets.javaUtilJarAccess()
+        Attributes attr = SharedSecrets.get(JavaUtilJarAccess.class)
                 .getTrustedAttributes(man, name.replace('.', '/').concat("/"));
         String sealed = null;
         if (attr != null) {
diff --git a/src/java.base/share/classes/java/nio/Bits.java b/src/java.base/share/classes/java/nio/Bits.java
index 07dd6a91890..07c471c7437 100644
--- a/src/java.base/share/classes/java/nio/Bits.java
+++ b/src/java.base/share/classes/java/nio/Bits.java
@@ -206,7 +206,7 @@ static void reserveMemory(long size, long cap) {
     private static boolean tryReserveOrClean(long size, long cap)
         throws InterruptedException
     {
-        JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();
+        JavaLangRefAccess jlra = SharedSecrets.get(JavaLangRefAccess.class);
         boolean progressing = true;
         while (true) {
             if (tryReserveMemory(size, cap)) {
diff --git a/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java b/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
index 6adf2eb2276..60396c314a7 100644
--- a/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
+++ b/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
@@ -31,6 +31,7 @@
 import java.nio.channels.ClosedByInterruptException;
 import java.nio.channels.InterruptibleChannel;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import sun.nio.ch.Interruptible;
@@ -221,6 +222,6 @@ protected final void end(boolean completed)
 
     // -- jdk.internal.access.SharedSecrets --
     static void blockedOn(Interruptible intr) {         // package-private
-        SharedSecrets.getJavaLangAccess().blockedOn(intr);
+        SharedSecrets.get(JavaLangAccess.class).blockedOn(intr);
     }
 }
diff --git a/src/java.base/share/classes/java/nio/file/Files.java b/src/java.base/share/classes/java/nio/file/Files.java
index 3f1d6fae4e4..009311b30f3 100644
--- a/src/java.base/share/classes/java/nio/file/Files.java
+++ b/src/java.base/share/classes/java/nio/file/Files.java
@@ -75,6 +75,7 @@
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.util.ArraysSupport;
 import sun.nio.ch.FileChannelImpl;
 import sun.nio.cs.UTF_8;
@@ -2908,7 +2909,7 @@ public static long copy(Path source, OutputStream out) throws IOException {
     }
 
     private static final jdk.internal.access.JavaLangAccess JLA =
-            jdk.internal.access.SharedSecrets.getJavaLangAccess();
+            jdk.internal.access.SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
diff --git a/src/java.base/share/classes/java/security/PrivilegedActionException.java b/src/java.base/share/classes/java/security/PrivilegedActionException.java
index 1c1418f4267..9aa70e6ceed 100644
--- a/src/java.base/share/classes/java/security/PrivilegedActionException.java
+++ b/src/java.base/share/classes/java/security/PrivilegedActionException.java
@@ -29,6 +29,8 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamField;
+
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -118,7 +120,7 @@ private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundEx
         ObjectInputStream.GetField fields = s.readFields();
         Exception exception = (Exception) fields.get("exception", null);
         if (exception != null) {
-            SharedSecrets.getJavaLangAccess().setCause(this, exception);
+            SharedSecrets.get(JavaLangAccess.class).setCause(this, exception);
         }
     }
 
diff --git a/src/java.base/share/classes/java/text/DigitList.java b/src/java.base/share/classes/java/text/DigitList.java
index 140a5827860..a61cc7fdaa2 100644
--- a/src/java.base/share/classes/java/text/DigitList.java
+++ b/src/java.base/share/classes/java/text/DigitList.java
@@ -43,6 +43,7 @@
 import java.math.RoundingMode;
 import java.nio.charset.StandardCharsets;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.math.FloatingDecimal;
 import jdk.internal.util.ArraysSupport;
@@ -218,7 +219,7 @@ public BigDecimal getBigDecimal() {
         }
 
         char[] chars = new char[count];
-        SharedSecrets.getJavaLangAccess()
+        SharedSecrets.get(JavaLangAccess.class)
                      .inflateBytesToChars(digits, 0, chars, 0, count);
         BigDecimal value = new BigDecimal(chars, 0, count);
         if (decimalAt == count) {
diff --git a/src/java.base/share/classes/java/util/ArrayDeque.java b/src/java.base/share/classes/java/util/ArrayDeque.java
index 60bb3ed4a45..a0682704ec6 100644
--- a/src/java.base/share/classes/java/util/ArrayDeque.java
+++ b/src/java.base/share/classes/java/util/ArrayDeque.java
@@ -37,6 +37,8 @@
 import java.io.Serializable;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.ArraysSupport;
 
@@ -1199,7 +1201,7 @@ private void readObject(java.io.ObjectInputStream s)
 
         // Read in size and allocate array
         int size = s.readInt();
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size + 1);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, size + 1);
         elements = new Object[size + 1];
         this.tail = size;
 
diff --git a/src/java.base/share/classes/java/util/ArrayList.java b/src/java.base/share/classes/java/util/ArrayList.java
index 53e818b99c5..b28f0d89366 100644
--- a/src/java.base/share/classes/java/util/ArrayList.java
+++ b/src/java.base/share/classes/java/util/ArrayList.java
@@ -28,6 +28,8 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.ArraysSupport;
 
@@ -982,7 +984,7 @@ private void readObject(java.io.ObjectInputStream s)
 
         if (size > 0) {
             // like clone(), allocate array based upon size not capacity
-            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
+            SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, size);
             Object[] elements = new Object[size];
 
             // Read in all elements in the proper order.
diff --git a/src/java.base/share/classes/java/util/Collections.java b/src/java.base/share/classes/java/util/Collections.java
index 316458d6f90..9af7fa15d87 100644
--- a/src/java.base/share/classes/java/util/Collections.java
+++ b/src/java.base/share/classes/java/util/Collections.java
@@ -41,6 +41,8 @@
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.vm.annotation.AOTSafeClassInitializer;
 
@@ -5664,7 +5666,7 @@ public Spliterator<E> spliterator() {
         @java.io.Serial
         private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
             ois.defaultReadObject();
-            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, n);
+            SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(ois, Object[].class, n);
         }
     }
 
diff --git a/src/java.base/share/classes/java/util/EnumMap.java b/src/java.base/share/classes/java/util/EnumMap.java
index d02b1fdcff7..4c2aed1eb00 100644
--- a/src/java.base/share/classes/java/util/EnumMap.java
+++ b/src/java.base/share/classes/java/util/EnumMap.java
@@ -25,6 +25,7 @@
 
 package java.util;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -747,7 +748,7 @@ private void typeCheck(K key) {
      * The result is uncloned, cached, and shared by all callers.
      */
     private static <K extends Enum<K>> K[] getKeyUniverse(Class<K> keyType) {
-        return SharedSecrets.getJavaLangAccess()
+        return SharedSecrets.get(JavaLangAccess.class)
                                         .getEnumConstantsShared(keyType);
     }
 
diff --git a/src/java.base/share/classes/java/util/EnumSet.java b/src/java.base/share/classes/java/util/EnumSet.java
index e8dee28fa33..e5864a10590 100644
--- a/src/java.base/share/classes/java/util/EnumSet.java
+++ b/src/java.base/share/classes/java/util/EnumSet.java
@@ -25,6 +25,7 @@
 
 package java.util;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -406,7 +407,7 @@ final void typeCheck(E e) {
      * The result is uncloned, cached, and shared by all callers.
      */
     private static <E extends Enum<E>> E[] getUniverse(Class<E> elementType) {
-        return SharedSecrets.getJavaLangAccess()
+        return SharedSecrets.get(JavaLangAccess.class)
                                         .getEnumConstantsShared(elementType);
     }
 
diff --git a/src/java.base/share/classes/java/util/HashMap.java b/src/java.base/share/classes/java/util/HashMap.java
index 3320b394e6c..e3f80aedfac 100644
--- a/src/java.base/share/classes/java/util/HashMap.java
+++ b/src/java.base/share/classes/java/util/HashMap.java
@@ -35,6 +35,8 @@
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -1548,7 +1550,7 @@ private void readObject(ObjectInputStream s)
 
             // Check Map.Entry[].class since it's the nearest public type to
             // what we're actually creating.
-            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);
+            SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Map.Entry[].class, cap);
             @SuppressWarnings({"rawtypes","unchecked"})
             Node<K,V>[] tab = (Node<K,V>[])new Node[cap];
             table = tab;
diff --git a/src/java.base/share/classes/java/util/HashSet.java b/src/java.base/share/classes/java/util/HashSet.java
index 57ecdbd1695..21b1ba8ba69 100644
--- a/src/java.base/share/classes/java/util/HashSet.java
+++ b/src/java.base/share/classes/java/util/HashSet.java
@@ -26,6 +26,8 @@
 package java.util;
 
 import java.io.InvalidObjectException;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -340,7 +342,7 @@ private void readObject(java.io.ObjectInputStream s)
         // added, so check it before construction. Call HashMap.tableSizeFor to compute the
         // actual allocation size. Check Map.Entry[].class since it's the nearest public type to
         // what is actually created.
-        SharedSecrets.getJavaObjectInputStreamAccess()
+        SharedSecrets.get(JavaObjectInputStreamAccess.class)
                      .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));
 
         // Create backing HashMap
diff --git a/src/java.base/share/classes/java/util/Hashtable.java b/src/java.base/share/classes/java/util/Hashtable.java
index ddff8f7a0ab..8ef03bae82e 100644
--- a/src/java.base/share/classes/java/util/Hashtable.java
+++ b/src/java.base/share/classes/java/util/Hashtable.java
@@ -29,6 +29,8 @@
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.BiFunction;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.ArraysSupport;
 
@@ -1298,7 +1300,7 @@ void readHashtable(ObjectInputStream s)
 
         // Check Map.Entry[].class since it's the nearest public type to
         // what we're actually creating.
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, length);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Map.Entry[].class, length);
         Hashtable.UnsafeHolder.putLoadFactor(this, lf);
         table = new Entry<?,?>[length];
         threshold = (int)Math.min(length * lf, MAX_ARRAY_SIZE + 1);
diff --git a/src/java.base/share/classes/java/util/HexFormat.java b/src/java.base/share/classes/java/util/HexFormat.java
index aebb8b9af52..cdc3c8805c0 100644
--- a/src/java.base/share/classes/java/util/HexFormat.java
+++ b/src/java.base/share/classes/java/util/HexFormat.java
@@ -138,7 +138,7 @@
 public final class HexFormat {
 
     // Access to create strings from a byte array.
-    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
 
     // Analysis has shown that generating the whole array allows the JIT to generate
     // better code compared to a slimmed down array, such as one cutting off after 'f'
diff --git a/src/java.base/share/classes/java/util/IdentityHashMap.java b/src/java.base/share/classes/java/util/IdentityHashMap.java
index 48a6d7b28df..66ec484365c 100644
--- a/src/java.base/share/classes/java/util/IdentityHashMap.java
+++ b/src/java.base/share/classes/java/util/IdentityHashMap.java
@@ -31,6 +31,8 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 
 /**
@@ -1327,7 +1329,7 @@ private void readObject(ObjectInputStream s)
             throw new java.io.StreamCorruptedException
                 ("Illegal mappings count: " + size);
         int cap = capacity(size);
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, cap*2);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, cap*2);
         this.size = size;
         init(cap);
 
diff --git a/src/java.base/share/classes/java/util/ImmutableCollections.java b/src/java.base/share/classes/java/util/ImmutableCollections.java
index abc48ff5ed9..564ef04f3e5 100644
--- a/src/java.base/share/classes/java/util/ImmutableCollections.java
+++ b/src/java.base/share/classes/java/util/ImmutableCollections.java
@@ -39,6 +39,7 @@
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
 
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.JavaUtilCollectionAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.CDS;
@@ -1506,7 +1507,7 @@ private void readObject(ObjectInputStream ois) throws IOException, ClassNotFound
             throw new InvalidObjectException("negative length " + len);
         }
 
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, len);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(ois, Object[].class, len);
         Object[] a = new Object[len];
         for (int i = 0; i < len; i++) {
             a[i] = ois.readObject();
diff --git a/src/java.base/share/classes/java/util/PriorityQueue.java b/src/java.base/share/classes/java/util/PriorityQueue.java
index bacce5ef97e..016b81b4eab 100644
--- a/src/java.base/share/classes/java/util/PriorityQueue.java
+++ b/src/java.base/share/classes/java/util/PriorityQueue.java
@@ -27,6 +27,8 @@
 
 import java.util.function.Consumer;
 import java.util.function.Predicate;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.ArraysSupport;
 
@@ -789,7 +791,7 @@ private void readObject(java.io.ObjectInputStream s)
         // Read in (and discard) array length
         s.readInt();
 
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, size);
         final Object[] es = queue = new Object[Math.max(size, 1)];
 
         // Read in all elements.
diff --git a/src/java.base/share/classes/java/util/Properties.java b/src/java.base/share/classes/java/util/Properties.java
index 6e02c3f5a23..18cfdc12f60 100644
--- a/src/java.base/share/classes/java/util/Properties.java
+++ b/src/java.base/share/classes/java/util/Properties.java
@@ -46,6 +46,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.util.StaticProperty;
 import sun.nio.cs.ISO_8859_1;
 import sun.nio.cs.UTF_8;
@@ -1584,7 +1585,7 @@ void readHashtable(ObjectInputStream s) throws IOException,
         // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is
         // accessible here.) Check Map.Entry[].class since it's the nearest public type to
         // what is actually created.
-        SharedSecrets.getJavaObjectInputStreamAccess()
+        SharedSecrets.get(JavaObjectInputStreamAccess.class)
                      .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));
 
         // create CHM of appropriate capacity
diff --git a/src/java.base/share/classes/java/util/ServiceLoader.java b/src/java.base/share/classes/java/util/ServiceLoader.java
index 5137adc1c08..e0d7834bf2b 100644
--- a/src/java.base/share/classes/java/util/ServiceLoader.java
+++ b/src/java.base/share/classes/java/util/ServiceLoader.java
@@ -403,7 +403,7 @@ public final class ServiceLoader<S>
     // Incremented when reload is called
     private int reloadCount;
 
-    private static final JavaLangAccess LANG_ACCESS = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess LANG_ACCESS = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * Represents a service provider located by {@code ServiceLoader}.
diff --git a/src/java.base/share/classes/java/util/StringJoiner.java b/src/java.base/share/classes/java/util/StringJoiner.java
index f8127d9b707..775ff4d3797 100644
--- a/src/java.base/share/classes/java/util/StringJoiner.java
+++ b/src/java.base/share/classes/java/util/StringJoiner.java
@@ -257,5 +257,5 @@ public int length() {
             len + prefix.length() + suffix.length();
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 }
diff --git a/src/java.base/share/classes/java/util/UUID.java b/src/java.base/share/classes/java/util/UUID.java
index f69ca8171cf..5d13be468c1 100644
--- a/src/java.base/share/classes/java/util/UUID.java
+++ b/src/java.base/share/classes/java/util/UUID.java
@@ -89,7 +89,7 @@ public final class UUID implements java.io.Serializable, Comparable<UUID> {
      */
     private final long leastSigBits;
 
-    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
 
     /*
      * The random number generator used by this class to create random
diff --git a/src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java b/src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
index 9024fca8024..0ae7fc067d1 100644
--- a/src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
+++ b/src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
@@ -55,6 +55,8 @@
 import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.util.ArraysSupport;
@@ -1035,7 +1037,7 @@ private void readObject(java.io.ObjectInputStream s)
 
         // Read in array length and allocate array
         int len = s.readInt();
-        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, len);
+        SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, len);
         Object[] es = (len == 0 ? EMPTY_ELEMENTDATA : new Object[len]);
 
         // Read in all elements in the proper order.
diff --git a/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java b/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java
index f289186e0ad..9ba9b9f7eed 100644
--- a/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java
+++ b/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java
@@ -4386,7 +4386,7 @@ protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
 
         Class<?> dep = LockSupport.class; // ensure loaded
         // allow access to non-public methods
-        JLA = SharedSecrets.getJavaLangAccess();
+        JLA = SharedSecrets.get(JavaLangAccess.class);
         SharedSecrets.setJavaUtilConcurrentFJPAccess(
             new JavaUtilConcurrentFJPAccess() {
                 @Override
diff --git a/src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java b/src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java
index 566fc417952..cdaa781bbef 100644
--- a/src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java
+++ b/src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java
@@ -246,7 +246,7 @@ void onThreadLocalReset() {
         = U.objectFieldOffset(Thread.class, "threadLocals");
     private static final long INHERITABLETHREADLOCALS
         = U.objectFieldOffset(Thread.class, "inheritableThreadLocals");
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * A worker thread that is not a member of any user-defined
diff --git a/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java b/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
index ebaecaa525d..a4353471b2c 100644
--- a/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
+++ b/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
@@ -52,6 +52,8 @@
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.invoke.MhUtil;
 import jdk.internal.util.ArraysSupport;
@@ -921,7 +923,7 @@ private void readObject(java.io.ObjectInputStream s)
         try {
             s.defaultReadObject();
             int sz = q.size();
-            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, sz);
+            SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(s, Object[].class, sz);
             this.queue = new Object[Math.max(1, sz)];
             comparator = q.comparator();
             addAll(q);
diff --git a/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java b/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java
index deed7f018c3..dcdc1cac097 100644
--- a/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java
+++ b/src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java
@@ -384,7 +384,7 @@ private Object readResolve() {
         = new AtomicLong(RandomSupport.mixMurmur64(System.currentTimeMillis()) ^
                          RandomSupport.mixMurmur64(System.nanoTime()));
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     // used by ScopedValue
     private static class Access {
diff --git a/src/java.base/share/classes/java/util/concurrent/ThreadPerTaskExecutor.java b/src/java.base/share/classes/java/util/concurrent/ThreadPerTaskExecutor.java
index fff60cec15f..cf27476ee66 100644
--- a/src/java.base/share/classes/java/util/concurrent/ThreadPerTaskExecutor.java
+++ b/src/java.base/share/classes/java/util/concurrent/ThreadPerTaskExecutor.java
@@ -46,7 +46,7 @@
  * threads is unbounded.
  */
 class ThreadPerTaskExecutor extends ThreadContainer implements ExecutorService {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     private static final VarHandle STATE = MhUtil.findVarHandle(
             MethodHandles.lookup(), "state", int.class);
 
diff --git a/src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java b/src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
index 38531c80a30..f0cbf8a419e 100644
--- a/src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
+++ b/src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
@@ -461,5 +461,5 @@ static final long getThreadId(Thread thread) {
     private static final long PARKBLOCKER
         = U.objectFieldOffset(Thread.class, "parkBlocker");
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 }
diff --git a/src/java.base/share/classes/java/util/jar/JarFile.java b/src/java.base/share/classes/java/util/jar/JarFile.java
index d1a8f1310a9..0067528af80 100644
--- a/src/java.base/share/classes/java/util/jar/JarFile.java
+++ b/src/java.base/share/classes/java/util/jar/JarFile.java
@@ -25,6 +25,7 @@
 
 package java.util.jar;
 
+import jdk.internal.access.JavaUtilJarAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.JavaUtilZipFileAccess;
 import sun.security.util.ManifestEntryVerifier;
@@ -163,7 +164,7 @@ public class JarFile extends ZipFile {
 
     static {
         // Set up JavaUtilJarAccess in SharedSecrets
-        SharedSecrets.setJavaUtilJarAccess(new JavaUtilJarAccessImpl());
+        SharedSecrets.set(JavaUtilJarAccess.class, new JavaUtilJarAccessImpl());
         // Get JavaUtilZipFileAccess from SharedSecrets
         JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
         // multi-release jar file versions >= 9
diff --git a/src/java.base/share/classes/java/util/zip/ZipCoder.java b/src/java.base/share/classes/java/util/zip/ZipCoder.java
index b9906d348e3..86241434750 100644
--- a/src/java.base/share/classes/java/util/zip/ZipCoder.java
+++ b/src/java.base/share/classes/java/util/zip/ZipCoder.java
@@ -35,6 +35,7 @@
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.util.ArraysSupport;
 import sun.nio.cs.UTF_8;
 
@@ -47,7 +48,7 @@
 class ZipCoder {
 
     private static final jdk.internal.access.JavaLangAccess JLA =
-        jdk.internal.access.SharedSecrets.getJavaLangAccess();
+        jdk.internal.access.SharedSecrets.get(JavaLangAccess.class);
 
     // Encoding/decoding is stateless, so make it singleton.
     static final UTF8ZipCoder UTF8 = new UTF8ZipCoder(UTF_8.INSTANCE);
diff --git a/src/java.base/share/classes/java/util/zip/ZipFile.java b/src/java.base/share/classes/java/util/zip/ZipFile.java
index 7fa507980c2..4c12e2485e5 100644
--- a/src/java.base/share/classes/java/util/zip/ZipFile.java
+++ b/src/java.base/share/classes/java/util/zip/ZipFile.java
@@ -44,6 +44,8 @@
 import java.util.jar.JarFile;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+
+import jdk.internal.access.JavaIORandomAccessFileAccess;
 import jdk.internal.access.JavaUtilZipFileAccess;
 import jdk.internal.access.JavaUtilJarAccess;
 import jdk.internal.access.SharedSecrets;
@@ -1158,7 +1160,7 @@ static record EntryPos(String name, int pos) {}
     private static class Source {
         // While this is only used from ZipFile, defining it there would cause
         // a bootstrap cycle that would leave this initialized as null
-        private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
+        private static final JavaUtilJarAccess JUJA = SharedSecrets.get(JavaUtilJarAccess.class);
         // "META-INF/".length()
         private static final int META_INF_LEN = 9;
         // "META-INF/versions//".length()
@@ -1541,7 +1543,7 @@ private Source(Key key, boolean toDelete, ZipCoder zipCoder) throws IOException
             this.key = key;
             if (toDelete) {
                 if (OperatingSystem.isWindows()) {
-                    this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
+                    this.zfile = SharedSecrets.get(JavaIORandomAccessFileAccess.class)
                                               .openAndDelete(key.file, "r");
                 } else {
                     this.zfile = new RandomAccessFile(key.file, "r");
diff --git a/src/java.base/share/classes/jdk/internal/access/Access.java b/src/java.base/share/classes/jdk/internal/access/Access.java
new file mode 100644
index 00000000000..ca2680af437
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/access/Access.java
@@ -0,0 +1,4 @@
+package jdk.internal.access;
+
+public sealed interface Access permits JavaBeansAccess, JavaIOAccess, JavaIOFileDescriptorAccess, JavaIORandomAccessFileAccess, JavaLangAccess, JavaLangInvokeAccess, JavaLangModuleAccess, JavaLangRefAccess, JavaLangReflectAccess, JavaNetHttpCookieAccess, JavaNetInetAddressAccess, JavaNetURLAccess, JavaNetUriAccess, JavaNioAccess, JavaObjectInputFilterAccess, JavaObjectInputStreamAccess, JavaObjectInputStreamReadString, JavaObjectStreamReflectionAccess, JavaSecurityPropertiesAccess, JavaSecuritySignatureAccess, JavaSecuritySpecAccess, JavaUtilCollectionAccess, JavaUtilConcurrentFJPAccess, JavaUtilConcurrentTLRAccess, JavaUtilJarAccess, JavaUtilResourceBundleAccess, JavaUtilZipFileAccess, JavaxCryptoSealedObjectAccess, JavaxCryptoSpecAccess, JavaxSecurityAccess {
+}
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaBeansAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaBeansAccess.java
index bcde7323f77..a2fb6557e44 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaBeansAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaBeansAccess.java
@@ -28,7 +28,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 
-public interface JavaBeansAccess {
+public non-sealed interface JavaBeansAccess extends Access {
     /**
      * Returns the getter method for a property of the given name
      * @param clazz The JavaBeans class
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaIOAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaIOAccess.java
index bdeb2282a02..80a632c7851 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaIOAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaIOAccess.java
@@ -27,7 +27,7 @@
 
 import java.io.Console;
 
-public interface JavaIOAccess {
+public non-sealed interface JavaIOAccess extends Access {
     Console console();
     boolean isStdinTty();
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
index 5e627abc73e..34eac93ab42 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
@@ -33,7 +33,7 @@
  * @author Chris Hegarty
  */
 
-public interface JavaIOFileDescriptorAccess {
+public non-sealed interface JavaIOFileDescriptorAccess extends Access {
     public void set(FileDescriptor fdo, int fd);
     public int get(FileDescriptor fdo);
     public void setAppend(FileDescriptor fdo, boolean append);
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaIORandomAccessFileAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaIORandomAccessFileAccess.java
index f6c59908727..79a8303f730 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaIORandomAccessFileAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaIORandomAccessFileAccess.java
@@ -29,7 +29,7 @@
 import java.io.IOException;
 import java.io.RandomAccessFile;
 
-public interface JavaIORandomAccessFileAccess {
+public non-sealed interface JavaIORandomAccessFileAccess extends Access {
     public RandomAccessFile openAndDelete(File file, String mode)
         throws IOException;
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java
index 86e5f317dc7..510a68650d6 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java
@@ -58,7 +58,7 @@
 import sun.reflect.annotation.AnnotationType;
 import sun.nio.ch.Interruptible;
 
-public interface JavaLangAccess {
+public non-sealed interface JavaLangAccess extends Access {
 
     /**
      * Returns the list of {@code Method} objects for the declared public
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
index 722447eece6..efa20070794 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -38,7 +38,7 @@
 import java.util.Map;
 import java.util.stream.Stream;
 
-public interface JavaLangInvokeAccess {
+public non-sealed interface JavaLangInvokeAccess extends Access {
     /**
      * Returns the declaring class for the given ResolvedMethodName.
      * Used by {@code StackFrameInfo}.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaLangModuleAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangModuleAccess.java
index 608dfb84cb0..c76c85b0fda 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangModuleAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangModuleAccess.java
@@ -43,7 +43,7 @@
  * Provides access to non-public methods in java.lang.module.
  */
 
-public interface JavaLangModuleAccess {
+public non-sealed interface JavaLangModuleAccess extends Access {
 
     /**
      * Creates a builder for building a module with the given module name.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaLangRefAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangRefAccess.java
index 909c5b80d25..398892a03e0 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangRefAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangRefAccess.java
@@ -27,7 +27,7 @@
 
 import java.lang.ref.ReferenceQueue;
 
-public interface JavaLangRefAccess {
+public non-sealed interface JavaLangRefAccess extends Access {
 
     /**
      * Starts the Finalizer and Reference Handler threads.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaLangReflectAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangReflectAccess.java
index 965bac67f45..0cf59951fba 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangReflectAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangReflectAccess.java
@@ -30,7 +30,7 @@
 
 /** An interface which gives privileged packages Java-level access to
     internals of java.lang.reflect. Use as a last resort! */
-public interface JavaLangReflectAccess {
+public non-sealed interface JavaLangReflectAccess extends Access {
     /**
      * Creates a new root constructor from the original one, with
      * a custom accessor. Used by serialization hooks.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaNetHttpCookieAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNetHttpCookieAccess.java
index b76dbf33afa..ae1de860126 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaNetHttpCookieAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNetHttpCookieAccess.java
@@ -28,7 +28,7 @@
 import java.net.HttpCookie;
 import java.util.List;
 
-public interface JavaNetHttpCookieAccess {
+public non-sealed interface JavaNetHttpCookieAccess extends Access {
     /*
      * Constructs cookies from Set-Cookie or Set-Cookie2 header string,
      * retaining the original header String in the cookie itself.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaNetInetAddressAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNetInetAddressAccess.java
index d3e0e6586f4..f24e24ed3bb 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaNetInetAddressAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNetInetAddressAccess.java
@@ -29,7 +29,7 @@
 import java.net.Inet6Address;
 import java.net.InetAddress;
 
-public interface JavaNetInetAddressAccess {
+public non-sealed interface JavaNetInetAddressAccess extends Access {
     /**
      * Return the original application specified hostname of
      * the given InetAddress object.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaNetURLAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNetURLAccess.java
index 0ad25d80c30..78cc68a10a0 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaNetURLAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNetURLAccess.java
@@ -27,6 +27,6 @@
 import java.net.URL;
 import java.net.URLStreamHandler;
 
-public interface JavaNetURLAccess {
+public non-sealed interface JavaNetURLAccess extends Access {
     URLStreamHandler getHandler(URL u);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaNetUriAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNetUriAccess.java
index 8eb95a21cee..cd9136dbc06 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaNetUriAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNetUriAccess.java
@@ -27,7 +27,7 @@
 
 import java.net.URI;
 
-public interface JavaNetUriAccess {
+public non-sealed interface JavaNetUriAccess extends Access {
     /**
      * Create a URI of pre-validated scheme and path.
      */
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
index 431ffbdab53..c3fa8c2b037 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
@@ -35,7 +35,7 @@
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
-public interface JavaNioAccess {
+public non-sealed interface JavaNioAccess extends Access {
 
     /**
      * Used by {@code jdk.internal.misc.VM}.
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputFilterAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputFilterAccess.java
index bc60cbbb98a..f6443635cea 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputFilterAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputFilterAccess.java
@@ -30,7 +30,7 @@
 /**
  * Access to the alternative ObjectInputFilter.Config.createFilter2 for RMI.
  */
-public interface JavaObjectInputFilterAccess {
+public non-sealed interface JavaObjectInputFilterAccess extends Access {
     /**
      * Creates a filter from the pattern.
      */
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
index a47add473c6..4d2a8da4d35 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
@@ -32,7 +32,7 @@
  * Interface to specify methods for accessing {@code ObjectInputStream}.
  */
 @FunctionalInterface
-public interface JavaObjectInputStreamAccess {
+public non-sealed interface JavaObjectInputStreamAccess extends Access {
     void checkArray(ObjectInputStream ois, Class<?> arrayType, int arrayLength)
         throws ObjectStreamException;
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamReadString.java b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamReadString.java
index 1ae489b75bd..108033dbe37 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamReadString.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamReadString.java
@@ -32,7 +32,7 @@
  * Interface to specify methods for accessing {@code ObjectInputStream}.
  */
 @FunctionalInterface
-public interface JavaObjectInputStreamReadString {
+public non-sealed interface JavaObjectInputStreamReadString extends Access {
     String readString(ObjectInputStream ois) throws IOException;
 }
 
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaObjectStreamReflectionAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaObjectStreamReflectionAccess.java
index ea3e219e8ab..413218acffb 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaObjectStreamReflectionAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaObjectStreamReflectionAccess.java
@@ -27,7 +27,7 @@
 
 import java.lang.invoke.MethodHandle;
 
-public interface JavaObjectStreamReflectionAccess {
+public non-sealed interface JavaObjectStreamReflectionAccess extends Access {
     MethodHandle defaultReadObject(Class<?> clazz);
     MethodHandle defaultWriteObject(Class<?> clazz);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaSecurityPropertiesAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaSecurityPropertiesAccess.java
index a4875f357e3..f43ce294c65 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaSecurityPropertiesAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaSecurityPropertiesAccess.java
@@ -27,6 +27,6 @@
 
 import java.util.Properties;
 
-public interface JavaSecurityPropertiesAccess {
+public non-sealed interface JavaSecurityPropertiesAccess extends Access {
     Properties getInitialProperties();
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaSecuritySignatureAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaSecuritySignatureAccess.java
index 28adeaff2e4..4d196e4ad56 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaSecuritySignatureAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaSecuritySignatureAccess.java
@@ -28,7 +28,7 @@
 import java.security.*;
 import java.security.spec.AlgorithmParameterSpec;
 
-public interface JavaSecuritySignatureAccess {
+public non-sealed interface JavaSecuritySignatureAccess extends Access {
 
     void initVerify(Signature s, PublicKey publicKey, AlgorithmParameterSpec params)
             throws InvalidKeyException, InvalidAlgorithmParameterException;
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaSecuritySpecAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaSecuritySpecAccess.java
index c370074ae3f..d6105d614f0 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaSecuritySpecAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaSecuritySpecAccess.java
@@ -27,6 +27,6 @@
 
 import java.security.spec.EncodedKeySpec;
 
-public interface JavaSecuritySpecAccess {
+public non-sealed interface JavaSecuritySpecAccess extends Access {
     void clearEncodedKeySpec(EncodedKeySpec keySpec);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
index 5e7647d6106..58f6c804a04 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
@@ -27,7 +27,7 @@
 
 import java.util.List;
 
-public interface JavaUtilCollectionAccess {
+public non-sealed interface JavaUtilCollectionAccess extends Access {
     <E> List<E> listFromTrustedArray(Object[] array);
     <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentFJPAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentFJPAccess.java
index 28c1b7fddee..498e5b08f1d 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentFJPAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentFJPAccess.java
@@ -26,7 +26,7 @@
 
 import java.util.concurrent.ForkJoinPool;
 
-public interface JavaUtilConcurrentFJPAccess {
+public non-sealed interface JavaUtilConcurrentFJPAccess extends Access {
     long beginCompensatedBlock(ForkJoinPool pool);
     void endCompensatedBlock(ForkJoinPool pool, long post);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentTLRAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentTLRAccess.java
index 29434e823a4..21155b09992 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentTLRAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilConcurrentTLRAccess.java
@@ -25,7 +25,7 @@
 
 package jdk.internal.access;
 
-public interface JavaUtilConcurrentTLRAccess {
+public non-sealed interface JavaUtilConcurrentTLRAccess extends Access {
     int nextSecondaryThreadLocalRandomSeed();
     int getThreadLocalRandomProbe();
     int advanceThreadLocalRandomProbe(int r);
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilJarAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilJarAccess.java
index fb266330323..ddfdc19f3df 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilJarAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilJarAccess.java
@@ -31,7 +31,7 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
-public interface JavaUtilJarAccess {
+public non-sealed interface JavaUtilJarAccess extends Access {
     public boolean jarFileHasClassPathAttribute(JarFile jar) throws IOException;
     public Attributes getTrustedAttributes(Manifest man, String name);
     public void ensureInitialization(JarFile jar);
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilResourceBundleAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilResourceBundleAccess.java
index fb8fda8f31a..499b096bec5 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilResourceBundleAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilResourceBundleAccess.java
@@ -31,7 +31,7 @@
 /**
  * Provides access to non-public methods in java.util.ResourceBundle.
  */
-public interface JavaUtilResourceBundleAccess {
+public non-sealed interface JavaUtilResourceBundleAccess extends Access {
     /**
      * Sets the bundle's parent to the given parent.
      */
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
index 9ff0f2e8b92..6d3d30b98f8 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
@@ -34,7 +34,7 @@
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
-public interface JavaUtilZipFileAccess {
+public non-sealed interface JavaUtilZipFileAccess extends Access {
     public boolean startsWithLocHeader(ZipFile zip);
     public List<String> getManifestAndSignatureRelatedFiles(JarFile zip);
     public String getManifestName(JarFile zip, boolean onlyIfSignatureRelatedFiles);
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSealedObjectAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSealedObjectAccess.java
index 0ab3c139dcb..804658f2ea2 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSealedObjectAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSealedObjectAccess.java
@@ -31,7 +31,7 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
-public interface JavaxCryptoSealedObjectAccess {
+public non-sealed interface JavaxCryptoSealedObjectAccess extends Access {
     ObjectInputStream getExtObjectInputStream(
             SealedObject sealed, Cipher cipher)
             throws BadPaddingException, IllegalBlockSizeException, IOException;
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSpecAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSpecAccess.java
index f8904cae4e6..42039cb8034 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSpecAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaxCryptoSpecAccess.java
@@ -27,6 +27,6 @@
 
 import javax.crypto.spec.SecretKeySpec;
 
-public interface JavaxCryptoSpecAccess {
+public non-sealed interface JavaxCryptoSpecAccess extends Access {
     void clearSecretKeySpec(SecretKeySpec keySpec);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/JavaxSecurityAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaxSecurityAccess.java
index 004b6db375b..d25c5d4129e 100644
--- a/src/java.base/share/classes/jdk/internal/access/JavaxSecurityAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaxSecurityAccess.java
@@ -28,7 +28,7 @@
 import javax.security.auth.x500.X500Principal;
 import sun.security.x509.X500Name;
 
-public interface JavaxSecurityAccess {
+public non-sealed interface JavaxSecurityAccess extends Access {
     X500Name asX500Name(X500Principal p);
     X500Principal asX500Principal(X500Name n);
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/SharedSecrets.java b/src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
index b0a71529fa7..3d55f1ea8f9 100644
--- a/src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
+++ b/src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
@@ -26,21 +26,24 @@
 package jdk.internal.access;
 
 import jdk.internal.vm.annotation.AOTSafeClassInitializer;
+import jdk.internal.vm.annotation.DontInline;
+import jdk.internal.vm.annotation.ForceInline;
 import jdk.internal.vm.annotation.Stable;
 
 import javax.crypto.SealedObject;
 import javax.crypto.spec.SecretKeySpec;
 import java.io.ObjectInputFilter;
+import java.lang.constant.Constable;
 import java.lang.invoke.MethodHandles;
 import java.lang.module.ModuleDescriptor;
 import java.security.Security;
 import java.security.spec.EncodedKeySpec;
+import java.util.Map;
 import java.util.ResourceBundle;
 import java.util.concurrent.ForkJoinPool;
 import java.util.jar.JarFile;
 import java.io.Console;
 import java.io.FileDescriptor;
-import java.io.FilePermission;
 import java.io.ObjectInputStream;
 import java.io.RandomAccessFile;
 import java.security.Signature;
@@ -73,31 +76,86 @@ interface and provides the ability to call package-private methods
  * cache creation will fail.
  */
 @AOTSafeClassInitializer
-public class SharedSecrets {
+public final class SharedSecrets {
+
+    // Sentinel value signaling that no explicit class initialization shall be performed
+    private static final String NO_INIT = "";
+
+    // This map is used to associate a certain Access interface to another class where
+    // the implementation of said interface resides
+    private static final Map<Class<? extends Access>, ? extends Constable> IMPLEMENTATIONS =
+            Map.ofEntries(
+                    Map.entry(JavaIOAccess.class                    , Console.class),
+                    Map.entry(JavaLangAccess.class                  , System.class),
+                    Map.entry(JavaLangInvokeAccess.class            , "java.lang.invoke.MethodHandleImpl"),
+                    Map.entry(JavaBeansAccess.class                 , NO_INIT),
+                    Map.entry(JavaLangModuleAccess.class            , ModuleDescriptor.class),
+                    Map.entry(JavaUtilJarAccess.class               , JarFile.class),
+                    Map.entry(JavaLangRefAccess.class               , NO_INIT),
+                    Map.entry(JavaLangReflectAccess.class           , NO_INIT),
+                    Map.entry(JavaIOFileDescriptorAccess.class      , FileDescriptor.class),
+                    Map.entry(JavaIORandomAccessFileAccess.class    , RandomAccessFile.class),
+                    Map.entry(JavaObjectInputStreamReadString.class , ObjectInputStream.class),
+                    Map.entry(JavaObjectInputStreamAccess.class     , ObjectInputStream.class),
+                    Map.entry(JavaObjectInputFilterAccess.class     , ObjectInputFilter.Config.class),
+                    Map.entry(JavaObjectStreamReflectionAccess.class, "java.io.ObjectStreamReflection$Access"),
+                    Map.entry(JavaNetInetAddressAccess.class        , java.net.InetAddress.class),
+                    Map.entry(JavaNetHttpCookieAccess.class         , java.net.HttpCookie.class),
+                    Map.entry(JavaNetUriAccess.class                , java.net.URI.class),
+                    Map.entry(JavaNetURLAccess.class                , java.net.URL.class)
+            );
+
+    private static final StableComponentContainer<Access> COMPONENTS =
+            StableComponentContainer.of(IMPLEMENTATIONS.keySet());
+
+    @ForceInline
+    public static <T extends Access> T get(Class<T> clazz) {
+        final T component = COMPONENTS.orElse(clazz, null);
+        return component == null
+                ? getSlowPath(clazz)
+                : component;
+    }
+
+    @DontInline
+    private static <T extends Access> T getSlowPath(Class<T> clazz) {
+        final Constable implementation = IMPLEMENTATIONS.get(clazz);
+        switch (implementation) {
+            case Class<?> c -> ensureClassInitialized(c);
+            case String s   -> { if (!s.equals(NO_INIT)) ensureClassInitialized(s); }
+            default         -> throw new InternalError("Should not reach here");
+        }
+        // The component should now be initialized
+        return COMPONENTS.get(clazz);
+    }
+
+    public static <T extends Access> void set(Class<T> type, T access) {
+        COMPONENTS.set(type, access);
+    }
+
     // This field is not necessarily stable
     private static JavaAWTFontAccess javaAWTFontAccess;
-    @Stable private static JavaBeansAccess javaBeansAccess;
-    @Stable private static JavaLangAccess javaLangAccess;
-    @Stable private static JavaLangInvokeAccess javaLangInvokeAccess;
-    @Stable private static JavaLangModuleAccess javaLangModuleAccess;
-    @Stable private static JavaLangRefAccess javaLangRefAccess;
-    @Stable private static JavaLangReflectAccess javaLangReflectAccess;
-    @Stable private static JavaIOAccess javaIOAccess;
-    @Stable private static JavaIOFileDescriptorAccess javaIOFileDescriptorAccess;
-    @Stable private static JavaIORandomAccessFileAccess javaIORandomAccessFileAccess;
-    @Stable private static JavaObjectInputStreamReadString javaObjectInputStreamReadString;
-    @Stable private static JavaObjectInputStreamAccess javaObjectInputStreamAccess;
-    @Stable private static JavaObjectInputFilterAccess javaObjectInputFilterAccess;
-    @Stable private static JavaObjectStreamReflectionAccess javaObjectStreamReflectionAccess;
-    @Stable private static JavaNetInetAddressAccess javaNetInetAddressAccess;
-    @Stable private static JavaNetHttpCookieAccess javaNetHttpCookieAccess;
-    @Stable private static JavaNetUriAccess javaNetUriAccess;
-    @Stable private static JavaNetURLAccess javaNetURLAccess;
+//    @Stable private static JavaBeansAccess javaBeansAccess;
+//    @Stable private static JavaLangAccess javaLangAccess;
+//    @Stable private static JavaLangInvokeAccess javaLangInvokeAccess;
+//    @Stable private static JavaLangModuleAccess javaLangModuleAccess;
+//    @Stable private static JavaLangRefAccess javaLangRefAccess;
+//    @Stable private static JavaLangReflectAccess javaLangReflectAccess;
+    //@Stable private static JavaIOAccess javaIOAccess;
+//    @Stable private static JavaIOFileDescriptorAccess javaIOFileDescriptorAccess;
+//    @Stable private static JavaIORandomAccessFileAccess javaIORandomAccessFileAccess;
+//    @Stable private static JavaObjectInputStreamReadString javaObjectInputStreamReadString;
+//    @Stable private static JavaObjectInputStreamAccess javaObjectInputStreamAccess;
+//    @Stable private static JavaObjectInputFilterAccess javaObjectInputFilterAccess;
+//    @Stable private static JavaObjectStreamReflectionAccess javaObjectStreamReflectionAccess;
+//    @Stable private static JavaNetInetAddressAccess javaNetInetAddressAccess;
+//    @Stable private static JavaNetHttpCookieAccess javaNetHttpCookieAccess;
+//    @Stable private static JavaNetUriAccess javaNetUriAccess;
+//    @Stable private static JavaNetURLAccess javaNetURLAccess;
     @Stable private static JavaNioAccess javaNioAccess;
     @Stable private static JavaUtilCollectionAccess javaUtilCollectionAccess;
     @Stable private static JavaUtilConcurrentTLRAccess javaUtilConcurrentTLRAccess;
     @Stable private static JavaUtilConcurrentFJPAccess javaUtilConcurrentFJPAccess;
-    @Stable private static JavaUtilJarAccess javaUtilJarAccess;
+//    @Stable private static JavaUtilJarAccess javaUtilJarAccess;
     @Stable private static JavaUtilZipFileAccess javaUtilZipFileAccess;
     @Stable private static JavaUtilResourceBundleAccess javaUtilResourceBundleAccess;
     @Stable private static JavaSecurityPropertiesAccess javaSecurityPropertiesAccess;
@@ -150,125 +208,6 @@ public static JavaUtilConcurrentFJPAccess getJavaUtilConcurrentFJPAccess() {
         return access;
     }
 
-    public static JavaUtilJarAccess javaUtilJarAccess() {
-        var access = javaUtilJarAccess;
-        if (access == null) {
-            // Ensure JarFile is initialized; we know that this class
-            // provides the shared secret
-            ensureClassInitialized(JarFile.class);
-            access = javaUtilJarAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaUtilJarAccess(JavaUtilJarAccess access) {
-        javaUtilJarAccess = access;
-    }
-
-    public static void setJavaLangAccess(JavaLangAccess jla) {
-        javaLangAccess = jla;
-    }
-
-    public static JavaLangAccess getJavaLangAccess() {
-        return javaLangAccess;
-    }
-
-    public static void setJavaLangInvokeAccess(JavaLangInvokeAccess jlia) {
-        javaLangInvokeAccess = jlia;
-    }
-
-    public static JavaLangInvokeAccess getJavaLangInvokeAccess() {
-        var access = javaLangInvokeAccess;
-        if (access == null) {
-            try {
-                Class.forName("java.lang.invoke.MethodHandleImpl", true, null);
-                access = javaLangInvokeAccess;
-            } catch (ClassNotFoundException e) {}
-        }
-        return access;
-    }
-
-    public static void setJavaLangModuleAccess(JavaLangModuleAccess jlrma) {
-        javaLangModuleAccess = jlrma;
-    }
-
-    public static JavaLangModuleAccess getJavaLangModuleAccess() {
-        var access = javaLangModuleAccess;
-        if (access == null) {
-            ensureClassInitialized(ModuleDescriptor.class);
-            access = javaLangModuleAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaLangRefAccess(JavaLangRefAccess jlra) {
-        javaLangRefAccess = jlra;
-    }
-
-    public static JavaLangRefAccess getJavaLangRefAccess() {
-        return javaLangRefAccess;
-    }
-
-    public static void setJavaLangReflectAccess(JavaLangReflectAccess jlra) {
-        javaLangReflectAccess = jlra;
-    }
-
-    public static JavaLangReflectAccess getJavaLangReflectAccess() {
-        return javaLangReflectAccess;
-    }
-
-    public static void setJavaNetUriAccess(JavaNetUriAccess jnua) {
-        javaNetUriAccess = jnua;
-    }
-
-    public static JavaNetUriAccess getJavaNetUriAccess() {
-        var access = javaNetUriAccess;
-        if (access == null) {
-            ensureClassInitialized(java.net.URI.class);
-            access = javaNetUriAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaNetURLAccess(JavaNetURLAccess jnua) {
-        javaNetURLAccess = jnua;
-    }
-
-    public static JavaNetURLAccess getJavaNetURLAccess() {
-        var access = javaNetURLAccess;
-        if (access == null) {
-            ensureClassInitialized(java.net.URL.class);
-            access = javaNetURLAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaNetInetAddressAccess(JavaNetInetAddressAccess jna) {
-        javaNetInetAddressAccess = jna;
-    }
-
-    public static JavaNetInetAddressAccess getJavaNetInetAddressAccess() {
-        var access = javaNetInetAddressAccess;
-        if (access == null) {
-            ensureClassInitialized(java.net.InetAddress.class);
-            access = javaNetInetAddressAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaNetHttpCookieAccess(JavaNetHttpCookieAccess a) {
-        javaNetHttpCookieAccess = a;
-    }
-
-    public static JavaNetHttpCookieAccess getJavaNetHttpCookieAccess() {
-        var access = javaNetHttpCookieAccess;
-        if (access == null) {
-            ensureClassInitialized(java.net.HttpCookie.class);
-            access = javaNetHttpCookieAccess;
-        }
-        return access;
-    }
-
     public static void setJavaNioAccess(JavaNioAccess jna) {
         javaNioAccess = jna;
     }
@@ -284,32 +223,6 @@ public static JavaNioAccess getJavaNioAccess() {
         return access;
     }
 
-    public static void setJavaIOAccess(JavaIOAccess jia) {
-        javaIOAccess = jia;
-    }
-
-    public static JavaIOAccess getJavaIOAccess() {
-        var access = javaIOAccess;
-        if (access == null) {
-            ensureClassInitialized(Console.class);
-            access = javaIOAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaIOFileDescriptorAccess(JavaIOFileDescriptorAccess jiofda) {
-        javaIOFileDescriptorAccess = jiofda;
-    }
-
-    public static JavaIOFileDescriptorAccess getJavaIOFileDescriptorAccess() {
-        var access = javaIOFileDescriptorAccess;
-        if (access == null) {
-            ensureClassInitialized(FileDescriptor.class);
-            access = javaIOFileDescriptorAccess;
-        }
-        return access;
-    }
-
     public static void setJavaSecurityPropertiesAccess(JavaSecurityPropertiesAccess jspa) {
         javaSecurityPropertiesAccess = jspa;
     }
@@ -346,14 +259,6 @@ public static JavaAWTFontAccess getJavaAWTFontAccess() {
         return javaAWTFontAccess;
     }
 
-    public static JavaBeansAccess getJavaBeansAccess() {
-        return javaBeansAccess;
-    }
-
-    public static void setJavaBeansAccess(JavaBeansAccess access) {
-        javaBeansAccess = access;
-    }
-
     public static JavaUtilResourceBundleAccess getJavaUtilResourceBundleAccess() {
         var access = javaUtilResourceBundleAccess;
         if (access == null) {
@@ -367,73 +272,6 @@ public static void setJavaUtilResourceBundleAccess(JavaUtilResourceBundleAccess
         javaUtilResourceBundleAccess = access;
     }
 
-    public static JavaObjectInputStreamReadString getJavaObjectInputStreamReadString() {
-        var access = javaObjectInputStreamReadString;
-        if (access == null) {
-            ensureClassInitialized(ObjectInputStream.class);
-            access = javaObjectInputStreamReadString;
-        }
-        return access;
-    }
-
-    public static void setJavaObjectInputStreamReadString(JavaObjectInputStreamReadString access) {
-        javaObjectInputStreamReadString = access;
-    }
-
-    public static JavaObjectInputStreamAccess getJavaObjectInputStreamAccess() {
-        var access = javaObjectInputStreamAccess;
-        if (access == null) {
-            ensureClassInitialized(ObjectInputStream.class);
-            access = javaObjectInputStreamAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaObjectInputStreamAccess(JavaObjectInputStreamAccess access) {
-        javaObjectInputStreamAccess = access;
-    }
-
-    public static JavaObjectInputFilterAccess getJavaObjectInputFilterAccess() {
-        var access = javaObjectInputFilterAccess;
-        if (access == null) {
-            ensureClassInitialized(ObjectInputFilter.Config.class);
-            access = javaObjectInputFilterAccess;
-        }
-        return access;
-    }
-
-    public static void setJavaObjectInputFilterAccess(JavaObjectInputFilterAccess access) {
-        javaObjectInputFilterAccess = access;
-    }
-
-    public static JavaObjectStreamReflectionAccess getJavaObjectStreamReflectionAccess() {
-        var access = javaObjectStreamReflectionAccess;
-        if (access == null) {
-            try {
-                Class.forName("java.io.ObjectStreamReflection$Access", true, null);
-                access = javaObjectStreamReflectionAccess;
-            } catch (ClassNotFoundException e) {}
-        }
-        return access;
-    }
-
-    public static void setJavaObjectStreamReflectionAccess(JavaObjectStreamReflectionAccess access) {
-        javaObjectStreamReflectionAccess = access;
-    }
-
-    public static void setJavaIORandomAccessFileAccess(JavaIORandomAccessFileAccess jirafa) {
-        javaIORandomAccessFileAccess = jirafa;
-    }
-
-    public static JavaIORandomAccessFileAccess getJavaIORandomAccessFileAccess() {
-        var access = javaIORandomAccessFileAccess;
-        if (access == null) {
-            ensureClassInitialized(RandomAccessFile.class);
-            access = javaIORandomAccessFileAccess;
-        }
-        return access;
-    }
-
     public static void setJavaSecuritySignatureAccess(JavaSecuritySignatureAccess jssa) {
         javaSecuritySignatureAccess = jssa;
     }
@@ -502,6 +340,12 @@ public static JavaxSecurityAccess getJavaxSecurityAccess() {
     private static void ensureClassInitialized(Class<?> c) {
         try {
             MethodHandles.lookup().ensureInitialized(c);
-        } catch (IllegalAccessException e) {}
+        } catch (IllegalAccessException _) {}
+    }
+
+    private static void ensureClassInitialized(String className) {
+        try {
+            Class.forName(className, true, null);
+        } catch (ClassNotFoundException _) {}
     }
 }
diff --git a/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java b/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java
new file mode 100644
index 00000000000..c5a45cadcfa
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/access/StableComponentContainer.java
@@ -0,0 +1,128 @@
+package jdk.internal.access;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.Function;
+
+// This class is required to be able to be used very early in the boot sequence.
+// Because of this, it does not use reflection, MethodHandles, or ImmutableCollections
+/**
+ * A thread-safe, concurrent, lock-free, stable heterogeneous container.
+ * <p>
+ * The lookup of components can be eligible for constant folding if the stable component
+ * container is a VM constant (e.g., is declared as a `static final` field) and the
+ * lookup key is a constant (e.g., a class literal).
+ * <p>
+ * Except if otherwise specified, all methods throw a {@linkplain NullPointerException}
+ * if a {@code null} parameter is provided.
+ *
+ * @param <T> The common type of the components. The type can be {@linkplain Object} if
+ *            there is no common super type for the components.
+ */
+public sealed interface StableComponentContainer<T> permits StableComponentContainerImpl {
+
+    /**
+     * {@return the associated component for the provided {@code type}}
+     *
+     * @param type to use as lookup
+     * @param <C> component type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C get(Class<C> type);
+
+    /**
+     * {@return the associated component for the provided {@code type}}, or else the
+     *          provided {@code other} value.
+     *
+     * @param type to use as lookup
+     * @param other to return if there is no association to the provided {@code type}
+     *              (nullable)
+     * @param <C> component type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C orElse(Class<C> type, C other);
+
+    /**
+     * {@return {@code true} if, and only if, there is an associated component for
+     *          the provided {@code type}}, or else {@code false}}
+     *
+     * @param type to use as lookup
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    boolean isInitialized(Class<? extends T> type);
+
+    /**
+     * Associates the provided {@code type} with the provided {@code component}
+     *
+     * @param type to use as lookup
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     * @throws IllegalStateException if the provided {@code type} was already associated
+     *         with a component
+     */
+    <C extends T> void set(Class<C> type, C component);
+
+    /**
+     * If the specified type is not already associated with a component,
+     * attempts to compute its value using the given mapping
+     * function and enters it into this container.
+     *<p>
+     * If the mapping function itself throws an (unchecked) exception, the
+     * exception is rethrown, and no association is recorded. The most
+     * common usage is to construct a new object serving as an initial
+     * mapped value or memoized result, as in:
+     *
+     * <pre> {@code
+     * Component component = container.computeIfAbsent(Component.class, k -> new ComponentImpl(f(k)));
+     * }</pre>
+     *
+     * <p>The mapping function should not modify this container during computation.
+     *
+     * @implSpec
+     * The implementation is equivalent to the following steps for this
+     * {@code container}, then returning the current value or {@code null} if now
+     * absent:
+     *
+     * <pre> {@code
+     * if (!map.isInitialized(key)) {
+     *     map.put(key, mappingFunction.apply(key));
+     * }
+     * }</pre>
+     * <p>
+     * The implementation makes no guarantees about synchronization
+     * or atomicity properties of this method.
+     *
+     * @param type with which the to-be-computed component is to be associated
+     * @param mappingFunction the mapping function to compute a component
+     * @return the current (existing or computed) component associated with
+     *         the specified type
+     * @throws IllegalArgumentException if the provided {@code type} was not specified
+     *         {@linkplain StableComponentContainer#of(Set) at construction}.
+     */
+    <C extends T> C computeIfAbsent(Class<C> type,
+                                    Function<Class<C>, ? extends C> mappingFunction);
+
+    /**
+     * {@return a new stable component container that can associate any of the provided
+     *          {@code types} to components}
+     *
+     * @param types that can be used to associate to components
+     * @param <T>   the common type of the components. The type can be {@linkplain Object}
+     *              if there is no common super type for the components.
+     */
+    static <T> StableComponentContainer<T> of(Set<Class<? extends T>> types) {
+        // TOC TOU protection and
+        // implicit null check of `types` and explicit null check on all its elements
+        final Object[] inputs = new Object[types.size()];
+        int idx = 0;
+        for (Object type : types) {
+            inputs[idx++] = Objects.requireNonNull(type);
+        }
+        return StableComponentContainerImpl.of(inputs);
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java b/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java
new file mode 100644
index 00000000000..acbb296aa98
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/access/StableComponentContainerImpl.java
@@ -0,0 +1,142 @@
+package jdk.internal.access;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.AOTSafeClassInitializer;
+import jdk.internal.vm.annotation.ForceInline;
+import jdk.internal.vm.annotation.Stable;
+
+import java.util.Objects;
+import java.util.StringJoiner;
+import java.util.function.Function;
+
+@AOTSafeClassInitializer
+record StableComponentContainerImpl<T>(@Stable Object[] table) implements StableComponentContainer<T> {
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    @ForceInline
+    public <C extends T> C get(Class<C> type) {
+        return type.cast(componentRaw(type));
+    }
+
+    public boolean isInitialized(Class<? extends T> type) {
+        return componentRaw(type) != null;
+    }
+
+    @Override
+    public <C extends T> C orElse(Class<C> type, C other) {
+        final Object componentRaw = componentRaw(type);
+        return componentRaw == null ? other : type.cast(componentRaw);
+    }
+
+    @ForceInline
+    private Object componentRaw(Class<?> type) {
+        Objects.requireNonNull(type);
+        final int probe = probeOrThrow(type);
+        return UNSAFE.getReferenceAcquire(table, nextOffset(offsetFor(probe)));
+    }
+
+    public <C extends T> void set(Class<C> type, C component) {
+        set0(type, component, true);
+    }
+
+    @ForceInline
+    public <C extends T> void set0(Class<C> type, C component, boolean setSemantics) {
+        Objects.requireNonNull(component);
+        // Implicit null check of `type`
+        if (!type.isInstance(component)) {
+            throw new IllegalArgumentException("The component '" + component + "' is not an instance of " + type);
+        }
+        final int probe = probeOrThrow(type);
+        if (!UNSAFE.compareAndSetReference(table, nextOffset(offsetFor(probe)), null, component) && setSemantics) {
+            throw new IllegalStateException("The component is already initialized: " + type.getName());
+        }
+    }
+
+    @ForceInline
+    @Override
+    public <C extends T> C computeIfAbsent(Class<C> type,
+                                           Function<Class<C>, ? extends C> mappingFunction) {
+        Objects.requireNonNull(mappingFunction);
+        C c;
+        if ((c = orElse(type, null)) == null) {
+            // Allow racy sets as several threads can race to set the value
+            set0(type, c = mappingFunction.apply(type), false);
+        }
+        return c;
+    }
+
+    @Override
+    public String toString() {
+        return "StableComponentContainer" + associations(true);
+    }
+
+    private String associations(boolean showValues) {
+        final StringJoiner sj = new StringJoiner(", ");
+        for (int i = 0; i < table.length; i += 2) {
+            final Class<?> type = (Class<?>) table[i];
+            if (type != null) {
+                if (showValues) {
+                    final Object component = UNSAFE.getReferenceAcquire(table, nextOffset(offsetFor(i)));
+                    sj.add(type.getName() + (component != null ? "=" + component : ""));
+                } else {
+                    sj.add(type.toString());
+                }
+            }
+        }
+        return "{" + sj + "}";
+    }
+
+    @ForceInline
+    private int probeOrThrow(Class<?> type) {
+        final int probe = probe(table, type);
+        if (probe < 0) {
+            throw new IllegalArgumentException("The type '" + type.getName() + "' is outside the allowed input types: " + associations(false));
+        }
+        return probe;
+    }
+
+    @ForceInline
+    private long offsetFor(int index) {
+        return Unsafe.ARRAY_OBJECT_BASE_OFFSET + (long) index * Unsafe.ARRAY_OBJECT_INDEX_SCALE;
+    }
+
+    @ForceInline
+    private long nextOffset(long offset) {
+        return offset + Unsafe.ARRAY_OBJECT_INDEX_SCALE;
+    }
+
+    // returns index at which the probe key is present; or if absent,
+    // (-i - 1) where i is location where element should be inserted.
+    @ForceInline
+    private static int probe(Object[] table, Object pk) {
+        int idx = Math.floorMod(pk.hashCode(), table.length >> 1) << 1;
+        while (true) {
+            Object ek = table[idx];
+            if (ek == null) {
+                return -idx - 1;
+            } else if (pk.equals(ek)) {
+                return idx;
+            } else if ((idx += 2) == table.length) {
+                idx = 0;
+            }
+        }
+    }
+
+    private static int availableIndex(int probe) {
+        return -probe - 1;
+    }
+
+    static <T> StableComponentContainer<T> of(Object[] inputs) {
+        // Prepopulate all the keys upfront
+        final Object[] table = new Object[inputs.length << 2];
+        for (Object type : inputs) {
+            final int probe = probe(table, type);
+            assert probe < 0;
+            final int keyIndex = availableIndex(probe);
+            table[keyIndex] = type;
+        }
+        return new StableComponentContainerImpl<>(table);
+    }
+
+}
diff --git a/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java b/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java
index ec747d06c21..b0c7b31419a 100644
--- a/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java
+++ b/src/java.base/share/classes/jdk/internal/classfile/impl/AbstractPoolEntry.java
@@ -125,7 +125,7 @@ public static final class Utf8EntryImpl extends AbstractPoolEntry implements Utf
 
         enum State { RAW, BYTE, CHAR, STRING }
 
-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+        private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
         private State state;
         private final byte[] rawBytes; // null if initialized directly from a string
diff --git a/src/java.base/share/classes/jdk/internal/classfile/impl/BufWriterImpl.java b/src/java.base/share/classes/jdk/internal/classfile/impl/BufWriterImpl.java
index 6daef5cab9a..fa61f4aa80e 100644
--- a/src/java.base/share/classes/jdk/internal/classfile/impl/BufWriterImpl.java
+++ b/src/java.base/share/classes/jdk/internal/classfile/impl/BufWriterImpl.java
@@ -42,7 +42,7 @@
 import static jdk.internal.util.ModifiedUtf.utfLen;
 
 public final class BufWriterImpl implements BufWriter {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private final ConstantPoolBuilder constantPool;
     private final ClassFileImpl context;
diff --git a/src/java.base/share/classes/jdk/internal/constant/ConstantUtils.java b/src/java.base/share/classes/jdk/internal/constant/ConstantUtils.java
index 15a178d7b29..636fbe78990 100644
--- a/src/java.base/share/classes/jdk/internal/constant/ConstantUtils.java
+++ b/src/java.base/share/classes/jdk/internal/constant/ConstantUtils.java
@@ -44,7 +44,7 @@
  */
 @AOTSafeClassInitializer // initialization dependency of PrimitiveClassDescImpl
 public final class ConstantUtils {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /** an empty constant descriptor */
     public static final ConstantDesc[] EMPTY_CONSTANTDESC = new ConstantDesc[0];
diff --git a/src/java.base/share/classes/jdk/internal/event/EventHelper.java b/src/java.base/share/classes/jdk/internal/event/EventHelper.java
index 4da2d5854cb..13ed09bf7ad 100644
--- a/src/java.base/share/classes/jdk/internal/event/EventHelper.java
+++ b/src/java.base/share/classes/jdk/internal/event/EventHelper.java
@@ -43,7 +43,7 @@
 
 public final class EventHelper {
 
-    private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
+    private static final JavaUtilJarAccess JUJA = SharedSecrets.get(JavaUtilJarAccess.class);
     private static volatile boolean loggingSecurity;
     private static volatile System.Logger securityLogger;
     private static final VarHandle LOGGER_HANDLE;
diff --git a/src/java.base/share/classes/jdk/internal/foreign/StringSupport.java b/src/java.base/share/classes/jdk/internal/foreign/StringSupport.java
index 208c6d54aab..4fe78372af9 100644
--- a/src/java.base/share/classes/jdk/internal/foreign/StringSupport.java
+++ b/src/java.base/share/classes/jdk/internal/foreign/StringSupport.java
@@ -43,7 +43,7 @@
  */
 public final class StringSupport {
 
-    private static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.get(JavaLangAccess.class);
     private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();
     private static final long LONG_MASK = ~7L; // The last three bits are zero
 
diff --git a/src/java.base/share/classes/jdk/internal/foreign/Utils.java b/src/java.base/share/classes/jdk/internal/foreign/Utils.java
index 4214b0395b8..4f755536369 100644
--- a/src/java.base/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/java.base/share/classes/jdk/internal/foreign/Utils.java
@@ -25,6 +25,7 @@
 
 package jdk.internal.foreign;
 
+import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.Unsafe;
@@ -138,7 +139,7 @@ private static VarHandle makeRawSegmentViewVarHandleInternal(MemoryLayout enclos
             baseCarrier = ADDRESS_CARRIER_TYPE;
         }
 
-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,
+        VarHandle handle = SharedSecrets.get(JavaLangInvokeAccess.class).memorySegmentViewHandle(baseCarrier,
                 enclosing, layout.byteAlignment() - 1, layout.order(), constantOffset, offset);
 
         if (layout instanceof AddressLayout addressLayout) {
diff --git a/src/java.base/share/classes/jdk/internal/foreign/abi/DowncallLinker.java b/src/java.base/share/classes/jdk/internal/foreign/abi/DowncallLinker.java
index acdbef5822d..0b4d6bf3e03 100644
--- a/src/java.base/share/classes/jdk/internal/foreign/abi/DowncallLinker.java
+++ b/src/java.base/share/classes/jdk/internal/foreign/abi/DowncallLinker.java
@@ -50,7 +50,7 @@ public class DowncallLinker {
     private static final boolean USE_SPEC = Boolean.parseBoolean(
             System.getProperty("jdk.internal.foreign.DowncallLinker.USE_SPEC", "true"));
 
-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.get(JavaLangInvokeAccess.class);
 
     private static final MethodHandle MH_INVOKE_INTERP_BINDINGS = MhUtil.findVirtual(
             MethodHandles.lookup(), DowncallLinker.class, "invokeInterpBindings",
diff --git a/src/java.base/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/java.base/share/classes/jdk/internal/foreign/abi/SharedUtils.java
index 37200598d5b..e09f6d16541 100644
--- a/src/java.base/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/java.base/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -72,7 +72,7 @@ public final class SharedUtils {
     private SharedUtils() {
     }
 
-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.get(JavaLangInvokeAccess.class);
 
     private static final MethodHandle MH_ALLOC_BUFFER;
     private static final MethodHandle MH_BUFFER_COPY;
diff --git a/src/java.base/share/classes/jdk/internal/io/JdkConsoleImpl.java b/src/java.base/share/classes/jdk/internal/io/JdkConsoleImpl.java
index a6f4174324e..d3df66f723f 100644
--- a/src/java.base/share/classes/jdk/internal/io/JdkConsoleImpl.java
+++ b/src/java.base/share/classes/jdk/internal/io/JdkConsoleImpl.java
@@ -41,6 +41,8 @@
 import java.util.Optional;
 import java.util.function.Supplier;
 
+import jdk.internal.access.JavaIOAccess;
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.StaticProperty;
 import sun.nio.cs.StreamDecoder;
@@ -126,7 +128,7 @@ public Optional<JdkConsoleImpl> get() {
 
                     // If stdin is NOT redirected, return an Optional containing a JdkConsoleImpl
                     // instance, otherwise an empty Optional.
-                    return SharedSecrets.getJavaIOAccess().isStdinTty() ?
+                    return SharedSecrets.get(JavaIOAccess.class).isStdinTty() ?
                             Optional.of(
                                     new JdkConsoleImpl(
                                             Charset.forName(StaticProperty.stdinEncoding(), UTF_8.INSTANCE),
@@ -207,7 +209,7 @@ private void installShutdownHook() {
         try {
             // Add a shutdown hook to restore console's echo state should
             // it be necessary.
-            SharedSecrets.getJavaLangAccess()
+            SharedSecrets.get(JavaLangAccess.class)
                     .registerShutdownHook(0 /* shutdown hook invocation order */,
                             false /* only register if shutdown is not in progress */,
                             new Runnable() {
diff --git a/src/java.base/share/classes/jdk/internal/loader/AbstractClassLoaderValue.java b/src/java.base/share/classes/jdk/internal/loader/AbstractClassLoaderValue.java
index 739f9c0d65e..e7da5eda873 100644
--- a/src/java.base/share/classes/jdk/internal/loader/AbstractClassLoaderValue.java
+++ b/src/java.base/share/classes/jdk/internal/loader/AbstractClassLoaderValue.java
@@ -253,7 +253,7 @@ public void removeAll(ClassLoader cl) {
         }
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * @return a ConcurrentHashMap for given ClassLoader
diff --git a/src/java.base/share/classes/jdk/internal/loader/BootLoader.java b/src/java.base/share/classes/jdk/internal/loader/BootLoader.java
index 72c7e7e7451..2f3b30c9e0a 100644
--- a/src/java.base/share/classes/jdk/internal/loader/BootLoader.java
+++ b/src/java.base/share/classes/jdk/internal/loader/BootLoader.java
@@ -53,14 +53,14 @@
 public class BootLoader {
     private BootLoader() { }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     // The unnamed module for the boot loader
     private static final Module UNNAMED_MODULE;
     private static final String JAVA_HOME = StaticProperty.javaHome();
 
     static {
-        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+        JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
         ArchivedClassLoaders archivedClassLoaders = ArchivedClassLoaders.get();
         if (archivedClassLoaders != null) {
             UNNAMED_MODULE = archivedClassLoaders.unnamedModuleForBootLoader();
@@ -223,7 +223,7 @@ public static Stream<Package> packages() {
      * defined to the boot loader.
      */
     static class PackageHelper {
-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+        private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
         /**
          * Define the {@code Package} with the given name. The specified
diff --git a/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java b/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
index f6cc79fd127..255e88c62d0 100644
--- a/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
+++ b/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
@@ -52,6 +52,7 @@
 import java.util.jar.Manifest;
 import java.util.stream.Stream;
 
+import jdk.internal.access.JavaUtilJarAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.module.ModulePatcher.PatchedModuleReader;
@@ -851,7 +852,7 @@ private Package definePackage(String pn, Manifest man, URL url) {
         URL sealBase = null;
 
         if (man != null) {
-            Attributes attr = SharedSecrets.javaUtilJarAccess()
+            Attributes attr = SharedSecrets.get(JavaUtilJarAccess.class)
                     .getTrustedAttributes(man, pn.replace('.', '/').concat("/"));
             if (attr != null) {
                 specTitle = attr.getValue(Attributes.Name.SPECIFICATION_TITLE);
@@ -902,7 +903,7 @@ private Package definePackage(String pn, Manifest man, URL url) {
      * @throws SecurityException if the package name is untrusted in the manifest
      */
     private boolean isSealed(String pn, Manifest man) {
-        Attributes attr = SharedSecrets.javaUtilJarAccess()
+        Attributes attr = SharedSecrets.get(JavaUtilJarAccess.class)
                 .getTrustedAttributes(man, pn.replace('.', '/').concat("/"));
         String sealed = null;
         if (attr != null)
diff --git a/src/java.base/share/classes/jdk/internal/loader/ClassLoaders.java b/src/java.base/share/classes/jdk/internal/loader/ClassLoaders.java
index 1a61d4b1522..3218a429c7c 100644
--- a/src/java.base/share/classes/jdk/internal/loader/ClassLoaders.java
+++ b/src/java.base/share/classes/jdk/internal/loader/ClassLoaders.java
@@ -46,7 +46,7 @@ public class ClassLoaders {
 
     private ClassLoaders() { }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     // the built-in class loaders
     private static final BootClassLoader BOOT_LOADER;
diff --git a/src/java.base/share/classes/jdk/internal/loader/Loader.java b/src/java.base/share/classes/jdk/internal/loader/Loader.java
index c4f9023482d..a368561ca7a 100644
--- a/src/java.base/share/classes/jdk/internal/loader/Loader.java
+++ b/src/java.base/share/classes/jdk/internal/loader/Loader.java
@@ -51,6 +51,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Stream;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.module.Resources;
 
@@ -283,7 +284,7 @@ private void remotePackage(String pn, ClassLoader loader) {
      * of layers rooted at the given parent.
      */
     private Optional<ModuleLayer> findModuleLayer(ModuleLayer parent, Configuration cf) {
-        return SharedSecrets.getJavaLangAccess().layers(parent)
+        return SharedSecrets.get(JavaLangAccess.class).layers(parent)
                 .filter(l -> l.configuration() == cf)
                 .findAny();
     }
diff --git a/src/java.base/share/classes/jdk/internal/loader/URLClassPath.java b/src/java.base/share/classes/jdk/internal/loader/URLClassPath.java
index 3504ce7e8b3..501744a857a 100644
--- a/src/java.base/share/classes/jdk/internal/loader/URLClassPath.java
+++ b/src/java.base/share/classes/jdk/internal/loader/URLClassPath.java
@@ -60,6 +60,7 @@
 import java.util.zip.ZipFile;
 
 import jdk.internal.access.JavaNetURLAccess;
+import jdk.internal.access.JavaUtilJarAccess;
 import jdk.internal.access.JavaUtilZipFileAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.net.util.URLUtil;
@@ -467,7 +468,7 @@ private Loader getLoader(final URL url) throws IOException {
     }
 
     private static final JavaNetURLAccess JNUA
-            = SharedSecrets.getJavaNetURLAccess();
+            = SharedSecrets.get(JavaNetURLAccess.class);
 
     private static boolean isDefaultJarHandler(URL u) {
         URLStreamHandler h = JNUA.getHandler(u);
@@ -717,7 +718,7 @@ public InputStream getInputStream() throws IOException
                 public int getContentLength()
                     { return (int)entry.getSize(); }
                 public Manifest getManifest() throws IOException {
-                    SharedSecrets.javaUtilJarAccess().ensureInitialization(jar);
+                    SharedSecrets.get(JavaUtilJarAccess.class).ensureInitialization(jar);
                     return jar.getManifest();
                 }
                 public Certificate[] getCertificates()
@@ -776,7 +777,7 @@ URL[] getClassPath() throws IOException {
             ensureOpen();
 
             // Only get manifest when necessary
-            if (SharedSecrets.javaUtilJarAccess().jarFileHasClassPathAttribute(jar)) {
+            if (SharedSecrets.get(JavaUtilJarAccess.class).jarFileHasClassPathAttribute(jar)) {
                 Manifest man = jar.getManifest();
                 if (man != null) {
                     Attributes attr = man.getMainAttributes();
diff --git a/src/java.base/share/classes/jdk/internal/math/ToDecimal.java b/src/java.base/share/classes/jdk/internal/math/ToDecimal.java
index 22f9e5a338d..68c78d70fd8 100644
--- a/src/java.base/share/classes/jdk/internal/math/ToDecimal.java
+++ b/src/java.base/share/classes/jdk/internal/math/ToDecimal.java
@@ -32,7 +32,7 @@
 import static java.lang.Math.multiplyHigh;
 
 abstract sealed class ToDecimal permits DoubleToDecimal, FloatToDecimal {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /* Used for left-to-tight digit extraction */
     static final int MASK_28 = (1 << 28) - 1;
diff --git a/src/java.base/share/classes/jdk/internal/misc/Blocker.java b/src/java.base/share/classes/jdk/internal/misc/Blocker.java
index d41ae73709f..c4c7e1ba03a 100644
--- a/src/java.base/share/classes/jdk/internal/misc/Blocker.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Blocker.java
@@ -47,7 +47,7 @@
 public class Blocker {
     private static final JavaLangAccess JLA;
     static {
-        JLA = SharedSecrets.getJavaLangAccess();
+        JLA = SharedSecrets.get(JavaLangAccess.class);
         if (JLA == null) {
             throw new InternalError("JavaLangAccess not setup");
         }
diff --git a/src/java.base/share/classes/jdk/internal/misc/CDS.java b/src/java.base/share/classes/jdk/internal/misc/CDS.java
index b61743c1fb3..d2a0f41fbd9 100644
--- a/src/java.base/share/classes/jdk/internal/misc/CDS.java
+++ b/src/java.base/share/classes/jdk/internal/misc/CDS.java
@@ -42,6 +42,7 @@
 import java.util.jar.JarFile;
 import java.util.stream.Stream;
 
+import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.util.StaticProperty;
 
@@ -235,7 +236,7 @@ private static Object[] generateLambdaFormHolderClasses(String[] lines) {
         Objects.requireNonNull(lines);
         validateInputLines(lines);
         Stream<String> lineStream = Arrays.stream(lines);
-        Map<String, byte[]> result = SharedSecrets.getJavaLangInvokeAccess().generateHolderClasses(lineStream);
+        Map<String, byte[]> result = SharedSecrets.get(JavaLangInvokeAccess.class).generateHolderClasses(lineStream);
         int size = result.size();
         Object[] retArray = new Object[size * 2];
         int index = 0;
diff --git a/src/java.base/share/classes/jdk/internal/misc/CarrierThread.java b/src/java.base/share/classes/jdk/internal/misc/CarrierThread.java
index b314b1823a5..7571f25b675 100644
--- a/src/java.base/share/classes/jdk/internal/misc/CarrierThread.java
+++ b/src/java.base/share/classes/jdk/internal/misc/CarrierThread.java
@@ -36,7 +36,7 @@
  * A ForkJoinWorkerThread that can be used as a carrier thread.
  */
 public class CarrierThread extends ForkJoinWorkerThread {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     private static final Unsafe U = Unsafe.getUnsafe();
 
     private static final ThreadGroup CARRIER_THREADGROUP = carrierThreadGroup();
diff --git a/src/java.base/share/classes/jdk/internal/misc/CarrierThreadLocal.java b/src/java.base/share/classes/jdk/internal/misc/CarrierThreadLocal.java
index 9396521cad5..4a05ab090e7 100644
--- a/src/java.base/share/classes/jdk/internal/misc/CarrierThreadLocal.java
+++ b/src/java.base/share/classes/jdk/internal/misc/CarrierThreadLocal.java
@@ -49,5 +49,5 @@ public void remove() {
         JLA.removeCarrierThreadLocal(this);
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 }
diff --git a/src/java.base/share/classes/jdk/internal/misc/MethodFinder.java b/src/java.base/share/classes/jdk/internal/misc/MethodFinder.java
index 60895b8115a..caec1d1b735 100644
--- a/src/java.base/share/classes/jdk/internal/misc/MethodFinder.java
+++ b/src/java.base/share/classes/jdk/internal/misc/MethodFinder.java
@@ -36,7 +36,7 @@
  */
 public class MethodFinder {
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private MethodFinder() {
         throw new AssertionError("private constructor");
diff --git a/src/java.base/share/classes/jdk/internal/misc/ThreadFlock.java b/src/java.base/share/classes/jdk/internal/misc/ThreadFlock.java
index 32f6d5d4905..31744672f5f 100644
--- a/src/java.base/share/classes/jdk/internal/misc/ThreadFlock.java
+++ b/src/java.base/share/classes/jdk/internal/misc/ThreadFlock.java
@@ -81,7 +81,7 @@
  * in this class will cause a {@link NullPointerException} to be thrown.
  */
 public class ThreadFlock implements AutoCloseable {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     private static final VarHandle THREAD_COUNT;
     private static final VarHandle PERMIT;
     static {
diff --git a/src/java.base/share/classes/jdk/internal/misc/VM.java b/src/java.base/share/classes/jdk/internal/misc/VM.java
index db57b1f9da5..b01ec2710ba 100644
--- a/src/java.base/share/classes/jdk/internal/misc/VM.java
+++ b/src/java.base/share/classes/jdk/internal/misc/VM.java
@@ -34,6 +34,7 @@
 import java.util.List;
 import java.util.Map;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.vm.annotation.Stable;
 import sun.nio.ch.FileChannelImpl;
@@ -484,6 +485,6 @@ public static List<BufferPool> getBufferPools() {
      * Return the initial value of System.err that was set during VM initialization.
      */
     public static PrintStream initialErr() {
-        return SharedSecrets.getJavaLangAccess().initialSystemErr();
+        return SharedSecrets.get(JavaLangAccess.class).initialSystemErr();
     }
 }
diff --git a/src/java.base/share/classes/jdk/internal/module/Builder.java b/src/java.base/share/classes/jdk/internal/module/Builder.java
index f12e2297b03..860dddf36bd 100644
--- a/src/java.base/share/classes/jdk/internal/module/Builder.java
+++ b/src/java.base/share/classes/jdk/internal/module/Builder.java
@@ -49,7 +49,7 @@
  */
 final class Builder {
     private static final JavaLangModuleAccess JLMA =
-        SharedSecrets.getJavaLangModuleAccess();
+        SharedSecrets.get(JavaLangModuleAccess.class);
 
     // Static cache of the most recently seen Version to cheaply deduplicate
     // most Version objects.  JDK modules have the same version.
diff --git a/src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java b/src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java
index 4dfc740024e..03affb28a60 100644
--- a/src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java
+++ b/src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java
@@ -87,8 +87,8 @@ private ModuleBootstrap() { }
     private static final String ALL_MODULE_PATH = "ALL-MODULE-PATH";
 
     // access to java.lang/module
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
-    private static final JavaLangModuleAccess JLMA = SharedSecrets.getJavaLangModuleAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
+    private static final JavaLangModuleAccess JLMA = SharedSecrets.get(JavaLangModuleAccess.class);
 
     // The ModulePatcher for the initial configuration
     private static final ModulePatcher patcher = initModulePatcher();
diff --git a/src/java.base/share/classes/jdk/internal/module/ModuleInfo.java b/src/java.base/share/classes/jdk/internal/module/ModuleInfo.java
index ed97937e39a..782ece115b6 100644
--- a/src/java.base/share/classes/jdk/internal/module/ModuleInfo.java
+++ b/src/java.base/share/classes/jdk/internal/module/ModuleInfo.java
@@ -65,7 +65,7 @@
 public final class ModuleInfo {
 
     private static final JavaLangModuleAccess JLMA
-        = SharedSecrets.getJavaLangModuleAccess();
+        = SharedSecrets.get(JavaLangModuleAccess.class);
 
     // supplies the set of packages when ModulePackages attribute not present
     private final Supplier<Set<String>> packageFinder;
diff --git a/src/java.base/share/classes/jdk/internal/module/ModulePatcher.java b/src/java.base/share/classes/jdk/internal/module/ModulePatcher.java
index eb3f25ceca7..5298bfa05bc 100644
--- a/src/java.base/share/classes/jdk/internal/module/ModulePatcher.java
+++ b/src/java.base/share/classes/jdk/internal/module/ModulePatcher.java
@@ -65,7 +65,7 @@
 public final class ModulePatcher {
 
     private static final JavaLangModuleAccess JLMA
-        = SharedSecrets.getJavaLangModuleAccess();
+        = SharedSecrets.get(JavaLangModuleAccess.class);
 
     // module name -> sequence of patches (directories or JAR files)
     private final Map<String, List<Path>> map;
diff --git a/src/java.base/share/classes/jdk/internal/module/Modules.java b/src/java.base/share/classes/jdk/internal/module/Modules.java
index 760b3ba9a08..e5c99062718 100644
--- a/src/java.base/share/classes/jdk/internal/module/Modules.java
+++ b/src/java.base/share/classes/jdk/internal/module/Modules.java
@@ -61,8 +61,8 @@
 public class Modules {
     private Modules() { }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
-    private static final JavaLangModuleAccess JLMA = SharedSecrets.getJavaLangModuleAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
+    private static final JavaLangModuleAccess JLMA = SharedSecrets.get(JavaLangModuleAccess.class);
 
     /**
      * Creates a new Module. The module has the given ModuleDescriptor and
diff --git a/src/java.base/share/classes/jdk/internal/module/SystemModuleFinders.java b/src/java.base/share/classes/jdk/internal/module/SystemModuleFinders.java
index 370c151af84..9f0a11a8c6c 100644
--- a/src/java.base/share/classes/jdk/internal/module/SystemModuleFinders.java
+++ b/src/java.base/share/classes/jdk/internal/module/SystemModuleFinders.java
@@ -71,7 +71,7 @@
  */
 
 public final class SystemModuleFinders {
-    private static final JavaNetUriAccess JNUA = SharedSecrets.getJavaNetUriAccess();
+    private static final JavaNetUriAccess JNUA = SharedSecrets.get(JavaNetUriAccess.class);
 
     private static final boolean USE_FAST_PATH;
     static {
diff --git a/src/java.base/share/classes/jdk/internal/reflect/DirectMethodHandleAccessor.java b/src/java.base/share/classes/jdk/internal/reflect/DirectMethodHandleAccessor.java
index e6c5aa5db2e..ab9989b3412 100644
--- a/src/java.base/share/classes/jdk/internal/reflect/DirectMethodHandleAccessor.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/DirectMethodHandleAccessor.java
@@ -311,7 +311,7 @@ static Object invoke(MethodHandle target, Class<?> caller, Object obj, Object[]
                 }
             }
 
-            static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
+            static final JavaLangInvokeAccess JLIA = SharedSecrets.get(JavaLangInvokeAccess.class);
             static final MethodHandle NATIVE_ACCESSOR_INVOKE = MhUtil.findVirtual(
                     MethodHandles.lookup(), NativeAccessor.class, "invoke",
                     genericMethodType(1, true));
diff --git a/src/java.base/share/classes/jdk/internal/reflect/MethodHandleAccessorFactory.java b/src/java.base/share/classes/jdk/internal/reflect/MethodHandleAccessorFactory.java
index 93a208662d5..27f47cdac9a 100644
--- a/src/java.base/share/classes/jdk/internal/reflect/MethodHandleAccessorFactory.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/MethodHandleAccessorFactory.java
@@ -439,7 +439,7 @@ public static boolean isSignaturePolymorphicMethod(Method method) {
      * Delay initializing these static fields until java.lang.invoke is fully initialized.
      */
     static class LazyStaticHolder {
-        static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
+        static final JavaLangInvokeAccess JLIA = SharedSecrets.get(JavaLangInvokeAccess.class);
     }
 
     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
diff --git a/src/java.base/share/classes/jdk/internal/reflect/Reflection.java b/src/java.base/share/classes/jdk/internal/reflect/Reflection.java
index d39fd9231da..4aab6618325 100644
--- a/src/java.base/share/classes/jdk/internal/reflect/Reflection.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/Reflection.java
@@ -32,6 +32,7 @@
 import java.util.Set;
 
 import jdk.internal.access.JavaLangAccess;
+import jdk.internal.access.JavaLangReflectAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.module.ModuleBootstrap;
@@ -82,7 +83,7 @@ public class Reflection {
         low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
         valid. */
     public static int getClassAccessFlags(Class<?> c) {
-        return SharedSecrets.getJavaLangAccess().getClassFileAccessFlags(c);
+        return SharedSecrets.get(JavaLangAccess.class).getClassFileAccessFlags(c);
     }
 
 
@@ -117,7 +118,7 @@ public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, Str
                 currentClass.getModule() :
                 ClassLoader.getSystemClassLoader().getUnnamedModule();
         class Holder {
-            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+            static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
         }
         if (module != null) {
             // not in init phase
@@ -361,7 +362,7 @@ public static boolean isCallerSensitive(Method m) {
      * modified reflectively regardless of the value of its accessible flag.
      */
     public static boolean isTrustedFinalField(Field field) {
-        return SharedSecrets.getJavaLangReflectAccess().isTrustedFinalField(field);
+        return SharedSecrets.get(JavaLangReflectAccess.class).isTrustedFinalField(field);
     }
 
     /**
diff --git a/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java b/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
index 19be5e53798..bf4dc1785f0 100644
--- a/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
@@ -38,7 +38,9 @@
 import java.lang.reflect.*;
 import java.util.Set;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.JavaLangReflectAccess;
+import jdk.internal.access.JavaObjectStreamReflectionAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.vm.annotation.Stable;
@@ -66,7 +68,7 @@ public class ReflectionFactory {
     private final JavaLangReflectAccess langReflectAccess;
 
     private ReflectionFactory() {
-        this.langReflectAccess = SharedSecrets.getJavaLangReflectAccess();
+        this.langReflectAccess = SharedSecrets.get(JavaLangReflectAccess.class);
     }
 
     /**
@@ -351,7 +353,7 @@ public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {
             return null;
         }
 
-        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultReadObject(cl);
+        return SharedSecrets.get(JavaObjectStreamReflectionAccess.class).defaultReadObject(cl);
     }
 
     public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {
@@ -359,7 +361,7 @@ public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {
             return null;
         }
 
-        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultWriteObject(cl);
+        return SharedSecrets.get(JavaObjectStreamReflectionAccess.class).defaultWriteObject(cl);
     }
 
     /**
@@ -521,7 +523,7 @@ public final Set<AccessFlag> parseAccessFlags(int mask, AccessFlag.Location loca
     }
 
     private final ClassFileFormatVersion classFileFormatVersion(Class<?> cl) {
-        int raw = SharedSecrets.getJavaLangAccess().classFileVersion(cl);
+        int raw = SharedSecrets.get(JavaLangAccess.class).classFileVersion(cl);
 
         int major = raw & 0xFFFF;
         int minor = raw >>> Character.SIZE;
diff --git a/src/java.base/share/classes/jdk/internal/util/ArraysSupport.java b/src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
index de7a5e44b91..db51e380a6f 100644
--- a/src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
+++ b/src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
@@ -413,7 +413,7 @@ private static int hashCode(int result, int[] a, int fromIndex, int length) {
         return result;
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     /*
      * fromIndex and length must be scaled to char indexes.
      */
diff --git a/src/java.base/share/classes/jdk/internal/util/DecimalDigits.java b/src/java.base/share/classes/jdk/internal/util/DecimalDigits.java
index b55b6ce63b0..f2406878a8e 100644
--- a/src/java.base/share/classes/jdk/internal/util/DecimalDigits.java
+++ b/src/java.base/share/classes/jdk/internal/util/DecimalDigits.java
@@ -38,7 +38,7 @@
  * @since 21
  */
 public final class DecimalDigits {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 
     /**
diff --git a/src/java.base/share/classes/jdk/internal/vm/Continuation.java b/src/java.base/share/classes/jdk/internal/vm/Continuation.java
index a7eb3ea6a9f..23603085de2 100644
--- a/src/java.base/share/classes/jdk/internal/vm/Continuation.java
+++ b/src/java.base/share/classes/jdk/internal/vm/Continuation.java
@@ -44,7 +44,7 @@ public class Continuation {
     private static final Unsafe U = Unsafe.getUnsafe();
     private static final long MOUNTED_OFFSET = U.objectFieldOffset(Continuation.class, "mounted");
     private static final boolean PRESERVE_SCOPED_VALUE_CACHE;
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     static {
         ContinuationSupport.ensureSupported();
 
diff --git a/src/java.base/share/classes/jdk/internal/vm/JcmdVThreadCommands.java b/src/java.base/share/classes/jdk/internal/vm/JcmdVThreadCommands.java
index b97deb942bc..a7b49f5448f 100644
--- a/src/java.base/share/classes/jdk/internal/vm/JcmdVThreadCommands.java
+++ b/src/java.base/share/classes/jdk/internal/vm/JcmdVThreadCommands.java
@@ -36,7 +36,7 @@
  * called from the "Attach Listener" thread.
  */
 public class JcmdVThreadCommands {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private JcmdVThreadCommands() { }
 
diff --git a/src/java.base/share/classes/jdk/internal/vm/ScopedValueContainer.java b/src/java.base/share/classes/jdk/internal/vm/ScopedValueContainer.java
index 1f15cfb05c9..e3b50726317 100644
--- a/src/java.base/share/classes/jdk/internal/vm/ScopedValueContainer.java
+++ b/src/java.base/share/classes/jdk/internal/vm/ScopedValueContainer.java
@@ -38,7 +38,7 @@
  * and a method to return a snapshot of the scoped value bindings.
  */
 public class ScopedValueContainer extends StackableScope {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     static {
         Unsafe.getUnsafe().ensureClassInitialized(StructureViolationException.class);
     }
diff --git a/src/java.base/share/classes/jdk/internal/vm/SharedThreadContainer.java b/src/java.base/share/classes/jdk/internal/vm/SharedThreadContainer.java
index ef9796b0c7d..449f1fc1143 100644
--- a/src/java.base/share/classes/jdk/internal/vm/SharedThreadContainer.java
+++ b/src/java.base/share/classes/jdk/internal/vm/SharedThreadContainer.java
@@ -38,7 +38,7 @@
  * and is intended for unstructured uses, e.g. thread pools.
  */
 public class SharedThreadContainer extends ThreadContainer implements AutoCloseable {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
     private static final VarHandle CLOSED;
     private static final VarHandle VIRTUAL_THREADS;
     static {
diff --git a/src/java.base/share/classes/jdk/internal/vm/StackableScope.java b/src/java.base/share/classes/jdk/internal/vm/StackableScope.java
index 85a5646db25..6d66ff10e17 100644
--- a/src/java.base/share/classes/jdk/internal/vm/StackableScope.java
+++ b/src/java.base/share/classes/jdk/internal/vm/StackableScope.java
@@ -36,7 +36,7 @@
  * scope stack.
  */
 public class StackableScope {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private final Thread owner;
     private volatile StackableScope previous;
diff --git a/src/java.base/share/classes/jdk/internal/vm/ThreadContainers.java b/src/java.base/share/classes/jdk/internal/vm/ThreadContainers.java
index aeae6b36520..3869c746aec 100644
--- a/src/java.base/share/classes/jdk/internal/vm/ThreadContainers.java
+++ b/src/java.base/share/classes/jdk/internal/vm/ThreadContainers.java
@@ -38,7 +38,7 @@
  * This class consists exclusively of static methods to support groupings of threads.
  */
 public class ThreadContainers {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     // true if all threads are tracked
     private static final boolean TRACK_ALL_THREADS;
diff --git a/src/java.base/share/classes/jdk/internal/vm/VMSupport.java b/src/java.base/share/classes/jdk/internal/vm/VMSupport.java
index 197da0d456c..ad363871dfa 100644
--- a/src/java.base/share/classes/jdk/internal/vm/VMSupport.java
+++ b/src/java.base/share/classes/jdk/internal/vm/VMSupport.java
@@ -205,7 +205,7 @@ public static byte[] encodeAnnotations(byte[] rawAnnotations,
             Class<?> superClass = declaringClass.getSuperclass();
             nextSuperClass:
             while (superClass != null) {
-                JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+                JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
                 Map<Class<? extends Annotation>, Annotation> superAnnotations =
                     AnnotationParser.parseSelectAnnotations(
                             jla.getRawClassAnnotations(superClass),
diff --git a/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java b/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
index 89ad0cc48ed..8948d7c3b82 100644
--- a/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
+++ b/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
@@ -2847,7 +2847,7 @@ private String filterHeaderField(String name, String value) {
                 return value;
 
             JavaNetHttpCookieAccess access =
-                    SharedSecrets.getJavaNetHttpCookieAccess();
+                    SharedSecrets.get(JavaNetHttpCookieAccess.class);
             StringJoiner retValue = new StringJoiner(",");  // RFC 2965, comma separated
             List<HttpCookie> cookies = access.parse(value);
             for (HttpCookie cookie : cookies) {
diff --git a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
index a1ddcad94f5..c51f071f549 100644
--- a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
+++ b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
@@ -69,7 +69,7 @@ public class FileChannelImpl
 {
     // Access to FileDescriptor internals
     private static final JavaIOFileDescriptorAccess fdAccess =
-        SharedSecrets.getJavaIOFileDescriptorAccess();
+        SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     // Used to make native read and write calls
     private static final FileDispatcher nd = new FileDispatcherImpl();
diff --git a/src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java b/src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java
index 9b65310784a..46174e078e0 100644
--- a/src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java
+++ b/src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java
@@ -36,7 +36,7 @@
  */
 
 abstract class NativeDispatcher {
-    private static final JavaIOFileDescriptorAccess JIOFDA = SharedSecrets.getJavaIOFileDescriptorAccess();
+    private static final JavaIOFileDescriptorAccess JIOFDA = SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     abstract int read(FileDescriptor fd, long address, int len)
         throws IOException;
diff --git a/src/java.base/share/classes/sun/nio/ch/NativeSocketAddress.java b/src/java.base/share/classes/sun/nio/ch/NativeSocketAddress.java
index c1f813ec524..e0e4b9524ca 100644
--- a/src/java.base/share/classes/sun/nio/ch/NativeSocketAddress.java
+++ b/src/java.base/share/classes/sun/nio/ch/NativeSocketAddress.java
@@ -47,7 +47,7 @@
  * This class is not thread safe.
  */
 class NativeSocketAddress {
-    private static final JavaNetInetAddressAccess JNINA = SharedSecrets.getJavaNetInetAddressAccess();
+    private static final JavaNetInetAddressAccess JNINA = SharedSecrets.get(JavaNetInetAddressAccess.class);
     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);
 
diff --git a/src/java.base/share/classes/sun/nio/ch/NioSocketImpl.java b/src/java.base/share/classes/sun/nio/ch/NioSocketImpl.java
index 01f894be227..49321b1ad03 100644
--- a/src/java.base/share/classes/sun/nio/ch/NioSocketImpl.java
+++ b/src/java.base/share/classes/sun/nio/ch/NioSocketImpl.java
@@ -1263,5 +1263,5 @@ private static int fdVal(FileDescriptor fd) {
         return JIOFDA.get(fd);
     }
 
-    private static final JavaIOFileDescriptorAccess JIOFDA = SharedSecrets.getJavaIOFileDescriptorAccess();
+    private static final JavaIOFileDescriptorAccess JIOFDA = SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 }
diff --git a/src/java.base/share/classes/sun/nio/cs/CESU_8.java b/src/java.base/share/classes/sun/nio/cs/CESU_8.java
index 409b375ec88..ffdc167f445 100644
--- a/src/java.base/share/classes/sun/nio/cs/CESU_8.java
+++ b/src/java.base/share/classes/sun/nio/cs/CESU_8.java
@@ -76,7 +76,7 @@ private static final void updatePositions(Buffer src, int sp,
         dst.position(dp - dst.arrayOffset());
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private static class Decoder extends CharsetDecoder
                                  implements ArrayDecoder {
diff --git a/src/java.base/share/classes/sun/nio/cs/DoubleByte.java b/src/java.base/share/classes/sun/nio/cs/DoubleByte.java
index 0969669a35b..d78fbbf9c2f 100644
--- a/src/java.base/share/classes/sun/nio/cs/DoubleByte.java
+++ b/src/java.base/share/classes/sun/nio/cs/DoubleByte.java
@@ -109,7 +109,7 @@ public class DoubleByte {
         Arrays.fill(B2C_UNMAPPABLE, UNMAPPABLE_DECODING);
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     public static class Decoder extends CharsetDecoder
                                 implements DelegatableDecoder, ArrayDecoder
diff --git a/src/java.base/share/classes/sun/nio/cs/ISO_8859_1.java b/src/java.base/share/classes/sun/nio/cs/ISO_8859_1.java
index ff5970e92a8..fa7a447d9bf 100644
--- a/src/java.base/share/classes/sun/nio/cs/ISO_8859_1.java
+++ b/src/java.base/share/classes/sun/nio/cs/ISO_8859_1.java
@@ -66,7 +66,7 @@ public CharsetEncoder newEncoder() {
 
     private static class Decoder extends CharsetDecoder {
 
-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+        private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
         private Decoder(Charset cs) {
             super(cs, 1.0f, 1.0f);
diff --git a/src/java.base/share/classes/sun/nio/cs/SingleByte.java b/src/java.base/share/classes/sun/nio/cs/SingleByte.java
index a5bf06cb251..f01d5b143dc 100644
--- a/src/java.base/share/classes/sun/nio/cs/SingleByte.java
+++ b/src/java.base/share/classes/sun/nio/cs/SingleByte.java
@@ -49,7 +49,7 @@ private static final CoderResult withResult(CoderResult cr,
         return cr;
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     public static final class Decoder extends CharsetDecoder
                                       implements ArrayDecoder {
diff --git a/src/java.base/share/classes/sun/nio/cs/US_ASCII.java b/src/java.base/share/classes/sun/nio/cs/US_ASCII.java
index 3886978d209..b8dc0f20ebb 100644
--- a/src/java.base/share/classes/sun/nio/cs/US_ASCII.java
+++ b/src/java.base/share/classes/sun/nio/cs/US_ASCII.java
@@ -61,7 +61,7 @@ public CharsetEncoder newEncoder() {
         return new Encoder(this);
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private static class Decoder extends CharsetDecoder {
 
diff --git a/src/java.base/share/classes/sun/nio/cs/UTF_8.java b/src/java.base/share/classes/sun/nio/cs/UTF_8.java
index d2d6d7e485d..6448718c9a8 100644
--- a/src/java.base/share/classes/sun/nio/cs/UTF_8.java
+++ b/src/java.base/share/classes/sun/nio/cs/UTF_8.java
@@ -82,7 +82,7 @@ static final void updatePositions(Buffer src, int sp,
         dst.position(dp - dst.arrayOffset());
     }
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private static class Decoder extends CharsetDecoder {
 
diff --git a/src/java.base/share/classes/sun/reflect/annotation/AnnotationSupport.java b/src/java.base/share/classes/sun/reflect/annotation/AnnotationSupport.java
index fd76eedfbcd..6814664935e 100644
--- a/src/java.base/share/classes/sun/reflect/annotation/AnnotationSupport.java
+++ b/src/java.base/share/classes/sun/reflect/annotation/AnnotationSupport.java
@@ -38,7 +38,7 @@
 import jdk.internal.reflect.ReflectionFactory;
 
 public final class AnnotationSupport {
-    private static final JavaLangAccess LANG_ACCESS = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess LANG_ACCESS = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * Finds and returns all annotations in {@code annotations} matching
diff --git a/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java b/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java
index 3a4bd80b014..e9ec75cc4a8 100644
--- a/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java
+++ b/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java
@@ -78,7 +78,7 @@ public class AnnotationType {
     public static AnnotationType getInstance(
         Class<? extends Annotation> annotationClass)
     {
-        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+        JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
         AnnotationType result = jla.getAnnotationType(annotationClass); // volatile read
         if (result == null) {
             result = new AnnotationType(annotationClass);
@@ -134,7 +134,7 @@ private AnnotationType(final Class<? extends Annotation> annotationClass) {
         // of the corresponding annotation types breaks infinite recursion.
         if (annotationClass != Retention.class &&
             annotationClass != Inherited.class) {
-            JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+            JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
             Map<Class<? extends Annotation>, Annotation> metaAnnotations =
                 AnnotationParser.parseSelectAnnotations(
                     jla.getRawClassAnnotations(annotationClass),
diff --git a/src/java.base/share/classes/sun/reflect/annotation/TypeAnnotationParser.java b/src/java.base/share/classes/sun/reflect/annotation/TypeAnnotationParser.java
index 30f9434d6b7..5ec56e95ecb 100644
--- a/src/java.base/share/classes/sun/reflect/annotation/TypeAnnotationParser.java
+++ b/src/java.base/share/classes/sun/reflect/annotation/TypeAnnotationParser.java
@@ -330,7 +330,7 @@ private static <D extends GenericDeclaration> List<TypeAnnotation> fetchBounds(D
     static TypeAnnotation[] parseAllTypeAnnotations(AnnotatedElement decl) {
         Class<?> container;
         byte[] rawBytes;
-        JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();
+        JavaLangAccess javaLangAccess = SharedSecrets.get(JavaLangAccess.class);
         if (decl instanceof Class<?> classDecl) {
             container = classDecl;
             rawBytes = javaLangAccess.getRawClassTypeAnnotations(container);
diff --git a/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java b/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
index ab01a9d85be..6eb3b40adcd 100644
--- a/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
+++ b/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
@@ -1618,7 +1618,7 @@ private void useImplicitHost(boolean useNameService) {
         }
 
         JavaNetInetAddressAccess jna =
-                SharedSecrets.getJavaNetInetAddressAccess();
+                SharedSecrets.get(JavaNetInetAddressAccess.class);
         String originalHostname = jna.getOriginalHostName(inetAddress);
         if (originalHostname != null && !originalHostname.isEmpty()) {
 
diff --git a/src/java.base/share/classes/sun/security/util/Password.java b/src/java.base/share/classes/sun/security/util/Password.java
index e358bcd95de..a03cc24c64d 100644
--- a/src/java.base/share/classes/sun/security/util/Password.java
+++ b/src/java.base/share/classes/sun/security/util/Password.java
@@ -30,6 +30,7 @@
 import java.nio.charset.*;
 import java.util.Arrays;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.io.JdkConsoleImpl;
 
@@ -56,7 +57,7 @@ public static char[] readPassword(InputStream in, boolean isEchoOn)
         try {
             // Only use Console if `in` is the initial System.in
             if (!isEchoOn) {
-                if (in == SharedSecrets.getJavaLangAccess().initialSystemIn()
+                if (in == SharedSecrets.get(JavaLangAccess.class).initialSystemIn()
                         && ConsoleHolder.consoleIsAvailable()) {
                     consoleEntered = ConsoleHolder.readPassword();
                     // readPassword might return null. Stop now.
diff --git a/src/java.base/unix/classes/java/lang/ProcessImpl.java b/src/java.base/unix/classes/java/lang/ProcessImpl.java
index 390a4f28477..ad8e2a3af83 100644
--- a/src/java.base/unix/classes/java/lang/ProcessImpl.java
+++ b/src/java.base/unix/classes/java/lang/ProcessImpl.java
@@ -58,7 +58,7 @@
  */
 final class ProcessImpl extends Process {
     private static final JavaIOFileDescriptorAccess fdAccess
-        = SharedSecrets.getJavaIOFileDescriptorAccess();
+        = SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     // Linux platforms support a normal (non-forcible) kill signal.
     static final boolean SUPPORTS_NORMAL_TERMINATION = true;
diff --git a/src/java.base/unix/classes/sun/nio/ch/UnixFileDispatcherImpl.java b/src/java.base/unix/classes/sun/nio/ch/UnixFileDispatcherImpl.java
index e9f8cb637fb..85612516a28 100644
--- a/src/java.base/unix/classes/sun/nio/ch/UnixFileDispatcherImpl.java
+++ b/src/java.base/unix/classes/sun/nio/ch/UnixFileDispatcherImpl.java
@@ -42,7 +42,7 @@ class UnixFileDispatcherImpl extends FileDispatcher {
     }
 
     private static final JavaIOFileDescriptorAccess fdAccess =
-            SharedSecrets.getJavaIOFileDescriptorAccess();
+            SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     UnixFileDispatcherImpl() {
     }
diff --git a/src/java.base/unix/classes/sun/nio/fs/UnixChannelFactory.java b/src/java.base/unix/classes/sun/nio/fs/UnixChannelFactory.java
index 1e04291d458..40e264b96a3 100644
--- a/src/java.base/unix/classes/sun/nio/fs/UnixChannelFactory.java
+++ b/src/java.base/unix/classes/sun/nio/fs/UnixChannelFactory.java
@@ -45,7 +45,7 @@
 
 class UnixChannelFactory {
     private static final JavaIOFileDescriptorAccess fdAccess =
-        SharedSecrets.getJavaIOFileDescriptorAccess();
+        SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     protected UnixChannelFactory() {
     }
diff --git a/src/java.base/unix/classes/sun/nio/fs/UnixPath.java b/src/java.base/unix/classes/sun/nio/fs/UnixPath.java
index b722c30db42..0416f9f9b29 100644
--- a/src/java.base/unix/classes/sun/nio/fs/UnixPath.java
+++ b/src/java.base/unix/classes/sun/nio/fs/UnixPath.java
@@ -52,7 +52,7 @@
  */
 class UnixPath implements Path {
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     private final UnixFileSystem fs;
 
diff --git a/src/java.desktop/share/classes/java/beans/Introspector.java b/src/java.desktop/share/classes/java/beans/Introspector.java
index 564021104a7..04d5ddfd5c9 100644
--- a/src/java.desktop/share/classes/java/beans/Introspector.java
+++ b/src/java.desktop/share/classes/java/beans/Introspector.java
@@ -142,7 +142,7 @@ public class Introspector {
 
     // register with SharedSecrets for JMX usage
     static {
-        SharedSecrets.setJavaBeansAccess(new JavaBeansAccess() {
+        SharedSecrets.set(JavaBeansAccess.class, new JavaBeansAccess() {
             @Override
             public Method getReadMethod(Class<?> clazz, String property) throws Exception {
                 BeanInfo bi = Introspector.getBeanInfo(clazz);
diff --git a/src/java.management/share/classes/com/sun/jmx/mbeanserver/JavaBeansAccessor.java b/src/java.management/share/classes/com/sun/jmx/mbeanserver/JavaBeansAccessor.java
index d8692d32e31..664c15d93d8 100644
--- a/src/java.management/share/classes/com/sun/jmx/mbeanserver/JavaBeansAccessor.java
+++ b/src/java.management/share/classes/com/sun/jmx/mbeanserver/JavaBeansAccessor.java
@@ -44,7 +44,7 @@ class JavaBeansAccessor {
     }
 
     private static JavaBeansAccess getJavaBeansAccess() {
-        return SharedSecrets.getJavaBeansAccess();
+        return SharedSecrets.get(JavaBeansAccess.class);
     }
 
     static boolean isAvailable() {
diff --git a/src/java.management/share/classes/javax/management/openmbean/TabularDataSupport.java b/src/java.management/share/classes/javax/management/openmbean/TabularDataSupport.java
index d670d2da782..79b429fcb54 100644
--- a/src/java.management/share/classes/javax/management/openmbean/TabularDataSupport.java
+++ b/src/java.management/share/classes/javax/management/openmbean/TabularDataSupport.java
@@ -40,6 +40,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
+import jdk.internal.access.JavaObjectInputStreamAccess;
 import jdk.internal.access.SharedSecrets;
 
 
@@ -906,7 +908,7 @@ private void readObject(ObjectInputStream in)
       in.defaultReadObject();
       List<String> tmpNames = tabularType.getIndexNames();
       int size = tmpNames.size();
-      SharedSecrets.getJavaObjectInputStreamAccess().checkArray(in, String[].class, size);
+      SharedSecrets.get(JavaObjectInputStreamAccess.class).checkArray(in, String[].class, size);
       indexNamesArray = tmpNames.toArray(new String[size]);
     }
 }
diff --git a/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl.java b/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl.java
index 406e16b6376..16fe8f75ad4 100644
--- a/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl.java
+++ b/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl.java
@@ -46,6 +46,7 @@
 import java.rmi.server.RMIServerSocketFactory;
 import java.text.MessageFormat;
 
+import jdk.internal.access.JavaObjectInputFilterAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.rmi.runtime.Log;
 import sun.rmi.server.UnicastRef;
@@ -117,7 +118,7 @@ private static ObjectInputFilter initRegistryFilter() {
             props = Security.getProperty(REGISTRY_FILTER_PROPNAME);
         }
         if (props != null) {
-            filter = SharedSecrets.getJavaObjectInputFilterAccess().createFilter2(props);
+            filter = SharedSecrets.get(JavaObjectInputFilterAccess.class).createFilter2(props);
             Log regLog = Log.getLog("sun.rmi.registry", "registry", -1);
             if (regLog.isLoggable(Log.BRIEF)) {
                 regLog.log(Log.BRIEF, "registryFilter = " + filter);
diff --git a/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java b/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java
index 95b94c57e1c..f5e7f6e2246 100644
--- a/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java
+++ b/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
+import jdk.internal.access.JavaObjectInputStreamReadString;
 import jdk.internal.access.SharedSecrets;
 import sun.rmi.transport.StreamRemoteCall;
 
@@ -87,7 +88,7 @@ public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall,
                 try {
                     ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                     $param_String_1 =
-                            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
+                            SharedSecrets.get(JavaObjectInputStreamReadString.class).readString(in);
                     $param_Remote_2 = (java.rmi.Remote) in.readObject();
                 } catch (ClassCastException | IOException | ClassNotFoundException e) {
                     call.discardPendingRefs();
@@ -123,7 +124,7 @@ public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall,
                 try {
                     ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                     $param_String_1 =
-                            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
+                            SharedSecrets.get(JavaObjectInputStreamReadString.class).readString(in);
                 } catch (ClassCastException | IOException e) {
                     call.discardPendingRefs();
                     throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
@@ -150,7 +151,7 @@ public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall,
                 try {
                     ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                     $param_String_1 =
-                            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
+                            SharedSecrets.get(JavaObjectInputStreamReadString.class).readString(in);
                     $param_Remote_2 = (java.rmi.Remote) in.readObject();
                 } catch (ClassCastException | IOException | java.lang.ClassNotFoundException e) {
                     call.discardPendingRefs();
@@ -176,7 +177,7 @@ public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall,
                 try {
                     ObjectInputStream in = (ObjectInputStream)call.getInputStream();
                     $param_String_1 =
-                            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);
+                            SharedSecrets.get(JavaObjectInputStreamReadString.class).readString(in);
                 } catch (ClassCastException | IOException e) {
                     call.discardPendingRefs();
                     throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
diff --git a/src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java b/src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java
index 39ff8ce8f20..d645c00ce93 100644
--- a/src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java
+++ b/src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java
@@ -39,6 +39,7 @@
 import java.rmi.server.RemoteObject;
 import java.rmi.server.RemoteRef;
 
+import jdk.internal.access.JavaObjectInputStreamReadString;
 import jdk.internal.access.SharedSecrets;
 import sun.rmi.runtime.Log;
 import sun.rmi.transport.Connection;
@@ -320,7 +321,7 @@ protected static Object unmarshalValue(Class<?> type, ObjectInput in)
                 throw new Error("Unrecognized primitive type: " + type);
             }
         } else if (type == String.class && in instanceof ObjectInputStream) {
-            return SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream)in);
+            return SharedSecrets.get(JavaObjectInputStreamReadString.class).readString((ObjectInputStream)in);
         } else {
             return in.readObject();
         }
diff --git a/src/jdk.charsets/share/classes/sun/nio/cs/ext/EUC_JP.java.template b/src/jdk.charsets/share/classes/sun/nio/cs/ext/EUC_JP.java.template
index f3d03a9e9c7..f962aeeaac8 100644
--- a/src/jdk.charsets/share/classes/sun/nio/cs/ext/EUC_JP.java.template
+++ b/src/jdk.charsets/share/classes/sun/nio/cs/ext/EUC_JP.java.template
@@ -34,6 +34,7 @@ import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
+import jdk.internal.access.JavaLangAccess;
 import sun.nio.cs.HistoricallyNamedCharset;
 import sun.nio.cs.DelegatableDecoder;
 import sun.nio.cs.DoubleByte;
@@ -46,7 +47,7 @@ public class EUC_JP
     extends Charset
     implements HistoricallyNamedCharset
 {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     public EUC_JP() {
         super("EUC-JP",  $ALIASES$);
diff --git a/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java b/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
index dcc9c3acdea..ad5a3b9a7bd 100644
--- a/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
+++ b/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
@@ -66,7 +66,7 @@ public final class GenerateJLIClassesPlugin extends AbstractPlugin {
     private static final String DEFAULT_TRACE_FILE = "default_jli_trace.txt";
 
     private static final JavaLangInvokeAccess JLIA
-            = SharedSecrets.getJavaLangInvokeAccess();
+            = SharedSecrets.get(JavaLangInvokeAccess.class);
 
     private String mainArgument;
     private Stream<String> traceFileStream;
diff --git a/src/jdk.management/share/classes/com/sun/management/internal/VirtualThreadSchedulerImpls.java b/src/jdk.management/share/classes/com/sun/management/internal/VirtualThreadSchedulerImpls.java
index 97c03cb79e4..8465ecff491 100644
--- a/src/jdk.management/share/classes/com/sun/management/internal/VirtualThreadSchedulerImpls.java
+++ b/src/jdk.management/share/classes/com/sun/management/internal/VirtualThreadSchedulerImpls.java
@@ -91,7 +91,7 @@ private static final class VirtualThreadSchedulerImpl extends BaseVirtualThreadS
          */
         private static class Scheduler {
             private static final Executor scheduler =
-                SharedSecrets.getJavaLangAccess().virtualThreadDefaultScheduler();
+                SharedSecrets.get(JavaLangAccess.class).virtualThreadDefaultScheduler();
             static Executor instance() {
                 return scheduler;
             }
diff --git a/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java b/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
index 51221df64ea..d23bad1d25a 100644
--- a/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
+++ b/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
@@ -328,7 +328,7 @@ public Object getOption(FileDescriptor fd,
     }
 
     private static final JavaIOFileDescriptorAccess fdAccess =
-            SharedSecrets.getJavaIOFileDescriptorAccess();
+            SharedSecrets.get(JavaIOFileDescriptorAccess.class);
 
     private static void setQuickAckOption(FileDescriptor fd, boolean enable)
             throws SocketException {
diff --git a/test/hotspot/jtreg/compiler/c2/TestDeadDataLoopIGVN.java b/test/hotspot/jtreg/compiler/c2/TestDeadDataLoopIGVN.java
index 26a1c1d8d1f..0d625ead587 100644
--- a/test/hotspot/jtreg/compiler/c2/TestDeadDataLoopIGVN.java
+++ b/test/hotspot/jtreg/compiler/c2/TestDeadDataLoopIGVN.java
@@ -47,6 +47,8 @@
 import java.util.ArrayList;
 import java.util.Vector;
 import java.util.ListIterator;
+
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.reflect.ConstantPool;
@@ -92,7 +94,7 @@ private static void callSomeMethods(List<String> list) {
     // Adaptation from CTW to compile and deoptimize the same methods
     private static void compileClass(Class<?> aClass) throws Exception {
         aClass = Class.forName(aClass.getCanonicalName(), true, aClass.getClassLoader());
-        ConstantPool constantPool = SharedSecrets.getJavaLangAccess().getConstantPool(aClass);
+        ConstantPool constantPool = SharedSecrets.get(JavaLangAccess.class).getConstantPool(aClass);
         preloadClasses(constantPool);
         UNSAFE.ensureClassInitialized(aClass);
         WB.enqueueInitializerForCompilation(aClass, 4); // Level 4 for C2
diff --git a/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ConstantPoolTestsHelper.java b/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ConstantPoolTestsHelper.java
index da6642bdc18..6b4b01f8760 100644
--- a/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ConstantPoolTestsHelper.java
+++ b/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ConstantPoolTestsHelper.java
@@ -28,6 +28,7 @@
 import compiler.jvmci.common.testcases.MultipleImplementersInterface;
 import compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes;
 import compiler.jvmci.compilerToVM.ConstantPoolTestCase.TestedCPEntry;
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import org.objectweb.asm.Opcodes;
 import jdk.internal.reflect.ConstantPool;
@@ -72,7 +73,7 @@ public enum DummyClasses {
 
         DummyClasses(Class<?> klass, Map<ConstantTypes, TestedCPEntry[]> testedCP) {
             this.klass = klass;
-            this.constantPoolSS = SharedSecrets.getJavaLangAccess().getConstantPool(klass);
+            this.constantPoolSS = SharedSecrets.get(JavaLangAccess.class).getConstantPool(klass);
             this.testedCP = testedCP;
         }
 
diff --git a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/EmptyClassHelper.java b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/EmptyClassHelper.java
index afcbadf11bd..ad00f3beed1 100644
--- a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/EmptyClassHelper.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/EmptyClassHelper.java
@@ -29,7 +29,7 @@
 import jdk.internal.access.SharedSecrets;
 
 class EmptyClassHelper {
-    static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
+    static final JavaLangAccess jla = SharedSecrets.get(JavaLangAccess.class);
     static final String USE_APP = "useAppLoader";
     public static void main(String[] args) throws Exception {
         Class cls = null;
diff --git a/test/hotspot/jtreg/testlibrary/ctw/src/sun/hotspot/tools/ctw/Compiler.java b/test/hotspot/jtreg/testlibrary/ctw/src/sun/hotspot/tools/ctw/Compiler.java
index 0ff9cae8169..dfeb3ea6df0 100644
--- a/test/hotspot/jtreg/testlibrary/ctw/src/sun/hotspot/tools/ctw/Compiler.java
+++ b/test/hotspot/jtreg/testlibrary/ctw/src/sun/hotspot/tools/ctw/Compiler.java
@@ -23,6 +23,7 @@
 
 package sun.hotspot.tools.ctw;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.reflect.ConstantPool;
@@ -77,7 +78,7 @@ public static void compileClass(Class<?> aClass, long id, Executor executor) {
 
         // Initialize all constant pool entries, if requested.
         if (Utils.COMPILE_THE_WORLD_PRELOAD_CLASSES) {
-            ConstantPool constantPool = SharedSecrets.getJavaLangAccess().getConstantPool(aClass);
+            ConstantPool constantPool = SharedSecrets.get(JavaLangAccess.class).getConstantPool(aClass);
             preloadClasses(aClass.getName(), id, constantPool);
         }
 
diff --git a/test/jdk/java/lang/LazyConstant/StableComponentContainerTest.java b/test/jdk/java/lang/LazyConstant/StableComponentContainerTest.java
new file mode 100644
index 00000000000..f0b41f27b31
--- /dev/null
+++ b/test/jdk/java/lang/LazyConstant/StableComponentContainerTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @summary Basic tests for the StableComponentContainer implementation
+ * @enablePreview
+ * @modules java.base/jdk.internal.access:+open
+ * @run junit StableComponentContainerTest
+ */
+
+import jdk.internal.access.StableComponentContainer;
+import org.junit.jupiter.api.Test;
+
+import java.math.BigInteger;
+import java.util.HashSet;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+final class StableComponentContainerTest {
+
+    private static final Set<Class<? extends Number>> SET = Set.of(
+            Byte.class,
+            Short.class,
+            Integer.class,
+            Long.class,
+            Float.class,
+            Double.class);
+
+    @Test
+    void factoryInvariants() {
+        assertThrows(NullPointerException.class, () -> StableComponentContainer.of(null));
+        Set<Class<? extends Number>> setWithNull = new HashSet<>();
+        setWithNull.add(Byte.class);
+        setWithNull.add(Short.class);
+        setWithNull.add(null);
+        setWithNull.add(Integer.class);
+        assertThrows(NullPointerException.class, () -> StableComponentContainer.of(setWithNull));
+    }
+
+    @Test
+    void basic() {
+        StableComponentContainer<Number> container = populated();
+        for (Class<? extends Number> type : SET) {
+            Number value = container.get(type);
+            assertEquals(1, value.intValue(), type.toString());
+        }
+        var x0 = assertThrows(IllegalStateException.class, () -> container.set(Byte.class, (byte) 1));
+        assertEquals("The component is already initialized: " + Byte.class.getName(), x0.getMessage());
+        var x1 = assertThrows(IllegalArgumentException.class, () -> container.set(BigInteger.class, BigInteger.ONE));
+        assertTrue(x1.getMessage().startsWith("The type '" + BigInteger.class.getName() + "' is outside the allowed input types:"), x1.getMessage());
+    }
+
+    @Test
+    void testToString() {
+        StableComponentContainer<Number> container = populated();
+        var toString = container.toString();
+        assertTrue(toString.startsWith("StableComponentContainer{"), toString);
+        for (Class<? extends Number> type : SET) {
+            assertTrue(toString.contains(type.getName()+"=1"), toString);
+        }
+        assertTrue(toString.endsWith("}"), toString);
+    }
+
+    @Test
+    void testToStringEmpty() {
+        StableComponentContainer<Number> container = StableComponentContainer.of(Set.of());
+        assertEquals("StableComponentContainer{}", container.toString());
+    }
+
+    @Test
+    void computeIfAbsent() {
+        StableComponentContainer<Number> container = StableComponentContainer.of(SET);
+        Integer value = container.computeIfAbsent(Integer.class, StableComponentContainerTest::mapper);
+        assertEquals(1, value);
+        assertThrows(NullPointerException.class, () -> container.computeIfAbsent(Byte.class, StableComponentContainerTest::mapper));
+    }
+
+    static <C extends Number> C mapper(Class<C> type) {
+        return type.cast(switch (type) {
+            case Class<?> c when c.equals(Byte.class) -> null;
+            case Class<?> c when c.equals(Integer.class) -> 1;
+            default -> throw new NoSuchElementException(type.toString());
+        });
+    }
+
+    private static StableComponentContainer<Number> populated() {
+        StableComponentContainer<Number> container = StableComponentContainer.of(SET);
+        container.set(Byte.class, (byte) 1);
+        container.set(Short.class, (short) 1);
+        container.set(Integer.class, 1);
+        container.set(Long.class, 1L);
+        container.set(Float.class, 1.0f);
+        container.set(Double.class, 1.0d);
+        return container;
+    }
+
+}
diff --git a/test/jdk/java/lang/ModuleLayer/BasicLayerTest.java b/test/jdk/java/lang/ModuleLayer/BasicLayerTest.java
index f2e7027df77..365d9f554a3 100644
--- a/test/jdk/java/lang/ModuleLayer/BasicLayerTest.java
+++ b/test/jdk/java/lang/ModuleLayer/BasicLayerTest.java
@@ -41,6 +41,7 @@
 import java.util.Set;
 import java.util.stream.Collectors;
 
+import jdk.internal.access.JavaLangModuleAccess;
 import jdk.test.lib.util.ModuleUtils;
 
 import jdk.internal.access.SharedSecrets;
@@ -57,7 +58,7 @@ public class BasicLayerTest {
      * test the create ModuleDescriptor objects that do not require java.base.
      */
     private static ModuleDescriptor.Builder newBuilder(String mn) {
-        return SharedSecrets.getJavaLangModuleAccess()
+        return SharedSecrets.get(JavaLangModuleAccess.class)
                 .newModuleBuilder(mn, false, Set.of());
     }
 
diff --git a/test/jdk/java/lang/String/CountNonZeroAscii.java b/test/jdk/java/lang/String/CountNonZeroAscii.java
index d4b8a4fb1eb..565e6b40fd1 100644
--- a/test/jdk/java/lang/String/CountNonZeroAscii.java
+++ b/test/jdk/java/lang/String/CountNonZeroAscii.java
@@ -36,7 +36,7 @@
  * @run main/othervm -XX:-CompactStrings CountNonZeroAscii
  */
 public class CountNonZeroAscii {
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     public static void main(String [] args) {
         byte[] bytes = new byte[1000];
diff --git a/test/jdk/java/lang/System/LoggerFinder/SignedLoggerFinderTest/java.base/share/classes/jdk/internal/event/EventHelper.java b/test/jdk/java/lang/System/LoggerFinder/SignedLoggerFinderTest/java.base/share/classes/jdk/internal/event/EventHelper.java
index 4e9e3f7bff5..079c3bdbb95 100644
--- a/test/jdk/java/lang/System/LoggerFinder/SignedLoggerFinderTest/java.base/share/classes/jdk/internal/event/EventHelper.java
+++ b/test/jdk/java/lang/System/LoggerFinder/SignedLoggerFinderTest/java.base/share/classes/jdk/internal/event/EventHelper.java
@@ -40,7 +40,7 @@
 
 public final class EventHelper {
 
-    private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
+    private static final JavaUtilJarAccess JUJA = SharedSecrets.get(JavaUtilJarAccess.class);
     private static volatile boolean loggingSecurity;
     private static volatile System.Logger securityLogger;
     private static final VarHandle LOGGER_HANDLE;
diff --git a/test/jdk/java/lang/module/ConfigurationTest.java b/test/jdk/java/lang/module/ConfigurationTest.java
index b32d49ffb06..71b3a3a7a17 100644
--- a/test/jdk/java/lang/module/ConfigurationTest.java
+++ b/test/jdk/java/lang/module/ConfigurationTest.java
@@ -49,6 +49,8 @@
 import java.util.List;
 import java.util.Set;
 import java.util.stream.Stream;
+
+import jdk.internal.access.JavaLangModuleAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.module.ModuleTarget;
 
@@ -68,7 +70,7 @@ class ConfigurationTest {
      * test the create ModuleDescriptor objects that do not require java.base.
      */
     private static ModuleDescriptor.Builder newBuilder(String mn) {
-        return SharedSecrets.getJavaLangModuleAccess()
+        return SharedSecrets.get(JavaLangModuleAccess.class)
                 .newModuleBuilder(mn, false, Set.of());
     }
 
diff --git a/test/jdk/java/lang/module/ModuleDescriptorTest.java b/test/jdk/java/lang/module/ModuleDescriptorTest.java
index fd7d32cc978..6c3f3db0627 100644
--- a/test/jdk/java/lang/module/ModuleDescriptorTest.java
+++ b/test/jdk/java/lang/module/ModuleDescriptorTest.java
@@ -72,7 +72,7 @@
 
 @Test
 public class ModuleDescriptorTest {
-    private static final JavaLangModuleAccess JLMA = SharedSecrets.getJavaLangModuleAccess();
+    private static final JavaLangModuleAccess JLMA = SharedSecrets.get(JavaLangModuleAccess.class);
 
     @DataProvider(name = "invalidNames")
     public Object[][] invalidNames() {
diff --git a/test/jdk/java/lang/module/ModuleNamesTest.java b/test/jdk/java/lang/module/ModuleNamesTest.java
index 49e730c06e8..345b6fc15da 100644
--- a/test/jdk/java/lang/module/ModuleNamesTest.java
+++ b/test/jdk/java/lang/module/ModuleNamesTest.java
@@ -43,6 +43,7 @@
 import java.util.Optional;
 import java.util.Set;
 
+import jdk.internal.access.JavaLangModuleAccess;
 import jdk.internal.access.SharedSecrets;
 
 import jdk.test.lib.util.ModuleInfoWriter;
@@ -237,7 +238,7 @@ public void testIllegalOpens(String mn, String ignore) throws Exception {
      * Returns a Builder that does not validate module names.
      */
     private Builder newBuilder(String mn) {
-        return SharedSecrets.getJavaLangModuleAccess()
+        return SharedSecrets.get(JavaLangModuleAccess.class)
                             .newModuleBuilder(mn, false, Set.of());
     }
 
diff --git a/test/jdk/java/net/InetAddress/getOriginalHostName.java b/test/jdk/java/net/InetAddress/getOriginalHostName.java
index 71567a7915d..666b8715532 100644
--- a/test/jdk/java/net/InetAddress/getOriginalHostName.java
+++ b/test/jdk/java/net/InetAddress/getOriginalHostName.java
@@ -36,7 +36,7 @@
 public class getOriginalHostName {
 
     private static final JavaNetInetAddressAccess jna =
-        SharedSecrets.getJavaNetInetAddressAccess();
+        SharedSecrets.get(JavaNetInetAddressAccess.class);
 
     public static void main(String[] args) throws Exception {
         final String HOST = "dummyserver.java.net";
diff --git a/test/jdk/java/util/jar/JarFile/jarVerification/MultiThreadLoad.java b/test/jdk/java/util/jar/JarFile/jarVerification/MultiThreadLoad.java
index c461cfc9b8c..f5e042bdab7 100644
--- a/test/jdk/java/util/jar/JarFile/jarVerification/MultiThreadLoad.java
+++ b/test/jdk/java/util/jar/JarFile/jarVerification/MultiThreadLoad.java
@@ -34,7 +34,7 @@ public class MultiThreadLoad {
 
     private static PrintStream out = System.err;
     static String TEST_CLASS_PATH;
-    private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
+    private static final JavaUtilJarAccess JUJA = SharedSecrets.get(JavaUtilJarAccess.class);
     private static CountDownLatch cdl = new CountDownLatch(1);
 
     private static <T> Set<T> setOf(Iterable<T> it) {
diff --git a/test/jdk/jdk/internal/reflect/constantPool/ConstantPoolTest.java b/test/jdk/jdk/internal/reflect/constantPool/ConstantPoolTest.java
index f53b6cf0032..aabbadb3a0d 100644
--- a/test/jdk/jdk/internal/reflect/constantPool/ConstantPoolTest.java
+++ b/test/jdk/jdk/internal/reflect/constantPool/ConstantPoolTest.java
@@ -36,6 +36,8 @@
 import java.lang.classfile.ClassFile;
 import java.util.HashMap;
 import java.util.Map;
+
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.reflect.ConstantPool;
 import jdk.test.lib.Asserts;
@@ -48,7 +50,7 @@
 public class ConstantPoolTest {
 
     private static final Class<?> TEST_CLASS = ConstantPoolTestDummy.class;
-    private static final ConstantPool CP = SharedSecrets.getJavaLangAccess()
+    private static final ConstantPool CP = SharedSecrets.get(JavaLangAccess.class)
             .getConstantPool(TEST_CLASS);
 
     @ParameterizedTest
diff --git a/test/jdk/sun/nio/cs/TestEncoderReplaceUTF16.java b/test/jdk/sun/nio/cs/TestEncoderReplaceUTF16.java
index 6ab49d91c6a..d0cad5e36f0 100644
--- a/test/jdk/sun/nio/cs/TestEncoderReplaceUTF16.java
+++ b/test/jdk/sun/nio/cs/TestEncoderReplaceUTF16.java
@@ -51,7 +51,7 @@
 
 class TestEncoderReplaceUTF16 {
 
-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final JavaLangAccess JLA = SharedSecrets.get(JavaLangAccess.class);
 
     /**
      * Character sets known to be absent of non-Latin-1 {@linkplain CoderResult#isUnmappable() unmappable} characters.
diff --git a/test/jdk/tools/jlink/plugins/SystemModuleDescriptors/SystemModulesTest.java b/test/jdk/tools/jlink/plugins/SystemModuleDescriptors/SystemModulesTest.java
index 2ec7c10394a..f8b1d8ab9a9 100644
--- a/test/jdk/tools/jlink/plugins/SystemModuleDescriptors/SystemModulesTest.java
+++ b/test/jdk/tools/jlink/plugins/SystemModuleDescriptors/SystemModulesTest.java
@@ -52,7 +52,7 @@
 
 public class SystemModulesTest {
     private static final JavaLangModuleAccess JLMA =
-        SharedSecrets.getJavaLangModuleAccess();
+        SharedSecrets.get(JavaLangModuleAccess.class);
     private static final String OS_NAME = System.getProperty("os.name");
     private static final String OS_ARCH = System.getProperty("os.arch");
     //  system modules containing no package
